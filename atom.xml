<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zxlg&#39;s notes</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://happylg.cn/"/>
  <updated>2019-08-12T12:15:47.000Z</updated>
  <id>http://happylg.cn/</id>
  
  <author>
    <name>zxlg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《薛兆丰的经济学讲义》读书笔记</title>
    <link href="http://happylg.cn/2019/07/22/ecnomics-lecture-notes/"/>
    <id>http://happylg.cn/2019/07/22/ecnomics-lecture-notes/</id>
    <published>2019-07-22T13:21:44.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h2><p>这是一本让你思维得到拓展的一本书，配合经典的法院判例，生动的诠释了枯燥难懂的经济学词汇，能够培养自己的经济学思维，让你变得更理性，值得一读。</p><img src="/img/ecnomics-lecture-notes.jpg" class="img-center" width="350" title="薛兆丰的经济学讲义"><h2 id="四大基本约束"><a href="#四大基本约束" class="headerlink" title="四大基本约束"></a>四大基本约束</h2><ol><li>东西不够</li><li>生命有限</li><li>互相依赖</li><li>需要协调</li></ol><h2 id="稀缺，为何商业是最大的慈善"><a href="#稀缺，为何商业是最大的慈善" class="headerlink" title="稀缺，为何商业是最大的慈善"></a>稀缺，为何商业是最大的慈善</h2><h3 id="真实世界-经济学的视角"><a href="#真实世界-经济学的视角" class="headerlink" title="真实世界 | 经济学的视角"></a>真实世界 | 经济学的视角</h3><h4 id="战俘营里的经济学"><a href="#战俘营里的经济学" class="headerlink" title="战俘营里的经济学"></a>战俘营里的经济学</h4><p>战俘营是一个微型社会，有人的地方就有交易</p><ol><li>货币： 香烟， 劣币驱逐良币</li><li>价格与价格波动： 面包的价格会随发放面包的时间波动</li><li>通胀与紧缩： 营房周围发生爆炸，差点没命，今朝有酒今朝醉， 都抽起了香烟，导致通货紧缩。听说红十字会送一批香烟过来，物品价格大涨，但是之后被证实为谣言，导致泡沫被戳破，价格大幅回落。</li></ol><p>结论：经济规律在哪里都起作用</p><a id="more"></a><h4 id="马粪争夺案"><a href="#马粪争夺案" class="headerlink" title="马粪争夺案"></a>马粪争夺案</h4><p>一个人将马粪堆积起来放在路边准备明天再收取，但是第二天过来发现马粪被人收走了。</p><p>四种说法：</p><ol><li>溯源说： 马粪归马的主人</li><li>位置说： 在什么位置就是谁的，在公家的马路上，所以谁都可以拿走</li><li>标记说： 若给马粪做了标记，那就是你的</li><li>劳动说： 帮工们花了功夫才把马粪堆好，所以应该给付出劳动的人</li></ol><p>法官最后支持了劳动说，只有这样社会的财富才会越来越多。</p><p><strong>公正背后是效率的考量</strong>： 保护产权是要消耗资源的，这种消耗越大，资源的净值越低；社会的道德规范越是能够帮助降低这种消耗，社会财富的积累就越多。<br>当我们讨论公正的问题时，背后的含义往往是：这是符合效率标准的。不是单人效率的考量，而是整体社会长远发展的效率的考量。因为有效，所以公平。</p><h4 id="看得见的和看不见的"><a href="#看得见的和看不见的" class="headerlink" title="看得见的和看不见的"></a>看得见的和看不见的</h4><p>破窗理论：窗子打碎了，花钱买一块新玻璃，可以推动经济的发展。殊不知，买玻璃的钱可以节省下来去做其他的事，这个社会的财富减少了。<br>破窗理论变种：战争和国家发展（战争有利于国家发展），工人就业（机器影响工人就业），节省物资（使用塑料袋不环保）</p><h4 id="区分愿望与结果"><a href="#区分愿望与结果" class="headerlink" title="区分愿望与结果"></a>区分愿望与结果</h4><p>坏人干坏事的影响其实有限，而美好愿望不一定带来美好结果，好人好心不一定干好事：如最近的租房补贴</p><p>经济学是研究“事与愿违”的规律。美好的愿望不一定带来美好的结果，坏人干坏事的影响其实有限。那些一眼就能看出好坏的思想，我们能够识别并抵制，倒是那些用良好愿望包装起来的思想，我们比较难以识别。<br>经济学与自然科学相同的地方在于，它研究的是不以人的意志为转移的客观规律–经济学关心的是事与愿违的现象，而不是事与愿符的现象。</p><h3 id="人性观-人是理性与自私的吗？"><a href="#人性观-人是理性与自私的吗？" class="headerlink" title="人性观 | 人是理性与自私的吗？"></a>人性观 | 人是理性与自私的吗？</h3><h4 id="不确定性、进化与经济理论"><a href="#不确定性、进化与经济理论" class="headerlink" title="不确定性、进化与经济理论"></a>不确定性、进化与经济理论</h4><p>一种说法：经济学是建立在“人是理性的”这一认识基础之上的。它假定人是理性的，每个人都想用最小的代价来获得最大的利益。</p><p>万物存活看条件，和理性与否无关。现实世界中，往往不存在最优，其实每个人生活在世界上，追求的不是最优，而是存活。（阿尔钦）<br>经济学关系的是存活的条件。经济学研究的是在什么条件下，人能够存活下来，而如果条件发生了改变，人们存活的情况又会发生怎样的改变。（进化论视角）</p><h4 id="亚当·斯密的人性观"><a href="#亚当·斯密的人性观" class="headerlink" title="亚当·斯密的人性观"></a>亚当·斯密的人性观</h4><ol><li>人是自私的，那些完全不自私的人，连自己都不爱的人，自暴自弃的人，在社会上是不会受到尊重的。</li><li>人不仅仅是自私的，同时还具有同情心，也就是有一种设身处地为他人着想的能力。</li><li>人的同情心是随着人与人之间距离的拉远而急速减弱的。</li></ol><p>正因如此，斯密写下了这样一段警世恒言：“我们的晚餐，并非来自屠户、酿酒商或面包师的恩惠，而是出自他们自利的打算。我们不说唤起他们利他心的话，而说唤起他们利己心的话。我们不说自己有需要，而说对他们有利。”</p><h5 id="小圈子靠爱心，大世界靠市场"><a href="#小圈子靠爱心，大世界靠市场" class="headerlink" title="小圈子靠爱心，大世界靠市场"></a>小圈子靠爱心，大世界靠市场</h5><p>斯密的重要建议是：不要搞混了，不要在家庭、朋友圈里斤斤计较，过分讲究市场规则，也不要在市场上强求陌生人表现出不切实际的爱心。</p><h4 id="铅笔的故事"><a href="#铅笔的故事" class="headerlink" title="铅笔的故事"></a>铅笔的故事</h4><p>一只铅笔是由成千上万人合作完成的。</p><p>亚当 · 斯密“看不见的手”——在没有强制的情况下合作的可能性</p><h4 id="商业是最大的慈善"><a href="#商业是最大的慈善" class="headerlink" title="商业是最大的慈善"></a>商业是最大的慈善</h4><p>四大原因让行善扶贫难见成效:</p><ol><li>缺乏反馈机制(无论好坏的慈善，反馈都是想继续要)</li><li>委托代理问题(花的不是自己的钱)</li><li>所托非人问题(比如由某企业造成的贫困，又让某企业去扶贫)</li><li>养懒汉效应</li></ol><p>商业从根部上大幅度改善了我们的生活，商业是最大的慈善</p><h3 id="区别对待-选择的标准"><a href="#区别对待-选择的标准" class="headerlink" title="区别对待 | 选择的标准"></a>区别对待 | 选择的标准</h3><h4 id="稀缺"><a href="#稀缺" class="headerlink" title="稀缺"></a>稀缺</h4><p>经济学最基本假设不是人本理性或人本自私，这都不是完全成立的。最基本的假设是：稀缺！</p><p>稀缺是一个基本事实</p><p>稀缺的原因有二：</p><ol><li>我们想要的东西， 别人也想要。且人的需求在不断变化，不断升级</li><li>人的欲望无限。物质越丰富，需求就越新奇</li></ol><h4 id="选择和歧视"><a href="#选择和歧视" class="headerlink" title="选择和歧视"></a>选择和歧视</h4><p>由于东西总是不够的，资源总是稀缺的，人们在利用有限资源的时候，就不得不对资源的用途进行选择；而每当要做选择时，都必须采取某种选择的标准；一旦确定了选择标准，就意味着存在区别对待，而区别对待就是歧视。</p><p>只要稀缺不可避免，选择就不可避免，区别对待就不可避免，歧视也就不可避免。</p><p>稀缺必然导致歧视。所以我们不应该问要不要歧视，而是要问应该如何歧视。</p><h4 id="凡歧视必得付代价"><a href="#凡歧视必得付代价" class="headerlink" title="凡歧视必得付代价"></a>凡歧视必得付代价</h4><p>贝克尔在博士论文《歧视经济学》（ The Economics ofDiscrimination ）中说，歧视别人的人，自己也得付出代价。</p><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><ol><li>偏好</li><li>信息不对称</li></ol><p>房间突然出现一只老虎，你拔腿就跑的故事是说，人们经常以偏概全做判断，那是不得已，因为信息费用很高。以偏概全做判断当然会发生错误，但是跟人们要付出的成本相比，还是值得的。</p><h5 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h5><p>经常有人说，美国人怎么样、日本人怎么样、韩国人怎么样。这都是一种以偏概全的视角，这种视角是一种歧视。但了解陌生人是有成本的，以偏概全（歧视）能让我们以最低的成本获取一些初步的印象。</p><p>当然，以偏概全是要付出代价的。错误的歧视，有可能要付出巨大代价。 顺着这个思路去想，我们会明白歧视造成的后果越严重，人们就越有积极性去减少歧视。如果歧视带来的后果不太严重，人们就会很随便地歧视别人。当我们不需要付出多少代价时，就会纵容自己歧视的习惯；当我们要付出很高代价时，就会节制自己歧视的习惯。</p><p>因为在偏远的小镇，居民的同质性强，歧视外人不会有多大损失，而在纽约这样的多种族集聚的地方，如果歧视别人，就得蒙受巨大的损失。并不是人生下来就心胸宽广，人们不歧视别人的心态，是在竞争当中慢慢习得的。</p><h2 id="成本，不要只盯着钱"><a href="#成本，不要只盯着钱" class="headerlink" title="成本，不要只盯着钱"></a>成本，不要只盯着钱</h2><h3 id="选择偏好-放弃的最大价值"><a href="#选择偏好-放弃的最大价值" class="headerlink" title="选择偏好 | 放弃的最大价值"></a>选择偏好 | 放弃的最大价值</h3><h4 id="一句话给成本下定义"><a href="#一句话给成本下定义" class="headerlink" title="一句话给成本下定义"></a>一句话给成本下定义</h4><h5 id="成本就是放弃了的最大代价"><a href="#成本就是放弃了的最大代价" class="headerlink" title="成本就是放弃了的最大代价"></a>成本就是放弃了的最大代价</h5><p>Cost is the best opportunity foregone.</p><h5 id="沉没成本不是成本"><a href="#沉没成本不是成本" class="headerlink" title="沉没成本不是成本"></a>沉没成本不是成本</h5><p>成本是放弃了的最大代价，而如果没什么可放弃的，也就不存在成本。沉没成本，就是指那些已经发生但不可收回的支出。当我们没办法再收回、没办法再放弃时，就不存在成本。凡是提到成本，我们一定是向前（未来）看，而不是向后（过去）看的。所以，沉没成本不是成本。</p><h4 id="你的成本由别人定义"><a href="#你的成本由别人定义" class="headerlink" title="你的成本由别人定义"></a>你的成本由别人定义</h4><ol><li>负面的感受不是成本</li><li>你的成本由别人决定</li><li>你的职业范围由社会决定</li></ol><p>今天的人喜欢讲“不忘初心”，但为什么不忘初心那么难呢？因为当初你有“初心”的时候，选择的机会可能没那么多，所以比较容易坚持。但随着境遇的变化，机会增加，你要坚持原来的看法就越来越难了，成本就越来越高了，放弃的东西就越来越多了。因此“不忘初心”不是一件容易的事。</p><p>其实，你今天能选择的职业，只是一个非常狭窄的范围，这是今天大多数人都认可而存在的职业范围。你在这当中要选择自己兴趣最大、付出成本最低，而且在相当一段长时间里总收入最高的职业。 经济学的看法是：你拥有你的生命，但是你的生命是怎么度过的，你的职业是怎么选择的，很大程度上是由社会上其他人决定的。</p><p>经济学的看法是：你拥有你的生命，但是你的生命是怎么度过的，你的职业是怎么选择的，很大程度上是由社会上其他人决定的。</p><h4 id="别只盯着钱"><a href="#别只盯着钱" class="headerlink" title="别只盯着钱"></a>别只盯着钱</h4><p>货币成本有别于全部成本（时间成本，假货损失的成本）</p><p>给士兵发薪水比免费征兵更便宜：义务征兵时，政府付出的货币成本确实比较低，但是他没有看到另外一个重要成本，就是放弃了的最大代价。</p><blockquote><p>一个青年，被征去当兵以后，就不能从事他原来的职业了。这时虽然多了一个廉价的士兵，但可能少了一位化学家、一个小提琴手，或是一位企业家。总的来说，义务兵制的成本是非常高的，因为它放弃的代价是不可估量的。 有人会说，那兵源问题如何解决呢？最好的办法，是采用志愿兵制，政府出钱请士兵。政府说我出1元钱请人当兵，当然没人愿意干，出两元钱也没人愿意，出100元、1000元呢？最后可能出到2000元时，就开始有人愿意了。 第一个愿意接受2000元去当兵的人，是在别处机会最少的人，也是认为当兵能给他带来最大满足感的人，这种人是最适合当兵的。也就是说，政府能够以最低的代价招募到最合适的兵，这才是我们解决兵源问题的好办法。 经济学家米尔顿·弗里德曼曾经给美国政府提过不少建议，大多数都没被接受。但是这一条，<strong>建议将征兵制改为志愿兵制</strong>，就被美国政府接受了。这对于减少美国的国防总成本，提高征兵效率，提高兵员质量，有极大的帮助。</p></blockquote><p>中间商赚差价，让商品价格更便宜：在大多数情况下，中间商在帮助我们减少总成本，而不是增加总成本，而中间商之间的竞争，会使物流的总成本降到最低。</p><h3 id="资源的价值-重新理解盈利和亏损"><a href="#资源的价值-重新理解盈利和亏损" class="headerlink" title="资源的价值 | 重新理解盈利和亏损"></a>资源的价值 | 重新理解盈利和亏损</h3><h4 id="从成本的角度理解盈利和亏损"><a href="#从成本的角度理解盈利和亏损" class="headerlink" title="从成本的角度理解盈利和亏损"></a>从成本的角度理解盈利和亏损</h4><h5 id="凡是盈利都是意外"><a href="#凡是盈利都是意外" class="headerlink" title="凡是盈利都是意外"></a>凡是盈利都是意外</h5><p>当我们得知这个碗不是一个普通的碗，而是一个珍贵古董的时候，我们获得了盈利。凡是盈利都是意外，英文叫作windfall profit，也译成“横财”。横财是在我们意识到这个商品的价值跟预期不一样的瞬间产生的。</p><p>从那一刻起，这个产品的价值就发生了变化。我们继续使用这个产品的成本，就要以新的价值为标准进行估算了。赚取利润只是瞬间的事情，一旦赚取了利润，这个碗就变成了另外一种资源。如果我们再把这个碗用作其他用途，那么放弃了的最大代价，就要以它在博物馆里赚取收入的水平来计算了。所以说，盈利提高了资源未来使用的成本。</p><h5 id="亏损会降低资源使用成本"><a href="#亏损会降低资源使用成本" class="headerlink" title="亏损会降低资源使用成本"></a>亏损会降低资源使用成本</h5><p>无论是盈利还是亏损，在经济学里，都是意外发生的。每当发生意外，我们就重新调整资源的未来估值，而资源使用的成本，就要按照这个新的估值来计算。所以，一旦出现盈利，资源的使用成本就会提高；一旦出现亏损，资源的使用成本就会下降。</p><h5 id="重新估值不难，难的是找出盈利或亏损的原因"><a href="#重新估值不难，难的是找出盈利或亏损的原因" class="headerlink" title="重新估值不难，难的是找出盈利或亏损的原因"></a>重新估值不难，难的是找出盈利或亏损的原因</h5><p>[未完待续]</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;总评&quot;&gt;&lt;a href=&quot;#总评&quot; class=&quot;headerlink&quot; title=&quot;总评&quot;&gt;&lt;/a&gt;总评&lt;/h2&gt;&lt;p&gt;这是一本让你思维得到拓展的一本书，配合经典的法院判例，生动的诠释了枯燥难懂的经济学词汇，能够培养自己的经济学思维，让你变得更理性，值得一读。&lt;/p&gt;
&lt;img src=&quot;/img/ecnomics-lecture-notes.jpg&quot; class=&quot;img-center&quot; width=&quot;350&quot; title=&quot;薛兆丰的经济学讲义&quot;&gt;
&lt;h2 id=&quot;四大基本约束&quot;&gt;&lt;a href=&quot;#四大基本约束&quot; class=&quot;headerlink&quot; title=&quot;四大基本约束&quot;&gt;&lt;/a&gt;四大基本约束&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;东西不够&lt;/li&gt;
&lt;li&gt;生命有限&lt;/li&gt;
&lt;li&gt;互相依赖&lt;/li&gt;
&lt;li&gt;需要协调&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;稀缺，为何商业是最大的慈善&quot;&gt;&lt;a href=&quot;#稀缺，为何商业是最大的慈善&quot; class=&quot;headerlink&quot; title=&quot;稀缺，为何商业是最大的慈善&quot;&gt;&lt;/a&gt;稀缺，为何商业是最大的慈善&lt;/h2&gt;&lt;h3 id=&quot;真实世界-经济学的视角&quot;&gt;&lt;a href=&quot;#真实世界-经济学的视角&quot; class=&quot;headerlink&quot; title=&quot;真实世界 | 经济学的视角&quot;&gt;&lt;/a&gt;真实世界 | 经济学的视角&lt;/h3&gt;&lt;h4 id=&quot;战俘营里的经济学&quot;&gt;&lt;a href=&quot;#战俘营里的经济学&quot; class=&quot;headerlink&quot; title=&quot;战俘营里的经济学&quot;&gt;&lt;/a&gt;战俘营里的经济学&lt;/h4&gt;&lt;p&gt;战俘营是一个微型社会，有人的地方就有交易&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;货币： 香烟， 劣币驱逐良币&lt;/li&gt;
&lt;li&gt;价格与价格波动： 面包的价格会随发放面包的时间波动&lt;/li&gt;
&lt;li&gt;通胀与紧缩： 营房周围发生爆炸，差点没命，今朝有酒今朝醉， 都抽起了香烟，导致通货紧缩。听说红十字会送一批香烟过来，物品价格大涨，但是之后被证实为谣言，导致泡沫被戳破，价格大幅回落。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结论：经济规律在哪里都起作用&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://happylg.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="http://happylg.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>服务端渲染与nuxt</title>
    <link href="http://happylg.cn/2019/06/06/nuxt/"/>
    <id>http://happylg.cn/2019/06/06/nuxt/</id>
    <published>2019-06-06T01:17:30.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>有利于SEO</li><li>首屏加载时间减少</li></ol><h3 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h3><ol><li>开发 客户端代码不能用在服务端</li><li>需要一个服务端环境，耗费更多的服务器资源</li></ol><a id="more"></a><h2 id="vue服务端渲染"><a href="#vue服务端渲染" class="headerlink" title="vue服务端渲染"></a>vue服务端渲染</h2><p>服务端渲染时已经得到了数据的状态，默认情况下禁用响应式，只有<code>beforeCreate</code>和<code>created</code>会在服务的渲染时会被调用。</p><p>避免在<code>beforeCreate</code>和<code>created</code>生命周期中产生全局副作用的代码，ssr没有不能操作之后的生命周期以消除这些副作用。</p><p>通用代码不可接受特定平台的 API, 比如<code>window</code>和<code>document</code></p><h2 id="nuxt基础认知"><a href="#nuxt基础认知" class="headerlink" title="nuxt基础认知"></a>nuxt基础认知</h2><p>开箱即用的基于vue的ssr框架</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="nuxt-config-js"><a href="#nuxt-config-js" class="headerlink" title="nuxt.config.js"></a>nuxt.config.js</h3><p>配置文件，构建nuxt的重要文件</p><h3 id="nuxt服务端渲染"><a href="#nuxt服务端渲染" class="headerlink" title="nuxt服务端渲染"></a>nuxt服务端渲染</h3><ol><li>服务端渲染：第一次加载，网址访问或者刷新页面等，不走前端路由而直接访问服务器</li><li>客户端渲染：通过前端路由访问</li></ol><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><img src="/img/nuxt-lifecycle-diagram.jpg" class="img-center" width="500" title="nuxt生命周期"><p>其中，红框只在服务端执行，黄框在服务端和客户端均执行，绿框只在客户端执行</p><p>服务端是没有<code>window</code>和<code>document</code>，所以使用<code>window</code>和<code>document</code>时需要加执行环节判断</p><h3 id="异步数据加载，asyncData和fetch"><a href="#异步数据加载，asyncData和fetch" class="headerlink" title="异步数据加载，asyncData和fetch"></a>异步数据加载，asyncData和fetch</h3><p>async: 数据获取（会在服务端执行）<br>fetch: 数据获取，存于store</p><p>参数为<a href="https://nuxtjs.org/api/context" target="_blank" rel="noopener">ctx</a>会有大量数据，以供调用</p><p>支持ES7 async进行异步获取数据</p><h3 id="page目录与路由"><a href="#page目录与路由" class="headerlink" title="page目录与路由"></a>page目录与路由</h3><p>Nuxt依据pages目录结构自动生成vue-router模块的路由配置。</p><h3 id="middleware"><a href="#middleware" class="headerlink" title="middleware"></a>middleware</h3><p>页面渲染之前执行，可做一些登录态等的处理</p><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>初始化vue实例前执行的代码，可以按照一些vue插件等</p><p>[未完待续]</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;服务端渲染&quot;&gt;&lt;a href=&quot;#服务端渲染&quot; class=&quot;headerlink&quot; title=&quot;服务端渲染&quot;&gt;&lt;/a&gt;服务端渲染&lt;/h2&gt;&lt;h3 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;有利于SEO&lt;/li&gt;
&lt;li&gt;首屏加载时间减少&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;劣势&quot;&gt;&lt;a href=&quot;#劣势&quot; class=&quot;headerlink&quot; title=&quot;劣势&quot;&gt;&lt;/a&gt;劣势&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开发 客户端代码不能用在服务端&lt;/li&gt;
&lt;li&gt;需要一个服务端环境，耗费更多的服务器资源&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="vue" scheme="http://happylg.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="http://happylg.cn/tags/vue/"/>
    
      <category term="nuxt" scheme="http://happylg.cn/tags/nuxt/"/>
    
  </entry>
  
  <entry>
    <title>如何选择相同类的第一个和最后一个元素</title>
    <link href="http://happylg.cn/2019/04/29/first-and-last-class-selector/"/>
    <id>http://happylg.cn/2019/04/29/first-and-last-class-selector/</id>
    <published>2019-04-29T11:55:30.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>项目中，使用</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div:first-child // 父元素的第一个div元素</span><br><span class="line">div:first-of-type // 父元素下的div元素中的第一个</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:last-child</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:last-of-type</span></span><br></pre></td></tr></table></figure><p>四个伪类，选出第一个或最后一个元素，并赋予相应的样式。</p><p>但是遇到了一个问题，就是如果对一个<code>class</code>类使用伪类，会发生意想不到的效果。因为这些伪类的作用对象是元素(tag)而不是类(class)，所以如果相同的类却有不同的元素类型，会发生不同的效果。</p><a id="more"></a><h2 id="使用last-of-type选择最后一个类"><a href="#使用last-of-type选择最后一个类" class="headerlink" title="使用last-of-type选择最后一个类"></a>使用last-of-type选择最后一个类</h2><p>选择出父元素内的最后一个class为<code>item</code>的子元素。</p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:last-of-type</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对最后的元素使用<code>:last-of-type</code>修饰改为红色，比较两个模块可以看出，当不同的元素拥有相同的类时，不同元素的最后一个都会变为红色，无法选出最后一个类。first也是类似。代码见：<a href="https://codepen.io/zxlg/pen/pBBjmJ" target="_blank" rel="noopener">https://codepen.io/zxlg/pen/pBBjmJ</a></p><h2 id="使用last-child选择最后一个类"><a href="#使用last-child选择最后一个类" class="headerlink" title="使用last-child选择最后一个类"></a>使用last-child选择最后一个类</h2><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> <span class="selector-class">.item</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中对最后的元素使用<code>:last-child</code>修饰改为红色，比较两个模块可以看出，当最后一个元素的类不是设定的类<code>item</code>, 则无法选出父元素内的子元素的最后一个类。first也是类似。代码见：<a href="https://codepen.io/zxlg/pen/ZZZWdP" target="_blank" rel="noopener">https://codepen.io/zxlg/pen/ZZZWdP</a></p><h2 id="可用的选择第一个类的方法"><a href="#可用的选择第一个类的方法" class="headerlink" title="可用的选择第一个类的方法"></a>可用的选择第一个类的方法</h2><p>网上有类似的讨论，只能得到一个实现获取第一个类的方法。如上所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.A</span> &#123;</span><br><span class="line">    // 所有.A元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.A</span> ~ <span class="selector-class">.A</span> &#123;</span><br><span class="line">    // 所有.A元素其前拥有兄弟元素.A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个作用域相减，得到第一个<code>.A</code>的元素。</p><p>若想要实现选中某个类的最后一个，只能暂用js去实现较为稳妥。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://www.zhangxinxu.com/wordpress/2011/06/css3%E9%80%89%E6%8B%A9%E5%99%A8nth-child%E5%92%8Cnth-of-type%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82/" target="_blank" rel="noopener">CSS3选择器:nth-child和:nth-of-type之间的差异</a></li><li><a href="https://stackoverflow.com/questions/2717480/css-selector-for-first-element-with-class" target="_blank" rel="noopener">CSS selector for first element with class</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;项目中，使用&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;div:first-child // 父元素的第一个div元素&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;div:first-of-type // 父元素下的div元素中的第一个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:last-child&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;div&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:last-of-type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;四个伪类，选出第一个或最后一个元素，并赋予相应的样式。&lt;/p&gt;
&lt;p&gt;但是遇到了一个问题，就是如果对一个&lt;code&gt;class&lt;/code&gt;类使用伪类，会发生意想不到的效果。因为这些伪类的作用对象是元素(tag)而不是类(class)，所以如果相同的类却有不同的元素类型，会发生不同的效果。&lt;/p&gt;
    
    </summary>
    
      <category term="front" scheme="http://happylg.cn/categories/front/"/>
    
    
      <category term="css" scheme="http://happylg.cn/tags/css/"/>
    
      <category term="front" scheme="http://happylg.cn/tags/front/"/>
    
  </entry>
  
  <entry>
    <title>洛克菲勒留给儿子的38封信</title>
    <link href="http://happylg.cn/2019/04/05/Rockefeller-s-38-letters-to-his-son/"/>
    <id>http://happylg.cn/2019/04/05/Rockefeller-s-38-letters-to-his-son/</id>
    <published>2019-04-05T09:32:59.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总评"><a href="#总评" class="headerlink" title="总评"></a>总评</h1><p>身处这个迷茫，诱惑重重的时代，听着”平凡才是真“的“箴言”，很多青年错把平庸当作平凡，殊不知那些历经精彩的人生，回首往事时去谈平凡才有意味，譬如杨慎的《临江仙》，“滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中”。杨慎，金科状元，明朝三大才子之手，时正任翰林院修撰的杨慎，因“大礼议”受廷杖，削夺官爵，定罪为谪戍终老于云南永昌卫。而你又知道古今多少事？所以骚年，不要为赋新词强说愁，你需要的是把握当下，勇往直前，思考的是做好当下的每一件事，并做到知行合一，走向成功。</p><img src="/img/38-posts.png" class="img-center" width="350" title="洛克菲勒留给儿子的38封信"><p>无意中在雪球上看到了关于这本书的几篇文章，当时就决定好好看下这本书。看完之后颇有感慨，一些人生道理是我们没有真正知道的，所以更谈不上知行合一，以此记录下来一些总结和感悟，以备查阅。</p><h1 id="书籍总结"><a href="#书籍总结" class="headerlink" title="书籍总结"></a>书籍总结</h1><h2 id="第1封-好的起点并不决定好的终点"><a href="#第1封-好的起点并不决定好的终点" class="headerlink" title="第1封 好的起点并不决定好的终点"></a>第1封 好的起点并不决定好的终点</h2><blockquote><p>试想，我们这个世界如同一座高山，当你的父母生活在山巅时，你注定不会生活在山脚下；当你的父母生活在山脚下时，注定你不会生活在山巅。在多数情况下，父母所处的位置决定了孩子的人生起点。</p></blockquote><blockquote><p>但这并不意味着，起点不同，其人生结果也不同。世界上永远没有贫、富世袭之说，也永远没有成、败世袭之说，有的只是奋斗与成功的真理。我坚信，我们的命运由我们的行动决定，而并非完全由我们的出身决定。</p></blockquote><h2 id="第2封-运气靠策划"><a href="#第2封-运气靠策划" class="headerlink" title="第2封 运气靠策划"></a>第2封 运气靠策划</h2><blockquote><p>运气是策划的残余物质</p></blockquote><p>通过了解自己的目标，了解自己的实力和资源创造运气<br><a id="more"></a></p><h2 id="第3封-天堂与地狱的距离"><a href="#第3封-天堂与地狱的距离" class="headerlink" title="第3封 天堂与地狱的距离"></a>第3封 天堂与地狱的距离</h2><blockquote><p>事实上，雇主想要按时工作、诚实努力的雇员，他只将加薪与升迁机会留给那些极其努力、忠心、热心、效率高爱做事的雇员，因为他在做生意，而不是在做慈善事业，他需要的是那些更有价值的人。</p></blockquote><blockquote><p>一个人的野心不管有多么大，他至少得先起步才能到达高峰。一旦起步，继续前进就容易多了。工作越困难或不愉快，越要立刻去做，否则等的时间越久，就变得越困难、可怕。这有点儿像打枪，你瞄准时间越长，射击的机会就越渺茫。</p></blockquote><h2 id="第4封-自动自发，立即行动"><a href="#第4封-自动自发，立即行动" class="headerlink" title="第4封 自动自发，立即行动"></a>第4封 自动自发，立即行动</h2><blockquote><p>看看那些庸碌无为的普通人，你会发现，他们说的远比做的多，甚至只说不做。但他们个个都是找借口的行家，总会找各种借口来开脱，直到最后证明这件事不应该、没有能力或已经来不及做为止。</p></blockquote><blockquote><p>缺乏行动之人都有一个坏习惯：喜欢维持现状，拒绝改变。</p></blockquote><blockquote><p>我还没听过有人因为没有打扰别人、没有采取行动或要等别人下令才做事而受到赞扬的。那些在商界、政府、军队中的领袖，都是很有才能又实干、自动自发的人。那些站在场外袖手旁观的人永远当不上领导者。</p></blockquote><h2 id="第5封-心怀接受挑战的决心"><a href="#第5封-心怀接受挑战的决心" class="headerlink" title="第5封 心怀接受挑战的决心"></a>第5封 心怀接受挑战的决心</h2><blockquote><p>要想在竞争中获胜，就要经常保持警觉，当你不断看到对手想削弱你时，那就是竞争的开始。这时你需要知道自己拥有什么，也需要知道友善、温情可能会害了你，而后就是动用所有的资源和技巧，去赢得胜利。</p></blockquote><blockquote><p>当然，要想在竞争中获胜，勇气只是赢得胜利的其中一面，还要有实力。</p></blockquote><h2 id="第6封-为幸福前途抵押生命"><a href="#第6封-为幸福前途抵押生命" class="headerlink" title="第6封　为幸福前途抵押生命"></a>第6封　为幸福前途抵押生命</h2><blockquote><p>借钱不是坏事，只要你不把它看成像救生圈一样，只在危机时使用，而把它看做一种有力的工具，就可以用它来创造机会。否则，你就会掉入恐惧失败的泥潭而终无大成。</p></blockquote><p>慎重贷款！高杠杆也是容易出人命的！</p><blockquote><p>人生就是不断抵押的过程，为前途我们抵押青春，为幸福我们抵押生命。如果你不敢逼近底线，你就输了。为成功我们抵押冒险不值得吗？</p></blockquote><blockquote><p>在我从银行家手里接过巨款时，我抵押出去的不光是我的企业，还有诚实。我视合同、契约为神物，严格遵守合同，从不拖欠债务。我对投资人、银行家、客户，包括竞争对手，从不忘以诚相待，在同他们讨论问题时都坚持讲真话，从不捏造或含糊其辞，我深信谎言在阳光下就会暴露。</p></blockquote><h2 id="第7封-精神破产更可怕"><a href="#第7封-精神破产更可怕" class="headerlink" title="第7封　精神破产更可怕"></a>第7封　精神破产更可怕</h2><blockquote><p>我把失败当做一杯烈酒，咽下的是苦涩，吐出的却是精神。</p></blockquote><blockquote><p>人人都痛恨失败，然而，一旦避免失败成为你做事的动机，你就走上了怠惰之路。这非常可怕，甚至是种灾难。因为这预示着人可能要丧失可能存在的机会。</p></blockquote><blockquote><p>害怕失败而不敢冒险，不敢冒险就会错失眼前的机会。所以，儿子，为了避免机会丧失、保住竞争资格，遭受失败与挫折也物有所值！</p></blockquote><blockquote><p>乐观之人在苦难中看到机会，悲观之人在机会中会看到苦难。</p></blockquote><blockquote><p>梦想+失败+挑战=成功之道</p></blockquote><blockquote><p>年轻人，你的人生旅程才刚刚开始，所以我告诉你一个对未来很有帮助的启示，我并未失败过一万次，我只是发明了一万种行不通的方法。</p></blockquote><p>人生的字典没有失败，只有发现了一种行不通的方法。</p><h2 id="第9封-信念带领人走向成功"><a href="#第9封-信念带领人走向成功" class="headerlink" title="第9封　信念带领人走向成功"></a>第9封　信念带领人走向成功</h2><blockquote><p>我从不相信失败是成功之母，我坚信信心是成功之父。胜利是一种习惯，失败也是一种习惯。如果想成功，就得取得持续性的胜利。我不喜欢取得一时的胜利，我要的是持续性胜利，只有这样我才能成为强者。信心激发了我成功的动力。</p></blockquote><blockquote><p>采取“暂且试试看，但我想还是不会有什么结果”的态度，最后一定会失败。“不信”是消极力量。当你心中不以为然或产生怀疑时，你就会想出各种理由来支持你的“不信”。怀疑、不信、潜意识里认为会失败的倾向，以及内心不渴望成功都是导致失败的主因。心中存疑，就会失败。相信会胜利，就必定成功。</p></blockquote><p>发自内心的相信自己。</p><blockquote><p>信心的大小决定成就的大小。庸庸碌碌、得过且过的人，他们只能得到微小的报酬。他们相信不能做出伟大事业，他们就真的做不到。他们认为自己很不重要，他们所做的每一件事都显得无足轻重。久而久之，连他们的言行举止都会透露出缺乏自信。如果他们不能将自信抬高，他们就会在自我评估中畏缩，变得越来越渺小。而且他们如何看待自己，别人就会怎么看待他们，于是这种人在众人的眼光下就会变得更渺小。积极向前的人坚信自己有更大的价值，他就能得到很高的报酬。他相信他能处理艰巨的任务，真的就能做到。他所做的每一件事情，他的待人接物，他的个性、见解和想法，都证明他是专家，是一位重要人物。</p></blockquote><blockquote><p>照亮我的道路，不断给我勇气，让我愉快地正视人生理想的，正是信心。我无时无刻都不忘增强自信。我用成功的信念取代失败的想法。当面临困境时，我想到的是“我能赢”，而不是“我可能会输”。当与人竞争时，我想到的是“我和他们一样出色”，而不是“我没法跟他们比”。当机会出现时，我想到的是“我能做到”，而不是“我做不到”。</p></blockquote><blockquote><p>我经常提醒自己：你比你想象的还好。</p></blockquote><blockquote><p>成功的人只是相信自己、肯定自己所作所为的平凡人。永远不要、绝对不要廉价出售自己。</p></blockquote><h2 id="第10封-相信自己，忠于自己"><a href="#第10封-相信自己，忠于自己" class="headerlink" title="第10封　相信自己，忠于自己"></a>第10封　相信自己，忠于自己</h2><blockquote><p>我一直坚守一个原则：我可以欺骗敌人，但绝不欺骗自己。回击正在射击我的敌人，永远不会让我良心不安。</p></blockquote><blockquote><p>只有在对自己有利无害的情况下，我才表露自己的情感；我可以让对手教导我，但我永远不教导对手，无论我对那件事了解有多深；不管别人如何催促，不考虑周全绝不行动；我有自己的真理，只对自己负责；小心那些要求我以诚相待的人，他们是想在我这里捞到好处。</p></blockquote><p>三思而行，不要因为别人的催促而匆忙行动。</p><h2 id="第11封-贪心大有裨益"><a href="#第11封-贪心大有裨益" class="headerlink" title="第11封　贪心大有裨益"></a>第11封　贪心大有裨益</h2><blockquote><p>静静地回溯历史，检视人类的脚印，我们能得出这样的结论：没有一个社会不是建立在贪心之上。那些企图诋毁我的人，看似道德的守望者，但他们有谁不想独占自己拥有的东西？有谁不想掌控所有好的东西？有谁不想控制每个人都需要的一切？虚伪之人实在是太多了。</p></blockquote><blockquote><p>贪心没什么不好，我觉得贪心是件好事，人人都可以贪心。从贪心开始，才会有希望！”</p></blockquote><p>“贪”在这里更多的表达的是进取心</p><blockquote><p>就像那些演化家所告诉我们的那样，自然界不是仁慈无私的场所，而是适者生存的天地，我所在的文明社会也同样如此。如果你不贪心，或许你就会被别人吃掉，毕竟可口的甜点很少。</p></blockquote><blockquote><p>实际上，只要追逐名利的世界一天不被摧毁，只要幸福一天不变得像空气那样唾手可得，人类就一天不能停止贪心。</p></blockquote><blockquote><p>任何力量都不能阻止我放弃贪心，因为我想成功。贪心之下实现的成功并非罪恶，成功是一种高尚的追求，如果能以高尚的行为去获取成功，对人类的贡献会远比贫困时所能做的更多，我做到了！</p></blockquote><h2 id="第12封-地狱里住满了好人"><a href="#第12封-地狱里住满了好人" class="headerlink" title="第12封　地狱里住满了好人"></a>第12封　地狱里住满了好人</h2><blockquote><p>在这个世界上能出人头地的人，都是那些懂得去寻找自己理想环境的人，如果找不到理想环境，就会自己创造出来。</p></blockquote><h2 id="第13封-天下没有免费的午餐"><a href="#第13封-天下没有免费的午餐" class="headerlink" title="第13封　天下没有免费的午餐"></a>第13封　天下没有免费的午餐</h2><blockquote><p>这则故事的寓意很简单，一只动物要靠人类供给食物时，它的机智会消失，麻烦会随之而来。同样的情形也适用于人类，如果你想让一个人残废，只要给他一对拐杖再等上几个月就能达到目的；换言之，如果在一定时间段给一个人免费的午餐，他就会养成不劳而获的习惯。</p></blockquote><blockquote><p>资助金钱是一种错误，它会使一个人失去动力，不再节俭勤奋，而变得懒惰、不思进取。更为重要的是，当你向一个人施舍时，就等于否定了他的尊严，抢走了他的命运，这在我看来很不道德。作为富人，我有责任成为造福于人类的使者，却不能成为塑造懒汉的始作俑者。</p></blockquote><p>授人以鱼不如授人以渔</p><h2 id="第14封-懂得装傻的人才是真聪明"><a href="#第14封-懂得装傻的人才是真聪明" class="headerlink" title="第14封　懂得装傻的人才是真聪明"></a>第14封　懂得装傻的人才是真聪明</h2><blockquote><p>一头猪好好被夸奖一番，它就能爬上树。善于驱使别人的经营者、领导者或大有作为的人，他们懂得尊敬和赞美他人的艺术。这意味着他们要付出感情。而付出深厚感情的领导者最终必赢得胜利，并获得下属的更多敬重。</p></blockquote><blockquote><p>但是，受自尊心的驱使，很多有知识的人对“不懂”总是难以启齿，好像向别人请教是丢人的事，这是自作聪明，这种人永远都不会理解那句伟大的格言——每一次说不懂的机会，都会成为我们人生的转折点。</p></blockquote><blockquote><p>直至今日我都能清晰地记得一次装傻的情景，当我正为如何筹到1.5万美元而大伤脑筋时，我走在大街上都在苦思冥想它。说来很可笑，正当我满脑子闪现出借钱的想法时，有位银行家拦住了我的去路，他在马车上低声问我：“你想用5万美元吗，洛克菲勒先生？”我交了好运吗？我都不相信自己的耳朵了，但那一刻我并未表现出丝毫的急切，我看了看对方，慢条斯理地告诉他：“是这样……能给我24小时考虑考虑吗？”最终，我以最有利的条件与他达成了借款合同。</p></blockquote><blockquote><p>装傻会带给你很多的好处。它的含义是摆低姿态，换言之，就是隐藏你的聪明。越是聪明的人越有装傻的必要，因为就像那句格言所说的——越是成熟的稻子，越垂下稻穗。</p></blockquote><blockquote><p>“让我想想再说”，是我在经商中始终奉行的格言。我做事总有一个习惯，作决定之前，先冷静地思考，但我一旦作出决定，就将义无反顾地执行到底。</p></blockquote><p>让我想想！</p><h2 id="第15封-财富是勤奋的副产品"><a href="#第15封-财富是勤奋的副产品" class="headerlink" title="第15封　财富是勤奋的副产品"></a>第15封　财富是勤奋的副产品</h2><blockquote><p>但机会如同时间一样是平等的，为何我能抓住机遇成为巨富，而很多人却与机会擦肩而过呢？难道真如诋毁我的人所说，是因为我贪得无厌吗？不！是勤奋！机会只留给勤奋之人！我自年少时就笃信一条成功法则：财富是意外之物，是勤奋工作的副产品。每个目标的达成都来自勤奋思考与踏实行动。</p></blockquote><h2 id="第16封-不给失败找借口"><a href="#第16封-不给失败找借口" class="headerlink" title="第16封　不给失败找借口"></a>第16封　不给失败找借口</h2><blockquote><p>在我看来找借口是一种思想疾病，而严重染有这种病的人，无一例外都会失败，当然一般人也有一些轻微症状。但是，一个人越是成功，越不会找借口，处处亨通的人与那些没有什么作为的人之间最大的差异，就在于是否找借口。</p></blockquote><blockquote><p>有一句老话说得好：“我一直在为自己的破鞋子懊恼，直到我遇见一位没有脚的人。”</p></blockquote><blockquote><p>我从不屈从于运气，我相信因果定律。看看那些似是好运当头的人，你会发现并不是运气使然，而是计划和积极的思想带来的成果。再看看那些“运气不好”的人，你会发现背后都有明确的成因。成功者能面对挫折，从失败中学习，再创契机。平庸者往往就此灰心丧气。</p></blockquote><p>不给失败找借口，要为成功找理由</p><h2 id="第17封-手中握有成功的种子"><a href="#第17封-手中握有成功的种子" class="headerlink" title="第17封　手中握有成功的种子"></a>第17封　手中握有成功的种子</h2><blockquote><p>对于一个要去创业的贫寒之人而言，他们常常苦恼于没有资本。如果他们再害怕失败，就会变得犹疑不决，像蜗牛般缓慢行进，甚至止步于成功之路，而永无出头之日，所以我在给那个年轻人的回信中特别提醒他：“从贫穷通往富裕之路永远畅通无阻，重要的是你要有这样的信念：‘我就是最大的资本。’你要锻炼信念，不停地探究迟疑的原因，直到信念取代怀疑。你要了解，你自己不信的事，你无法达成；信念是带你前进的力量。”</p></blockquote><p>投资自己，让自己变得更强大，才能在需要你的时候不至于无能为力。</p><blockquote><p>印度戈尔康达钻石矿。　阿拉伯人的故事却带给我宝贵的人生教诲：你的钻石不在遥远的高山与大海之间，如果你下定决心去挖掘，钻石就在你家的后院。重要的是真诚地相信自己。</p></blockquote><blockquote><p>每个人都有理想，这种理想决定了他的努力和判断方向。就此意义而言，我觉得不相信自己的人就跟窃贼一样，因为任何一个不肯定自己，而且未充分发挥本身才能的人，可以说是向自己偷窃的人；而且在这个过程中，由于创造力低落，他也等于是从社会偷窃。由于没有人会从他自己那里故意偷窃，那些向自己偷窃的人，显然都是无意中偷窃了。然而这一罪状仍很严重，因为其所造成的损失跟故意偷窃一样严重。</p></blockquote><p>不相信自己　–&gt; 没有为自己(社会)创造应有的财富和价值　–&gt; 偷窃了自己(社会)的价值</p><h2 id="第18封-无权当穷人"><a href="#第18封-无权当穷人" class="headerlink" title="第18封　无权当穷人"></a>第18封　无权当穷人</h2><blockquote><p>儿子，没有比为赚钱而赚钱的人更可悲、更可鄙的，我懂得赚钱之道：要让金钱当我的奴隶，而不能让金钱奴役我。</p></blockquote><p>和平年代，没有任何理由做一个穷人。</p><h2 id="第19封-时刻怀有做第一的心态"><a href="#第19封-时刻怀有做第一的心态" class="headerlink" title="第19封　时刻怀有做第一的心态"></a>第19封　时刻怀有做第一的心态</h2><blockquote><p>人之所以被创造出来是有目的的，一个人不是在计划成功，就是在计划失败。</p></blockquote><blockquote><p>我相信勤奋会致富，但不相信努力为别人工作就一定成功。我住进百万富翁大街前就发现，我身边的很多穷人都是工作最努力的人。现实就是如此残酷，不管雇员努力与否，替老板工作而变得富有的人少之又少。替老板工作所得的薪金，只能在合理预期的情况下让雇员活下去，尽管雇员可能会赚到不少钱，但变得富有却很难。我一直视“努力工作定会致富”为谎言，从不把为别人工作当做积累可观财富的过程；相反，我非常相信为自己工作才能富有。我采取的一切行动都忠于我的伟大梦想和为实现这一梦想而不断达成的各个目标。</p></blockquote><p>为自己工作！</p><h2 id="第20封-敢于冒险才能创造机会"><a href="#第20封-敢于冒险才能创造机会" class="headerlink" title="第20封　敢于冒险才能创造机会"></a>第20封　敢于冒险才能创造机会</h2><blockquote><p>好奇才能发现机会，冒险才能利用机会。</p></blockquote><blockquote><p>如果你想知道既冒险又不招致失败的秘诀，你只需要记住一句话：大胆筹划，谨慎实施。</p></blockquote><p>大胆假设，小心求证</p><h2 id="第21封-侮辱是一种强大的动力"><a href="#第21封-侮辱是一种强大的动力" class="headerlink" title="第21封　侮辱是一种强大的动力"></a>第21封　侮辱是一种强大的动力</h2><blockquote><p>对他人的报复，就是对自己的攻击。</p></blockquote><blockquote><p>我知道任何轻微的侮辱都可能伤及尊严。但是，尊严不是天赐的，也不是别人给的，是你自己缔造的。尊严是精神产品，每个人的尊严都属于他自己，你认为自己有尊严，你就有尊严。所以，如果有人伤害你的感情、尊严，你要不为所动。如果死守你的尊严，就没有人能伤害你。</p></blockquote><p>自己对自身的尊重是尊重中最重要的部分。</p><h2 id="第22封-用实力让对手恐惧"><a href="#第22封-用实力让对手恐惧" class="headerlink" title="第22封　用实力让对手恐惧"></a>第22封　用实力让对手恐惧</h2><blockquote><p>要完成一笔好交易，最好的方法是强调其价值。而很多人会犯强调价格而非价值的错误</p></blockquote><h2 id="第23封-合作精神尤为重要"><a href="#第23封-合作精神尤为重要" class="headerlink" title="第23封　合作精神尤为重要"></a>第23封　合作精神尤为重要</h2><blockquote><p>范德比尔特将军一定明白了这样一个道理：往上爬的时候要对别人好一点儿，因为你走下坡路的时候会碰到他们。</p></blockquote><h2 id="第24封-相信自己才能成功"><a href="#第24封-相信自己才能成功" class="headerlink" title="第24封　相信自己才能成功"></a>第24封　相信自己才能成功</h2><blockquote><p>成功不能用一个人的身高、体重、学历或家庭背景来衡量，而是以他思想的“大小”来决定。我们思想的大小决定我们成就的大小。这其中最重要的一条就是我们要看重自己，克服人类最大的弱点——自卑，千万不要廉价出卖自己。你们比你们想象中的更伟大，所以，要将你们的思想扩大到你们真实的程度，绝不要看轻自己。</p></blockquote><p>看重自己，你比想象的更强大。</p><h2 id="第25封-让每一分钱都带来效益"><a href="#第25封-让每一分钱都带来效益" class="headerlink" title="第25封　让每一分钱都带来效益"></a>第25封　让每一分钱都带来效益</h2><blockquote><p>我之所以能取得巨大的成就，就在于我首先经营了人——所有的人。</p></blockquote><blockquote><p>我喜欢查尔斯先生最喜欢的一句格言：“珍惜时间和金钱。”我一直认为这是一句凝聚了伟大智慧的箴言。我相信绝大多数人都会喜欢它，却难以将其变成自己的思想信念和价值观，并永远溶入自己的血液中。</p></blockquote><blockquote><p>每一刻都是关键，每一个决定都会影响生命的过程，所以，我们要有作出决定的策略。作决定不易太快，遇到重要问题时，如果没有想好最后一步，就永远不要迈出第一步，要相信总有时间思考问题，也总有时间付诸行动，要有促进计划成熟的耐心。但一旦作出决定，就要像斗士那样忠实地去执行。</p></blockquote><blockquote><p>世界上有两种人永远不会富有：第一种是及时行乐者，他们喜欢过奢侈的生活，像苍蝇叮臭肉那样痴迷于奢侈品，他们挥霍无度，竭尽所能要拥有精美的服饰、昂贵的汽车、豪华的住宅以及价格不菲的艺术品。这种生活的确令人着迷，但缺乏理性，及时行乐者缺乏这样的警惕：他们这样做是在寻找增加负债的方法，他们会成为可怜的车奴、房奴，而一旦破产，他们就完了！第二种人喜欢攒钱，把钱存在银行里固然保险，但这跟把钱冷冻起来没什么两样，要知道靠利息不能发财。但有一种人会成为富人，比如在座的诸位，我们不寻找花销的方法，我们寻找、培养和管理各种投资的方法，因为我们知道财富是可以用来增值的，我们会把钱拿来投资创造更多的财富。但我们还要知道，让每一分钱都能带来效益！这正如约翰一贯的经商原则——每一分钱都要让它物有所值！”</p></blockquote><blockquote><p>珍惜时间和金钱”这句话却一直与我相伴。我没有理由浪费生命，浪费生命就等于扼杀自己，世界上没有比糟蹋自己更大的悲剧了。</p></blockquote><blockquote><p>我也不把安逸和享乐看做生活目的本身，因为我称其为猪的理想。</p></blockquote><p>创造是人的价值!</p><h2 id="第26封-忍耐就是策略"><a href="#第26封-忍耐就是策略" class="headerlink" title="第26封　忍耐就是策略"></a>第26封　忍耐就是策略</h2><blockquote><p>忍耐并非盲目的容忍，你需要冷静地考量情势，搞清你的决定是否会偏离或有害你的目标。</p></blockquote><blockquote><p>在我看来，忍耐并非忍气吞声，也绝非卑躬屈膝，它是一种策略，同时也是一种性格磨炼，它所孕育出的是好胜之心。</p></blockquote><blockquote><p>能忍人所不能忍之忤，才能为人所不能为之事。</p></blockquote><blockquote><p>在任何时候冲动都是我们最大的敌人。如果忍耐能化解不该发生的冲突，这样的忍耐永远是值得的；但是，如果坚持一意孤行，非但不能化解危机，还会带来更大的灾难。</p></blockquote><blockquote><p>在这个世界上我们要忍耐的人和事太多太多，而引诱我们感情用事的人和事也太多太多。所以，你要修炼自己管理情绪和控制情感的能力，要注意在作决策时不要受情绪所左右，而是完全根据需要来作决定，要永远知道自己想要什么。你还需要知道，在机会的世界里，没有太多的机会可以争取，如果你真的想成功，你一定要掌握并保护自己的机会，更要设法抢夺别人的机会。记住，要天天怀有一些忍耐的心，它会给你带来快乐、机遇和成功。</p></blockquote><h2 id="第27封-幸运之神眷顾勇者"><a href="#第27封-幸运之神眷顾勇者" class="headerlink" title="第27封　幸运之神眷顾勇者"></a>第27封　幸运之神眷顾勇者</h2><blockquote><p>幸运儿是因为幸运才表现得自信和大胆，还是他们的“运气”是自信和大胆的结果呢？我的答案是后者。</p></blockquote><p>越努力，越幸运</p><h2 id="第28封-用更好的办法把事情做得更好"><a href="#第28封-用更好的办法把事情做得更好" class="headerlink" title="第28封　用更好的办法把事情做得更好"></a>第28封　用更好的办法把事情做得更好</h2><blockquote><p>我的用人原则是被委以重任者要能找出更好的方法把事情做得更好。</p></blockquote><blockquote><p>各种计划都不可能达到绝对的完美，这意味着一切事物可以无止境地进行改良。我深知这一道理，所以我经常会再寻找一些更好的方法。我不会问自己：“我能不能做得更好？”我知道我一定办得到，所以我会问：“我要怎样才能做得更好？”</p></blockquote><p>##　第29封　结束意味着另一个开始</p><blockquote><p>第一个策略：一开始就要下决心，关注竞争状况和竞争者的资源。</p></blockquote><blockquote><p>第二个策略：研究和检视对手的情况，然后善用这种知识，来形成自己的优势。</p></blockquote><blockquote><p>第三个策略：你必须拥有积极正确的心态。</p></blockquote><h2 id="第30封-不要让小人拖后腿"><a href="#第30封-不要让小人拖后腿" class="headerlink" title="第30封　不要让小人拖后腿"></a>第30封　不要让小人拖后腿</h2><blockquote><p>我喜欢同那些永不屈服的人交朋友。有个聪明人说得好：我要挑战令人厌恶的逆境，因为智者告诉我，那是通往成功最明智的方向。只是这种人少之又少。</p></blockquote><blockquote><p>这种人绝不让悲观左右一切，绝不屈从各种阻力，更不相信自己只能浑浑噩噩虚度一生。他们活着的目的就是获得成就。这种人很乐观，因为他们一定要完成自己的心愿。这种人很容易成为各个领域的佼佼者。他们能真正地享受人生，也真正了解生命的可贵与价值。他们都盼望新的每一天，以及跟别人之间的新接触，因为他们把这些看成丰富人生的历练而热烈地接受。</p></blockquote><blockquote><p>你要多加防范那些说你不行的人，只能把他们的警告当做证明你一定办得到的挑战。你还要特别防范消极者破坏你迈向成功的计划，这种人随处可见，他们似乎专门破坏别人的进步与努力。千万要小心，要多多注意那些消极者，千万不要让他们破坏你的计划。不要让那些思想颓废、心胸狭窄的人妨碍你进步。那些幸灾乐祸、善妒之人都想看你失败，不要给他们机会。</p></blockquote><h2 id="第31封-目的是一切，做目的主义者"><a href="#第31封-目的是一切，做目的主义者" class="headerlink" title="第31封　目的是一切，做目的主义者"></a>第31封　目的是一切，做目的主义者</h2><blockquote><p>目的是我领导的依据，目的就是一切。</p></blockquote><blockquote><p>杰出的领导者都善于动用两种无形的力量：信任和尊重。当你诚实地说出你的目的时，你也传递了这样的信息：“因为我对你有足够的信任，所以我愿意向你表白。”它将开启让人信任之门，而在大门外，你拥抱的不仅是下属的能力，还有来自他们的忠诚——要凝聚力量来帮助你的忠诚。信赖别人并使别人信赖我，是我一生取得成就的重要因素。</p></blockquote><blockquote><p>公开你的目的，更能避免无益的推论。</p></blockquote><blockquote><p>目的表明的力量无可取代，它所传达出的不仅是一项声明，同时也是领导者对于个人行为勇敢坚决的誓言。</p></blockquote><p>想想你看这本书，看这篇文章的目的是什么？</p><h2 id="第32封-认清职责，拒绝推诿"><a href="#第32封-认清职责，拒绝推诿" class="headerlink" title="第32封　认清职责，拒绝推诿"></a>第32封　认清职责，拒绝推诿</h2><blockquote><p>如果我们想要永久生存，那么我们的领导方式就意味着断然拒绝为了任何理由，去责难任何一个人或任何一件事。责难就如同一片沼泽，一旦失足跌落进去，你便失去了立足点和前进的方向，你会变得动弹不得，陷入憎恨和挫折的困顿之中。结果只有一个：失去下属的尊重与支持。一旦落入这步田地，那你就好似一个将王冠拱手让给他人的国王，无法再主宰一切。</p></blockquote><blockquote><p>我的下属都知道我的基本原则：在标准石油公司没有责难、没有借口！这是我坚持的信条，每一个人都知道。我不会因为他们犯错而惩罚他们，但是我绝不能容忍不负责任的行为存在。我们的信念就是要彻底奉行。我们的箴言是支持、鼓励和尊重将被全心接受与加倍颂扬。只会找借口而不提供解决方式，在标准石油公司是无法容忍的。</p></blockquote><h2 id="第33封-善用每个人的智慧"><a href="#第33封-善用每个人的智慧" class="headerlink" title="第33封　善用每个人的智慧"></a>第33封　善用每个人的智慧</h2><blockquote><p>做你喜欢做的事，而其他事，就交由喜欢做这件事的人去做。</p></blockquote><blockquote><p>最完美的人就是那彻底投身于自己最擅长的活动的人。”</p></blockquote><blockquote><p>与很多人不同，我不以自己的好恶为优先选拔人才的标准，我用人并不会看他身上贴着什么标签，我看中的是他在工作中展示出来的能力。我喜欢自己的喜好，但更喜欢效率。</p></blockquote><h2 id="第34封-策略性思考是关键"><a href="#第34封-策略性思考是关键" class="headerlink" title="第34封　策略性思考是关键"></a>第34封　策略性思考是关键</h2><blockquote><p>我想你也可以获得这样的赞誉，只是你需要克制找寻简单、单向解决方案的冲动，乐于尝试能达成目标的各种可能性办法，拥有在困难面前付诸行动的耐心、勇气和胆略，以及不达目的决不收手的执着精神。</p></blockquote><blockquote><p>作为总裁，我只为部属设立清楚明确的方向或策略，但不会将自我局限于过分僵化的行动计划中。</p></blockquote><h2 id="第37封-充实你的心灵"><a href="#第37封-充实你的心灵" class="headerlink" title="第37封　充实你的心灵"></a>第37封　充实你的心灵</h2><blockquote><p>我们不能读那些文字商人的书，他们的书犹如瘟疫，散布无耻的邪念、讹误的消息和自负的愚蠢，他们的书只配捧在那些浅薄、庸俗的人手里。我们需要的是能给我们带来行动的信心与力量，能够将我们的人生推到另一个新高度和引导我们行善的书，</p></blockquote><p>#　结语</p><p>财富达到美国２.4%的那个男人，打破富不过三代说法的一个富六代家族创始人，捐献了自身财富的３５％的慈善家。希望这些他交给儿子的话能帮助到犹豫和迷茫的你。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;总评&quot;&gt;&lt;a href=&quot;#总评&quot; class=&quot;headerlink&quot; title=&quot;总评&quot;&gt;&lt;/a&gt;总评&lt;/h1&gt;&lt;p&gt;身处这个迷茫，诱惑重重的时代，听着”平凡才是真“的“箴言”，很多青年错把平庸当作平凡，殊不知那些历经精彩的人生，回首往事时去谈平凡才有意味，譬如杨慎的《临江仙》，“滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中”。杨慎，金科状元，明朝三大才子之手，时正任翰林院修撰的杨慎，因“大礼议”受廷杖，削夺官爵，定罪为谪戍终老于云南永昌卫。而你又知道古今多少事？所以骚年，不要为赋新词强说愁，你需要的是把握当下，勇往直前，思考的是做好当下的每一件事，并做到知行合一，走向成功。&lt;/p&gt;
&lt;img src=&quot;/img/38-posts.png&quot; class=&quot;img-center&quot; width=&quot;350&quot; title=&quot;洛克菲勒留给儿子的38封信&quot;&gt;
&lt;p&gt;无意中在雪球上看到了关于这本书的几篇文章，当时就决定好好看下这本书。看完之后颇有感慨，一些人生道理是我们没有真正知道的，所以更谈不上知行合一，以此记录下来一些总结和感悟，以备查阅。&lt;/p&gt;
&lt;h1 id=&quot;书籍总结&quot;&gt;&lt;a href=&quot;#书籍总结&quot; class=&quot;headerlink&quot; title=&quot;书籍总结&quot;&gt;&lt;/a&gt;书籍总结&lt;/h1&gt;&lt;h2 id=&quot;第1封-好的起点并不决定好的终点&quot;&gt;&lt;a href=&quot;#第1封-好的起点并不决定好的终点&quot; class=&quot;headerlink&quot; title=&quot;第1封 好的起点并不决定好的终点&quot;&gt;&lt;/a&gt;第1封 好的起点并不决定好的终点&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;试想，我们这个世界如同一座高山，当你的父母生活在山巅时，你注定不会生活在山脚下；当你的父母生活在山脚下时，注定你不会生活在山巅。在多数情况下，父母所处的位置决定了孩子的人生起点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;但这并不意味着，起点不同，其人生结果也不同。世界上永远没有贫、富世袭之说，也永远没有成、败世袭之说，有的只是奋斗与成功的真理。我坚信，我们的命运由我们的行动决定，而并非完全由我们的出身决定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;第2封-运气靠策划&quot;&gt;&lt;a href=&quot;#第2封-运气靠策划&quot; class=&quot;headerlink&quot; title=&quot;第2封 运气靠策划&quot;&gt;&lt;/a&gt;第2封 运气靠策划&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;运气是策划的残余物质&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过了解自己的目标，了解自己的实力和资源创造运气&lt;br&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://happylg.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书，励志书籍" scheme="http://happylg.cn/tags/%E8%AF%BB%E4%B9%A6%EF%BC%8C%E5%8A%B1%E5%BF%97%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>webpack+vue+vue-router</title>
    <link href="http://happylg.cn/2018/08/23/webpack-vue-vue-router/"/>
    <id>http://happylg.cn/2018/08/23/webpack-vue-vue-router/</id>
    <published>2018-08-23T01:31:51.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-vue-vue-router学习笔记"><a href="#webpack-vue-vue-router学习笔记" class="headerlink" title="webpack + vue + vue-router学习笔记"></a>webpack + vue + vue-router学习笔记</h1><h2 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm i -D webpack webpack-cli</span><br></pre></td></tr></table></figure><h2 id="建立代码目录"><a href="#建立代码目录" class="headerlink" title="建立代码目录"></a>建立代码目录</h2><p><img src="/img/webpack-note-directory.png" alt="目录图片"></p><h2 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h2><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &#123;extry file&#125;出填写入口文件的路径，本文中就是上述main.js的路径，</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> &#123;destination <span class="keyword">for</span> bundled file&#125;处填写打包文件的存放路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 填写路径的时候不用添加&#123;&#125;</span></span><br><span class="line">webpack &#123;entry file&#125; -o &#123;destination for bundled file&#125;</span><br></pre></td></tr></table></figure><ol><li>命令：<code>webpack app/main.js public/bundle.js</code></li><li>出错及更正：<code>ERROR in multi ./hello.js bundle.js Module not found: Error: Can&#39;t resolve &#39;bundle.js</code>，更正：webpack版本过高,原来的命令已经不适用了，更换打包命令：<code>webpack app/main.js -o public/bundle.js</code></li></ol><a id="more"></a><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>根目录新建<code>webpack.config.js</code>，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 环境</span></span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    <span class="comment">// 唯一入口</span></span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'app/main.js'</span>),</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        <span class="comment">// 打包后文件所在目录</span></span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'public'</span>),</span><br><span class="line">        <span class="comment">// 文件名</span></span><br><span class="line">        filename: <span class="string">'bundle.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根目录运行<code>webpack</code>打包程序</p><h3 id="npm配置"><a href="#npm配置" class="headerlink" title="npm配置"></a>npm配置</h3><p>npm配置文件<code>package.json</code>中配置<code>scripts</code>可以运行相应命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"vue-router-manual"</span>,</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">        <span class="attr">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">    <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"webpack"</span>: <span class="string">"^4.16.5"</span>,</span><br><span class="line">        <span class="attr">"webpack-command"</span>: <span class="string">"^0.4.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>npm run build</code>或者<code>npm run-script build</code>即可让webpack打包代码</p><h3 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h3><p>安装依赖：<code>npm i -D webpack-dev-server</code><br>webpack配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack本地服务器</span></span><br><span class="line">devServer: &#123;</span><br><span class="line">    contentBase: path.resolve(__dirname, <span class="string">'public'</span>), <span class="comment">// 本地服务器所加载的页面所在目录</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转</span></span><br><span class="line">    inline: <span class="literal">true</span>, <span class="comment">// 实时刷新</span></span><br><span class="line">    compress: <span class="literal">true</span>, <span class="comment">// 是否压缩</span></span><br><span class="line">    host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    port: <span class="number">9000</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行<code>webpack-dev-server</code>即可启动本地服务器</p><h3 id="应用vue框架"><a href="#应用vue框架" class="headerlink" title="应用vue框架"></a>应用vue框架</h3><p><img src="/img/vue-directory.png" alt="vue代码"></p><p>其中src中的main.js为入口文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="comment">// import Router from 'vue-router';</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./app.vue'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(root)</span><br></pre></td></tr></table></figure><p>app.vue为单页面组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;test&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">        msg: &quot; vue + vue-router + webpack&quot;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">    .test &#123;</span><br><span class="line">    color: coral;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h3 id="安装loaders"><a href="#安装loaders" class="headerlink" title="安装loaders"></a>安装loaders</h3><p>webpack中安装并使用loader进行代码的打包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> npm一次性安装多个依赖模块，模块之间用空格隔开</span></span><br><span class="line">npm i -D html-webpack-plugin</span><br><span class="line">npm i -D vue vue-loader vue-template-compiler</span><br><span class="line">npm i -D babel-core babel-loader babel-preset-es2015 style-loader css-loader url-loader file-loader</span><br></pre></td></tr></table></figure><p>webpack配置完善为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">'vue-loader/lib/plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 环境</span></span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成Source Maps，使调试更容易</span></span><br><span class="line">    <span class="comment">// eval-source-map只能在开发阶段使用</span></span><br><span class="line">    <span class="comment">// devtools: 'eval-source-map',</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 唯一入口</span></span><br><span class="line">    entry: path.resolve(__dirname, <span class="string">'src/main.js'</span>),</span><br><span class="line">    <span class="comment">// 出口</span></span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">// 打包后文件所在目录</span></span><br><span class="line">        filename: <span class="string">'index.js'</span> <span class="comment">// 文件名</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> htmlWebpackPlugin(),</span><br><span class="line">        <span class="keyword">new</span> VueLoaderPlugin()</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'vue-loader'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(gif|jpg|jpeg|svg)$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        limit: <span class="number">1024</span>,</span><br><span class="line">                        name: <span class="string">'name.[hash:6].[ext]'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// webpack本地服务器</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: path.resolve(__dirname, <span class="string">'public'</span>), <span class="comment">// 本地服务器所加载的页面所在目录</span></span><br><span class="line">        historyApiFallback: <span class="literal">true</span>, <span class="comment">// 不跳转</span></span><br><span class="line">        inline: <span class="literal">true</span>, <span class="comment">// 实时刷新</span></span><br><span class="line">        compress: <span class="literal">true</span>, <span class="comment">// 是否压缩</span></span><br><span class="line">        host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        port: <span class="number">9000</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错误及解决"><a href="#错误及解决" class="headerlink" title="错误及解决"></a>错误及解决</h3><ol><li>选项配置错误</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Options Validation Error</span><br><span class="line"></span><br><span class="line">options.module                         should match some schema in anyOf</span><br><span class="line">options.module.rules[2]                should match some schema in anyOf</span><br><span class="line">options.module.rules[2].use            should be string</span><br><span class="line">options.module.rules[2].use            should pass "instanceof" keyword validation</span><br><span class="line">options.module.rules[2].use            should match some schema in anyOf</span><br><span class="line">options.module.rules[2].use            should pass "instanceof" keyword validation</span><br><span class="line">options.module.rules[2].use            should match some schema in anyOf</span><br><span class="line">options.module.rules[2].use            should be object</span><br><span class="line">options.module.rules[2].use            should match some schema in anyOf</span><br><span class="line">options.module.rules[2].use[0]         should match some schema in anyOf</span><br><span class="line">options.module.rules[2].use[0]         should be string</span><br><span class="line">options.module.rules[2].use[0]         should pass "instanceof" keyword validation</span><br><span class="line">options.module.rules[2].use[0]         should match some schema in anyOf</span><br><span class="line">options.module.rules[2].use[0].loader  should be string</span><br><span class="line">options.module.rules[2].use[0].loader  should match some schema in anyOf</span><br></pre></td></tr></table></figure><p>rules[2]配置错误，不能为数组，只能为字符串<br>解决方案：将原代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">            loader: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>更改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span>,</span><br><span class="line">            <span class="comment">// loader: ['style-loader', 'css-loader']</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>或者更改为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>2.vue-loader插件显性引入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error1: Module Error (from ./node_modules/vue-loader/lib/index.js):</span><br><span class="line">vue-loader was used without the corresponding plugin.</span><br><span class="line">Make sure to include VueLoaderPlugin in your webpack config.</span><br></pre></td></tr></table></figure><p>webpack4.X更新之后，需要显性引入vue-loader插件<br>解决方案：<code>const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);</code>详见<a href="https://vue-loader.vuejs.org/guide/#manual-configuration" target="_blank" rel="noopener">vue-loader</a></p><p>3.vue-template-compiler需要作为单独的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error2: Module build failed (from ./node_modules/vue-loader/lib/index.js):</span><br><span class="line">Error: [vue-loader] vue-template-compiler must be installed as a peer dependency,</span><br><span class="line">or a compatible compiler implementation must be passed via options.</span><br></pre></td></tr></table></figure><p>解决方案：<code>npm i -D vue-template-compiler</code></p><h2 id="应用vue-router"><a href="#应用vue-router" class="headerlink" title="应用vue-router"></a>应用vue-router</h2><p>安装依赖：<code>npm i -D vue-router</code></p><h3 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h3><p>入口文件中，新建vue实例，参数中传入<code>router</code>，<code>components</code>，<code>template</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span>,</span><br><span class="line">    router,</span><br><span class="line">    components: &#123; App &#125;,</span><br><span class="line">    template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h3><p>使用 <code>router-link</code> 组件来导航。通过传入 <code>to</code> 属性指定链接，<code>&lt;router-link&gt;</code> 默认会被渲染成一个 <code>&lt;a&gt;</code> 标签。<br><code>&lt;router-view/&gt;</code> 为路由出口，路由匹配到的组件将渲染在这里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;你好&lt;/h1&gt;</span><br><span class="line">    &lt;router-link to=&quot;/helloworld&quot;&gt;欢迎&lt;/router-link&gt;</span><br><span class="line">    &lt;router-view/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">name: &apos;App&apos;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>router定义了跳转路由渲染的组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld'</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'@/components/Home'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">    mode: <span class="string">'history'</span>,</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/'</span>,</span><br><span class="line">            name: <span class="string">'Home'</span>,</span><br><span class="line">            component: Home</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: <span class="string">'/helloworld'</span>,</span><br><span class="line">            name: <span class="string">'HelloWorld'</span>,</span><br><span class="line">            component: HelloWorld</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><ol><li>vue使用template时更改vue使用模块</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue.runtime.esm.js:588 [Vue warn]:</span><br><span class="line">You are using the runtime-only build of Vue</span><br><span class="line">where the template compiler is not available.</span><br><span class="line">Either pre-compile the templates into render functions,</span><br><span class="line">or use the compiler-included build.</span><br></pre></td></tr></table></figure><blockquote><p>运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%，只有 17.14 Kb min+gzip大小。就是说，如果我们想使用template，我们不能直接在客户端使用npm install之后的vue。</p></blockquote><p>此时，再去看查vue模块，在webpack配置文件添加:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'vue'</span>: <span class="string">'vue/dist/vue.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.默认的代码目录使用<code>@</code>替换，webpack配置文件添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'vue'</span>: <span class="string">'vue/dist/vue.js'</span>,</span><br><span class="line">            <span class="string">'@'</span>: path.resolve(__dirname,<span class="string">'src'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.引入文件必须加后缀，否则报错，webpack配置文件添加：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    resolve: &#123;</span><br><span class="line">        alias: &#123;</span><br><span class="line">            <span class="string">'vue'</span>: <span class="string">'vue/dist/vue.js'</span>,</span><br><span class="line">            <span class="string">'@'</span>: path.resolve(__dirname,<span class="string">'src'</span>),</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 引入文件可不加后缀</span></span><br><span class="line">        extensions: [<span class="string">'.js'</span>, <span class="string">'.vue'</span>, <span class="string">'.json'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.HTML</p><p><code>inject</code>有四个值： <code>true</code> <code>body</code> <code>head</code> <code>false</code></p><p><code>true</code> 默认值，script标签位于html文件的 <code>body</code> 底部<br><code>body</code> script标签位于html文件的 <code>body</code> 底部<br><code>head</code> script标签位于html文件的 <code>head</code>中<br><code>false</code> 不插入生成的js文件，这个几乎不会用到的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> htmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        filename: <span class="string">'index.html'</span>,</span><br><span class="line">        template: <span class="string">'index.html'</span>,</span><br><span class="line">        inject: <span class="literal">true</span></span><br><span class="line">    &#125;),</span><br><span class="line">],</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;webpack-vue-vue-router学习笔记&quot;&gt;&lt;a href=&quot;#webpack-vue-vue-router学习笔记&quot; class=&quot;headerlink&quot; title=&quot;webpack + vue + vue-router学习笔记&quot;&gt;&lt;/a&gt;webpack + vue + vue-router学习笔记&lt;/h1&gt;&lt;h2 id=&quot;安装webpack&quot;&gt;&lt;a href=&quot;#安装webpack&quot; class=&quot;headerlink&quot; title=&quot;安装webpack&quot;&gt;&lt;/a&gt;安装webpack&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm init&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm i -D webpack webpack-cli&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;建立代码目录&quot;&gt;&lt;a href=&quot;#建立代码目录&quot; class=&quot;headerlink&quot; title=&quot;建立代码目录&quot;&gt;&lt;/a&gt;建立代码目录&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/img/webpack-note-directory.png&quot; alt=&quot;目录图片&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用webpack&quot;&gt;&lt;a href=&quot;#使用webpack&quot; class=&quot;headerlink&quot; title=&quot;使用webpack&quot;&gt;&lt;/a&gt;使用webpack&lt;/h2&gt;&lt;h3 id=&quot;终端&quot;&gt;&lt;a href=&quot;#终端&quot; class=&quot;headerlink&quot; title=&quot;终端&quot;&gt;&lt;/a&gt;终端&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &amp;#123;extry file&amp;#125;出填写入口文件的路径，本文中就是上述main.js的路径，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; &amp;#123;destination &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; bundled file&amp;#125;处填写打包文件的存放路径&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; 填写路径的时候不用添加&amp;#123;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;webpack &amp;#123;entry file&amp;#125; -o &amp;#123;destination for bundled file&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;命令：&lt;code&gt;webpack app/main.js public/bundle.js&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;出错及更正：&lt;code&gt;ERROR in multi ./hello.js bundle.js Module not found: Error: Can&amp;#39;t resolve &amp;#39;bundle.js&lt;/code&gt;，更正：webpack版本过高,原来的命令已经不适用了，更换打包命令：&lt;code&gt;webpack app/main.js -o public/bundle.js&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="front" scheme="http://happylg.cn/categories/front/"/>
    
    
      <category term="vue" scheme="http://happylg.cn/tags/vue/"/>
    
      <category term="webpack" scheme="http://happylg.cn/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>拖拽的实现</title>
    <link href="http://happylg.cn/2017/10/13/drag-and-drop/"/>
    <id>http://happylg.cn/2017/10/13/drag-and-drop/</id>
    <published>2017-10-13T10:20:15.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>12.5更新</p><hr><h2 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h2><p>前端经常使用拖拽进行图片上传，那么拖拽是如何实现的呢？<br>使用拖拽基本过程如下：首先定义哪些元素是可拖动的，在鼠标左键点击一个可拖动元素进行拖拽；拖拽元素进行移动，拖拽元素的位置发生改变，可以通过绝对定位实现；鼠标释放拖拽元素。</p><h3 id="HTML5实现"><a href="#HTML5实现" class="headerlink" title="HTML5实现"></a>HTML5实现</h3><h4 id="拖拽删除元素实例"><a href="#拖拽删除元素实例" class="headerlink" title="拖拽删除元素实例"></a>拖拽删除元素实例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span>&gt;</span>垃圾桶<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test-drag"</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>拖拽元素区域:拖拽到垃圾桶中删除<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Javascript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dragElement = <span class="built_in">document</span>.getElementById(<span class="string">"test-drag"</span>);</span><br><span class="line"><span class="keyword">var</span> targetElement = <span class="built_in">document</span>.getElementById(<span class="string">"main"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拖动对象操作</span></span><br><span class="line">dragElement.ondragstart = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"开始拖拽"</span>);</span><br><span class="line">    event.dataTransfer.setData(<span class="string">"deleteDiv"</span>, <span class="keyword">this</span>.id);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">dragElement.ondrag = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"拖动中"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">dragElement.ondragend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"拖动结束"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//目标对象操作</span></span><br><span class="line">targetElement.ondragenter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"拖拽对象进入"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">targetElement.ondragleave = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"拖拽对象离开"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">targetElement.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"拖拽对象在目标对象上"</span>);</span><br><span class="line">    event.preventDefault(); <span class="comment">//必须阻止默认事件，否则无法触发ondrop</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">targetElement.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"拖拽对象松手释放在目标对象上"</span>);</span><br><span class="line">    <span class="keyword">var</span> deleteDivId = event.dataTransfer.getData(<span class="string">"deleteDiv"</span>); <span class="comment">//得到数据--id值  </span></span><br><span class="line">    <span class="keyword">var</span> deleteDiv = <span class="built_in">document</span>.getElementById(deleteDivId); <span class="comment">//根据id值找到相关的元素  </span></span><br><span class="line">    deleteDiv.parentNode.removeChild(deleteDiv); <span class="comment">//从父元素中删除子节点  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="可拖拽对象"><a href="#可拖拽对象" class="headerlink" title="可拖拽对象"></a>可拖拽对象</h5><p>通过设置<code>draggable</code>属性<br><code>draggable</code>：<code>true</code> 表明可拖拽<br><code>draggable</code>：<code>false</code> 表明元素不可拖拽<br><code>draggable</code>：<code>auto</code> 默认，只有<code>img</code>图片,<code>a</code>链接,<code>input</code>文字选中三种情况可拖拽</p><h5 id="拖拽对象API"><a href="#拖拽对象API" class="headerlink" title="拖拽对象API"></a>拖拽对象API</h5><p><code>dragstart</code>:可拖拽元素拖拽开始时触发<br><code>drag</code>:可拖拽元素拖拽触发<br><code>dragend</code>:可拖拽元素拖拽结束时触发</p><h5 id="目标对象API"><a href="#目标对象API" class="headerlink" title="目标对象API"></a>目标对象API</h5><p><code>dragenter</code>:可拖拽元素进入目标放置区域触发<br><code>dragexit</code>:可拖拽元素不再是拖动操作的直接选择目标。<br><code>dragleave</code>:可拖拽元素离开目标放置区域触发<br><code>dragover</code>:可拖拽元素在目标放置区域移动时触发<br><code>drop</code>:可拖拽元素在目标放置区域放置时触发</p><p><strong>注意：<code>dragenter</code>和<code>dragover</code>事件的默认行为是不允许被拖拽元素在其他元素上释放或放置（即无法触发<code>drop</code>事件），需要通过 <code>event.preventDefault()</code>或者<code>return false</code>来阻止默认行为才能触发后续的<code>drop</code>事件。</strong>（实测只需要<code>dragover</code>事件阻止默认事件）</p><h5 id="event-dataTransfer对象"><a href="#event-dataTransfer对象" class="headerlink" title="event.dataTransfer对象"></a><code>event.dataTransfer</code>对象</h5><h6 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h6><blockquote><p><code>DataTransfer</code>对象用于在配置拖拽行为效果，并且在拖拽过程的各事件间传递数据信息。它存储在事件对象当中，下面我们逐步了解它吧。</p><ol><li><code>[object DragEvent]</code>对象<br>继承自<code>[object MouseEvent]</code> 对象，其实就多了个<code>{DataTransfer}</code> <code>dataTransfer</code>属性</li><li><p><code>[object DataTransfer]</code>对象详解<br>上文说到<code>DataTransfer</code>对象可用于传递数据信息，而数据信息的数据类型被限定为字符串和文件类型</p><ol><li><p><code>effectAllowed</code>和<code>dropEffect</code>属性<br>这个两个属性对于初次接触DnD的朋友来说，可谓最令人摸不着头脑的，网上和各书籍上对这两个属性的解释均不全面，下面我试图尽量把它们讲明白<br><code>effectAllowed</code>和<code>dropEffect</code>最主要的作用是，用于配置拖拽操作过程中鼠标指针的类型以便提示用户后续可执行怎样的操作；其次的作用是，控制 drop 事件的触发与否。</p><ol><li><p><code>effectAllowed</code><br><strong>作用：用于设置被拖拽元素可执行的操作。</strong><br>取值范围：<br><code>copy</code> ，限定<code>dropEffect</code>的属性值为<code>copy</code>，否则会鼠标指针为禁止样式<br><code>link</code> ，限定<code>dropEffect</code>的属性值为<code>link</code>，否则会鼠标指针为禁止样式<br><code>move</code> ，限定<code>dropEffect</code>的属性值为<code>move</code>，否则会鼠标指针为禁止样式<br><code>copyLink</code> ，限定<code>dropEffect</code>的属性值为<code>copy</code>和<code>link</code>，否则会鼠标指针为禁止样式<br><code>copyMove</code> ，限定<code>dropEffect</code>的属性值为<code>copy</code>和<code>move</code>，否则会鼠标指针为禁止样式<br><code>linkMove</code> ，限定<code>dropEffect</code>的属性值为<code>link</code>和<code>move</code>，否则会鼠标指针为禁止样式<br><code>all</code>，允许<code>dropEffect</code>的属性值为任意值<code>none</code>，鼠标指针一直为禁止样式，不管<code>dropEffect</code>的属性值是什么<br><code>uninitialized</code>，没有限定<code>dropEffect</code>属性的值，效果和<code>all</code>一样。</p><p>注意：仅能在<code>dragstart</code>事件中设置该属性，其他事件中设置均无效。</p></li><li><p><code>dropEffect</code><br><strong>作用：用于设置目标元素将执行的操作，若属性值属于<code>effectAllowed</code>范围内，则鼠标指针将显示对应的指针样式，否则则显示禁止的指针样式。</strong><br>取值范围：<br><code>copy</code>：被拖拽元素将被复制到目标元素内，若属于<code>effectAllowed</code>范围内时，则鼠标指针显示复制的样式，否则则显示禁止的指针样式。<br><code>link</code>被拖拽元素将以超链接的形式打开资源（具体是否打开资源请参考七、2），若属于 <code>effectAllowed</code>范围内时，则鼠标指针显示超链接的样式，否则则显示禁止的指针样式。<br><code>move</code>：被拖拽元素将被移动到目标元素内，若属于<code>effectAllowed</code>范围内时，则鼠标指针显示移动的样式，否则则显示禁止的指针样式。<br><code>none</code>：被拖拽元素不能在目标元素上作任何操作，一直显示禁止的指针样式。除了文本框外其他元素的默认值均为<code>none</code></p></li></ol><p>注意：</p><ol><li>仅能在<code>dragover</code>事件中设置该属性值，其他事件中设置均无效</li><li>当显示禁止的指针样式时，将无法触发目标元素的 drop 事件。</li></ol></li></ol></li></ol></blockquote><h6 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h6><ol><li><code>DataTransfer.getData()</code><br>获取<code>DataTransfer</code>对象中的一个数据</li><li><code>DataTransfer.setData()</code><br>在<code>DataTransfer</code>对象中添加一个数据</li><li><code>DataTransfer.clearData()</code><br>在<code>DataTransfer</code>对象中删除一个数据</li></ol><h4 id="拖拽过程"><a href="#拖拽过程" class="headerlink" title="拖拽过程"></a>拖拽过程</h4><p>在上述实例中，我们使用HTML5 <code>drap</code>和<code>drop</code>实现了一个拖拽一个元素到指定区域中进行删除。HTML5新增<code>drag</code>事件以方便解决拖拽问题。<br>首先，在这个过程中我们要定义一个可拖拽元素，对拖拽添加属性<code>draggable=&quot;true&quot;</code>即可定义该元素为可拖拽对象。<br>第二，在拖拽元素开始后，可以通过<code>drag</code>事件的<code>dataTransfer</code>对象进行数据的传递。可设置数据来传递文件等。在上述例子中<code>event.dataTransfer.setData()</code>传递被删除元素的ID。<br>第三，放置拖拽元素，通常情况下页面元素为不可放置拖拽元素区域。<strong>放置拖拽元素是通过对目标元素的<code>drop</code>事件实现，但是只有目标元素<code>dragenter</code>和<code>dragover</code>的触发事件最后必须通过取消事件来防止默认处理，即为<code>return false</code>或阻止默认事件<code>event.preventDefault()</code>，则该目标元素才为可放置拖拽元素区域，<code>drop</code>事件才会被触发。否则不会触发<code>drop</code>事件。</strong></p><h3 id="JS实现"><a href="#JS实现" class="headerlink" title="JS实现"></a>JS实现</h3><h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><h2 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://segmentfault.com/q/1010000002885157" target="_blank" rel="noopener">请教js实现拖拽上传图片的实现思路</a></p></li><li><p><a href="http://www.ahonn.me/2016/05/14/use-javascript-to-achieve-simple-drag-and-drop/" target="_blank" rel="noopener">使用 JavaScript 实现简单的拖拽</a></p></li><li><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API" target="_blank" rel="noopener">HTML Drag and Drop API</a></p></li></ul><p>-<a href="http://www.cnblogs.com/fsjohnhuang/p/3961066.html" target="_blank" rel="noopener">HTML5魔法堂：全面理解Drag &amp; Drop API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;12.5更新&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;拖拽&quot;&gt;&lt;a href=&quot;#拖拽&quot; class=&quot;headerlink&quot; title=&quot;拖拽&quot;&gt;&lt;/a&gt;拖拽&lt;/h2&gt;&lt;p&gt;前端经常使用拖拽进行图片上传，那么拖拽是如何实现的呢？&lt;br&gt;使用拖拽基本过程如下：首先定义哪些元素是可拖动的，在鼠标左键点击一个可拖动元素进行拖拽；拖拽元素进行移动，拖拽元素的位置发生改变，可以通过绝对定位实现；鼠标释放拖拽元素。&lt;/p&gt;
&lt;h3 id=&quot;HTML5实现&quot;&gt;&lt;a href=&quot;#HTML5实现&quot; class=&quot;headerlink&quot; title=&quot;HTML5实现&quot;&gt;&lt;/a&gt;HTML5实现&lt;/h3&gt;&lt;h4 id=&quot;拖拽删除元素实例&quot;&gt;&lt;a href=&quot;#拖拽删除元素实例&quot; class=&quot;headerlink&quot; title=&quot;拖拽删除元素实例&quot;&gt;&lt;/a&gt;拖拽删除元素实例&lt;/h4&gt;&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;main&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;垃圾桶&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;test-drag&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;draggable&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;拖拽元素区域:拖拽到垃圾桶中删除&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Javascript代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; dragElement = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;test-drag&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; targetElement = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(&lt;span class=&quot;string&quot;&gt;&quot;main&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//拖动对象操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dragElement.ondragstart = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;开始拖拽&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    event.dataTransfer.setData(&lt;span class=&quot;string&quot;&gt;&quot;deleteDiv&quot;&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.id);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dragElement.ondrag = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;拖动中&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dragElement.ondragend = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;拖动结束&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//目标对象操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;targetElement.ondragenter = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;拖拽对象进入&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;targetElement.ondragleave = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;拖拽对象离开&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;targetElement.ondragover = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;拖拽对象在目标对象上&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    event.preventDefault(); &lt;span class=&quot;comment&quot;&gt;//必须阻止默认事件，否则无法触发ondrop&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;targetElement.ondrop = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;拖拽对象松手释放在目标对象上&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deleteDivId = event.dataTransfer.getData(&lt;span class=&quot;string&quot;&gt;&quot;deleteDiv&quot;&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//得到数据--id值  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; deleteDiv = &lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.getElementById(deleteDivId); &lt;span class=&quot;comment&quot;&gt;//根据id值找到相关的元素  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deleteDiv.parentNode.removeChild(deleteDiv); &lt;span class=&quot;comment&quot;&gt;//从父元素中删除子节点  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="html5" scheme="http://happylg.cn/categories/html5/"/>
    
    
      <category term="html5" scheme="http://happylg.cn/tags/html5/"/>
    
      <category term="drag" scheme="http://happylg.cn/tags/drag/"/>
    
      <category term="拖拽" scheme="http://happylg.cn/tags/%E6%8B%96%E6%8B%BD/"/>
    
  </entry>
  
  <entry>
    <title>CSS实现水平垂直居中</title>
    <link href="http://happylg.cn/2017/09/25/css-all-center/"/>
    <id>http://happylg.cn/2017/09/25/css-all-center/</id>
    <published>2017-09-25T01:54:41.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>44年前我们把人送上月球，但在CSS中我们仍然不能很好实现垂直居中——@James Anderson</p></blockquote><p>让一个元素水平居中对于CSS来说非常简单：如果是一个内联元素，我们可以在他的父元素上设置<code>text-align:center;</code>，如果是一个块元素，我们可以使用<code>margin:auto;</code>。然而，只要一想到让一个元素垂直居中，让人死的心都有了。</p><p>多年来，垂直居中已成为CSS的不朽神话，也是前端专业人士群体中的一个内部笑话。原因是：</p><ul><li>经常需要使用</li><li>理论上看上去非常简单</li><li>过去实战中要实现是极其困难，特别是元素大小固定时</li></ul><a id="more"></a><h2 id="方法一：绝对定位"><a href="#方法一：绝对定位" class="headerlink" title="方法一：绝对定位"></a>方法一：绝对定位</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>完全居中--1.绝对定位<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    内容盒子</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,255,0.2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">margin</span>:auto;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">0</span>;<span class="attribute">left</span>:<span class="number">0</span>;<span class="attribute">bottom</span>:<span class="number">0</span>;<span class="attribute">right</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,255,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见 <a href="https://codepen.io/zxlg/pen/xXRadp" target="_blank" rel="noopener">DEMO:完全居中–1.绝对定位</a></p><h2 id="方法二：绝对定位-负margin"><a href="#方法二：绝对定位-负margin" class="headerlink" title="方法二：绝对定位+负margin"></a>方法二：绝对定位+负margin</h2><p>这或许是最常用的方法。如果知道了各个元素的大小，设置等于宽高一半大小的负<code>margin</code>值（如果没有使用<code>box-sizing: border-box</code>样式，还需要加上<code>padding</code>值），再配合<code>top: 50%</code>; <code>left: 50%;</code>样式就会使块元素居中。</p><p>给容器设置绝对定位（<code>position:absolute</code>）,并且定位高度（<code>top:50%</code>）和<code>margin-top</code>为高度的一半（<code>margin-top:-height/2</code>），宽度设置类似。</p><p>这就意味着使用这种方法来实现垂直居中的效果，那么元素必须要有一个固定的高度。这样一来，给元素设置了固定高度，如果又设置了<code>overflow:auto</code>，那么当元素内容超过容器后，这样元素的就会出现滚动，而不会自适应内容的高度。</p><h3 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>完全居中--2.绝对定位+负margin值<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    内容盒子</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,255,0.2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>:-<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>:-<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,255,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果使用<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/calc" target="_blank" rel="noopener">CSS3中的<code>calc()</code></a>可以减少两个样式：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">top</span>:<span class="built_in">calc</span>(50% - 50px);<span class="comment">/* calc中的`+` `-` 必须被空格包围，`*` `/` 则不需要*/</span></span><br><span class="line">  <span class="attribute">left</span>:<span class="built_in">calc</span>(50% - 50px);</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,255,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参见<a href="https://codepen.io/zxlg/pen/wroRMb" target="_blank" rel="noopener">DEMO:完全居中–2.绝对定位+负margin值</a></p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>浏览器兼容性非常好，甚至支持IE6-7</li><li>需要的编码量很少<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3></li><li>这是个非响应式的方法，不能使用百分比的大小，也不能设置<code>min-/max-</code>的最大值最小值。</li><li>内容可能会超出容器</li><li>需要为<code>padding</code>预留空间，或者需要使用<code>box-sizing: border-box</code>样式。</li></ul><h2 id="方法三：模拟表格"><a href="#方法三：模拟表格" class="headerlink" title="方法三：模拟表格"></a>方法三：模拟表格</h2><p>这种可能是最好的方法，因为高度可以随内容改变，浏览器支持也不差。主要缺陷是会产生额外的标签，每一个需要居中的元素需要三个额外的HTML标签。</p><h3 id="实现过程-2"><a href="#实现过程-2" class="headerlink" title="实现过程"></a>实现过程</h3><p>设置父元素<code>display:table</code>，子元素<code>display:table-cell; vertical-align:middle</code><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"table-cell"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span>完全居中--3.模拟表格<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:table;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.table-cell</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>:table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,0,0,0.3); </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span> auto; </span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,255,0,0.5); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/KXNrpG" target="_blank" rel="noopener">DEMO:完全居中–3.模拟表格</a></p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>内容高度可变</li><li>内容溢出则能自动撑开父元素高度</li><li>浏览器兼容性好</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>需要额外的HTML标签</li></ul><h2 id="方法四：inline-box"><a href="#方法四：inline-box" class="headerlink" title="方法四：inline-box"></a>方法四：inline-box</h2><p>基本方法是使用<code>display: inline-block</code>,<code>vertical-align: middle</code>样式和伪元素让内容块在容器中居中。</p><h3 id="实现过程-3"><a href="#实现过程-3" class="headerlink" title="实现过程"></a>实现过程</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>完全居中--4.inline-block<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    内容盒子</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>:center;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,255,0.2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>:middle;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,255,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/qPqLeQ" target="_blank" rel="noopener">完全居中–4.inline-block</a></p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>内容高度可变</li><li>内容溢出则能自动撑开父元素高度</li><li>浏览器兼容性好，甚至可以调整支持IE7<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3></li><li>需要额外容器</li><li>依赖于<code>margin-left: -0.25em</code>的样式，做到水平居中，需要为不同的字体大小作调整<br>内容区声明的宽度不能大于容器的100% 减去0.25em的宽度</li></ul><h2 id="方法五：transform-CSS3"><a href="#方法五：transform-CSS3" class="headerlink" title="方法五：transform(CSS3)"></a>方法五：transform(CSS3)</h2><p>为内容指定带有厂商前缀的<code>transform: translate(-50%,-50%)</code>和<code>top: 50%; left: 50%;</code>样式就可以让内容块居中。</p><h3 id="实现过程-4"><a href="#实现过程-4" class="headerlink" title="实现过程"></a>实现过程</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>完全居中--5.transform<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    内容盒子</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>:relative;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,255,0.2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>:absolute;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">      <span class="attribute">-ms-transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">          <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%,-50%);</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,255,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/yzVZap" target="_blank" rel="noopener">DEMO:完全居中–5.transform</a></p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>内容高度可变</li><li>代码量小<h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3></li><li>不支持IE8</li><li>需要写厂商前缀</li><li>会和其他<code>transform</code>样式有冲突</li><li>某些情况下的边缘和字体渲染会有问题</li></ul><h2 id="方法六：flex-CSS3"><a href="#方法六：flex-CSS3" class="headerlink" title="方法六：flex(CSS3)"></a>方法六：flex(CSS3)</h2><p>CSS未来发展的方向就是采用Flexbox这种设计，解决像垂直居中这种共同的问题。请注意，Flexbox有不止一种办法居中，他也可以用来分栏，并解决奇奇怪怪的布局问题。</p><h3 id="实现过程-5"><a href="#实现过程-5" class="headerlink" title="实现过程"></a>实现过程</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--   &lt;h2&gt;完全居中--5.flex&lt;/h2&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    内容盒子</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">600px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -moz-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">     <span class="attribute">-moz-box-align</span>: center;</span><br><span class="line">     <span class="attribute">-ms-flex-align</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">          <span class="attribute">align-items</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">     <span class="attribute">-moz-box-pack</span>: center;</span><br><span class="line">     <span class="attribute">-ms-flex-pack</span>: center;</span><br><span class="line">  <span class="attribute">-webkit-justify-content</span>: center;</span><br><span class="line">          <span class="attribute">justify-content</span>: center;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(0,0,255,0.2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(255,255,0,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>内容可以是任意高宽，溢出也能表现良好</li><li>可以用于各种高级布局技巧<h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3></li><li>不支持IE8-9</li><li>需要在<code>body</code>上写样式，或者需要额外容器</li><li>需要各种厂商前缀兼容现代浏览器</li><li>可能有潜在的性能问题</li></ul><h2 id="完全居中对照表"><a href="#完全居中对照表" class="headerlink" title="完全居中对照表"></a>完全居中对照表</h2><table><thead><tr><th style="text-align:center">所用样式</th><th style="text-align:center">支持的浏览器</th><th style="text-align:center">是否响应式</th><th style="text-align:center">内容溢出后的样式</th><th style="text-align:center">resize:both</th><th style="text-align:center">高度可变</th><th style="text-align:center">主要缺陷 </th></tr></thead><tbody><tr><td style="text-align:center">absolute</td><td style="text-align:center">现代浏览器&amp;IE8+</td><td style="text-align:center">是</td><td style="text-align:center">会导致容器溢出</td><td style="text-align:center">是</td><td style="text-align:center">是*</td><td style="text-align:center">‘可变高度’的特性不能跨浏览器</td></tr><tr><td style="text-align:center">负margin值</td><td style="text-align:center">所有</td><td style="text-align:center">否</td><td style="text-align:center">带滚动条</td><td style="text-align:center">大小改变后不再居中</td><td style="text-align:center">否</td><td style="text-align:center">不具有响应式特性，margin值必须经过手工计算</td></tr><tr><td style="text-align:center">transform</td><td style="text-align:center">现代浏览器&amp;IE9+</td><td style="text-align:center">是</td><td style="text-align:center">会导致容器溢出</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">妨碍渲染</td></tr><tr><td style="text-align:center">table-cell</td><td style="text-align:center">现代浏览器&amp;IE8+</td><td style="text-align:center">是</td><td style="text-align:center">撑开容器</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">会加上多余的标记</td></tr><tr><td style="text-align:center">inline-block</td><td style="text-align:center">现代浏览器&amp;IE8+&amp;IE7*</td><td style="text-align:center">是</td><td style="text-align:center">撑开容器</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">需要使用容器包裹和hack式的样式</td></tr><tr><td style="text-align:center">flex</td><td style="text-align:center">现代浏览器&amp;IE10+</td><td style="text-align:center">是</td><td style="text-align:center">会导致容器溢出</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">需要使用容器包裹和厂商前缀（vendor prefix）</td></tr></tbody></table><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://blog.jobbole.com/46574/" target="_blank" rel="noopener">如何只用CSS做到完全居中</a></li><li><a href="https://www.w3cplus.com/css3/css-secrets/vertical-centering.html" target="_blank" rel="noopener">CSS秘密花园： 垂直居中</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;44年前我们把人送上月球，但在CSS中我们仍然不能很好实现垂直居中——@James Anderson&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让一个元素水平居中对于CSS来说非常简单：如果是一个内联元素，我们可以在他的父元素上设置&lt;code&gt;text-align:center;&lt;/code&gt;，如果是一个块元素，我们可以使用&lt;code&gt;margin:auto;&lt;/code&gt;。然而，只要一想到让一个元素垂直居中，让人死的心都有了。&lt;/p&gt;
&lt;p&gt;多年来，垂直居中已成为CSS的不朽神话，也是前端专业人士群体中的一个内部笑话。原因是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经常需要使用&lt;/li&gt;
&lt;li&gt;理论上看上去非常简单&lt;/li&gt;
&lt;li&gt;过去实战中要实现是极其困难，特别是元素大小固定时&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://happylg.cn/categories/CSS/"/>
    
    
      <category term="css" scheme="http://happylg.cn/tags/css/"/>
    
      <category term="水平居中" scheme="http://happylg.cn/tags/%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/"/>
    
      <category term="垂直居中" scheme="http://happylg.cn/tags/%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/"/>
    
      <category term="完全居中" scheme="http://happylg.cn/tags/%E5%AE%8C%E5%85%A8%E5%B1%85%E4%B8%AD/"/>
    
  </entry>
  
  <entry>
    <title>CSS选择器总结</title>
    <link href="http://happylg.cn/2017/09/25/css-selector/"/>
    <id>http://happylg.cn/2017/09/25/css-selector/</id>
    <published>2017-09-25T01:14:01.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如<code>document.querySelector( )</code>和<code>document.querySelectorAll( )</code>。</p><h2 id="选择器类型"><a href="#选择器类型" class="headerlink" title="选择器类型"></a>选择器类型</h2><h3 id="基本选择器"><a href="#基本选择器" class="headerlink" title="基本选择器"></a>基本选择器</h3><ul><li>通配符选择器( <code>*</code> )</li><li>id选择器( <code>\#ID</code> )</li><li>类选择器( <code>.className</code> )</li><li>元素选择器( <code>E</code> )</li><li>后代选择器( <code>E F</code> )</li><li>子元素选择器( <code>E&gt;F</code> )</li><li>相邻兄弟元素选择器( <code>E + F</code> )</li><li>群组选择器( <code>selector1,selector2,...,selectorN</code> )</li></ul><a id="more"></a><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。</p><p><code>E[attr]</code>：只使用属性名，但没有确定任何属性值<br><code>E[attr=&quot;value&quot;]</code>：指定属性名，并指定了该属性的属性值<br><code>E[attr~=&quot;value&quot;]</code>：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的<code>~</code>不能不写<br><code>E[attr^=&quot;value&quot;]</code>：指定了属性名，并且有属性值，属性值是以value开头的；<br><code>E[attr$=&quot;value&quot;]</code>：指定了属性名，并且有属性值，而且属性值是以value结束的；<br><code>E[attr*=&quot;value&quot;]</code>：指定了属性名，并且有属性值，而且属值中包含了value；<br><code>E[attr|=&quot;value&quot;]</code>：指定了属性名，并且属性值是value或者以“value-”开头的值( 比如说zh-cn );</p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>伪类选择器的形式就是<code>:xxx</code>， 比如<code>:hover</code>, <code>:link</code>, <code>:nth</code>。</p><h4 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h4><p>这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来.<br>动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如<code>:link</code>,<code>:visited</code>;<br>另外一种被称作用户行为伪类，如<code>:hover</code>,<code>:active</code>和<code>:focus</code>。</p><h5 id="锚点伪类"><a href="#锚点伪类" class="headerlink" title="锚点伪类"></a>锚点伪类</h5><h6 id="锚点伪类爱恨原则（LoVe-HAte）"><a href="#锚点伪类爱恨原则（LoVe-HAte）" class="headerlink" title="锚点伪类爱恨原则（LoVe/HAte）"></a>锚点伪类爱恨原则（LoVe/HAte）</h6><p>为了可以正确地渲染链接元素的样式，<code>:link</code>伪类选择器应当放在其他伪类选择器的前面，并且遵循LVHA的先后顺序，即：<code>:link</code> — <code>:visited</code> — <code>:hover</code> — <code>:active</code>。</p><h6 id="link"><a href="#link" class="headerlink" title=":link"></a><code>:link</code></h6><p><code>:link</code>伪类选择器是用来选中元素当中的链接。它将会选中所有尚未访问的链接，包括那些已经给定了其他伪类选择器的链接（例如<code>:hover</code>选择器，<code>:active</code>选择器，<code>:visited</code>选择器）。</p><h6 id="visited"><a href="#visited" class="headerlink" title=":visited"></a><code>:visited</code></h6><p><code>:link</code>伪类选择器是用来选中所有已访问过的链接</p><h5 id="用户行为伪类"><a href="#用户行为伪类" class="headerlink" title="用户行为伪类"></a>用户行为伪类</h5><p><code>:hover</code>: 用于当用户把鼠标移动到元素上面时的效果<br><code>:active</code>: 用于用户点击元素那一下的效果( 正发生在点的那一下，松开鼠标左键此动作也就完成了 )<br><code>:focus</code>: 用于元素成为焦点，这个经常用在表单元素上</p><h4 id="UI元素状态伪类"><a href="#UI元素状态伪类" class="headerlink" title="UI元素状态伪类"></a>UI元素状态伪类</h4><p>我们把<code>:enabled</code>,<code>:disabled</code>,<code>:checked</code>伪类称为UI元素状态伪类，这些主要是针对于HTML中的Form元素操作。<br>最常见的比如我们”type=”text”有<code>enable</code>和<code>disabled</code>两种状态，前者为可写状态后者为不可状态；另外”type=”radio”和”type=”checkbox”有<code>checked</code>和<code>unchecked</code>两种状态。<br>IE6-8不支持<code>:checked</code>,<code>:enabled</code>,<code>:disabled</code>这三种选择器。</p><h3 id="CSS3的-nth选择器"><a href="#CSS3的-nth选择器" class="headerlink" title="CSS3的:nth选择器"></a>CSS3的:nth选择器</h3><p>需要注意的是CSS3添加的nth选择器在IE8下不支持。</p><ul><li><code>:first-child</code>选择某个元素的第一个子元素；</li><li><code>:last-child</code>选择某个元素的最后一个子元素；</li><li><code>:nth-child()</code>选择某个元素的一个或多个特定的子元素；</li><li><code>:nth-last-child()</code>选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算；</li><li><code>:nth-of-type()</code>选择指定的元素；</li><li><code>:nth-last-of-type()</code>选择指定的元素，从元素的最后一个开始计算；</li><li><code>:first-of-type</code>选择一个上级元素下的第一个同类子元素；</li><li><code>:last-of-type</code>选择一个上级元素的最后一个同类子元素；</li><li><code>:only-child</code>选择的元素是它的父元素的唯一一个了元素；</li><li><code>:only-of-type</code>选择一个元素是它的上级元素的唯一一个相同类型的子元素；</li><li><code>:empty</code>选择的元素里面没有任何内容。</li></ul><h2 id="选择器权重"><a href="#选择器权重" class="headerlink" title="选择器权重"></a>选择器权重</h2><p>权重，也就是选择器的优先级，每条选择器的规则都有其权重，权重大的会覆盖掉权重小的，很多CSS出现问题的场景，都是某处定义了一个更高权重的规则，导致此处规则不生效。</p><h3 id="权重的计算"><a href="#权重的计算" class="headerlink" title="权重的计算"></a>权重的计算</h3><p>通过这篇文章<a href="http://www.w3cplus.com/css/css-specificity-things-you-should-know.html" target="_blank" rel="noopener">你应该知道的一些事情——CSS权重</a>。了解下权重的计算，主要的规则就是:<br><strong>id选择器 &gt; 类，属性选择器和伪类选择器 &gt; 元素和伪元素</strong><br>需要注意的是<code>!improtant</code>,凡是属性值后加上了<code>!important</code>，那么它的值不会被其他值替换。</p><p>根据样式所在位置，对元素的影响也有关系：<strong>内联样式( 标签内style形式 ) &gt; style标签 &gt; link标签</strong>。</p><h2 id="CSS解析器"><a href="#CSS解析器" class="headerlink" title="CSS解析器"></a>CSS解析器</h2><p>HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render tree，最终用来进行绘图。<br>Render tree 中的元素( WebKit 中称为<code>renderers</code>，Firefox 下为<code>frames</code> )与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个<code>renderer</code>，如文本折行后，不同的行会成为 Render tree 中不同的<code>renderer</code>。也有的 DOM 元素被 Render tree 完全无视，比如<code>display:none</code>的元素。</p><p>在建立 Render tree 时( WebKit 中的<code>Attachment</code>过程 )，浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果( Style Rules )来确定生成怎样的<code>renderer</code>。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的<code>selector</code>并将对应的规则进行合并。选择器的解析实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的<code>selector</code>。</p><h3 id="解析顺序–从右到左原则"><a href="#解析顺序–从右到左原则" class="headerlink" title="解析顺序–从右到左原则"></a>解析顺序–从右到左原则</h3><p>浏览器读取你的选择器，遵循的原则是从选择器的右边到左边读取。换句话说，浏览器读取选择器的顺序是由右到左进行著作权归作者所有，即<strong>选择器从右到左的原则</strong>。</p><p>CSS匹配不是从左到右进行查找，而是从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找。</p><p>选择器的最后一部分，也就是选择器的最右边部分被称为<strong>“关键选择器”</strong>，它将决定你的选择器的效率如何？是高还是低。</p><h3 id="选择器优化"><a href="#选择器优化" class="headerlink" title="选择器优化"></a>选择器优化</h3><h4 id="选择器效率"><a href="#选择器效率" class="headerlink" title="选择器效率"></a>选择器效率</h4><ul><li>id选择器（<code>#myid</code>）</li><li>类选择器（<code>.myclassname</code>）</li><li>标签选择器（<code>div</code>,<code>h1</code>,<code>p</code>）</li><li>相邻选择器（<code>h1+p</code>）</li><li>子选择器（<code>ul &gt; li</code>）</li><li>后代选择器（<code>li a</code>）</li><li>通配符选择器（<code>*</code>）</li><li>属性选择器（<code>a[rel=&quot;external&quot;</code>]）</li><li>伪类选择器（<code>a:hover</code>,<code>li:nth-child</code>）</li></ul><p>id和类名用于关键选择器上效率是最高的，而CSS3的仿伪类和属性选择器，虽然使用方便，但其效率却是最低的。</p><h4 id="几种书写高效率的CSS选择器"><a href="#几种书写高效率的CSS选择器" class="headerlink" title="几种书写高效率的CSS选择器"></a>几种书写高效率的CSS选择器</h4><ul><li>避免普遍规则</li><li>不要在ID选择器前加标签名或类名</li><li>不要在类名选择器前加标签名</li><li>尽可能使用具体的类别</li><li>避免使用后代选择器</li><li>标签分类规则中不应该包含一个子选择器</li><li>子选择器的问题</li><li>借助相关继承关系</li><li>使用范围内的样式表</li></ul><p>附CSS选择器图：<br><img src="/img/css-selector.jpg" alt="CSS选择器"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://leohxj.gitbooks.io/front-end-database/html-and-css-basic/css-selector.html" target="_blank" rel="noopener">CSS选择器</a></li><li><a href="http://www.w3cplus.com/css/css-selector-performance" target="_blank" rel="noopener">CSS选择器的优化</a></li><li><a href="https://www.w3cplus.com/css3/pseudo-class-selector" target="_blank" rel="noopener">CSS3 选择器——伪类选择器</a></li><li><a href="https://csswizardry.com/2011/09/writing-efficient-css-selectors/" target="_blank" rel="noopener">Writing efficient CSS selectors</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如&lt;code&gt;document.querySelector( )&lt;/code&gt;和&lt;code&gt;document.querySelectorAll( )&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;选择器类型&quot;&gt;&lt;a href=&quot;#选择器类型&quot; class=&quot;headerlink&quot; title=&quot;选择器类型&quot;&gt;&lt;/a&gt;选择器类型&lt;/h2&gt;&lt;h3 id=&quot;基本选择器&quot;&gt;&lt;a href=&quot;#基本选择器&quot; class=&quot;headerlink&quot; title=&quot;基本选择器&quot;&gt;&lt;/a&gt;基本选择器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;通配符选择器( &lt;code&gt;*&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;id选择器( &lt;code&gt;\#ID&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;类选择器( &lt;code&gt;.className&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;元素选择器( &lt;code&gt;E&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;后代选择器( &lt;code&gt;E F&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;子元素选择器( &lt;code&gt;E&amp;gt;F&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;相邻兄弟元素选择器( &lt;code&gt;E + F&lt;/code&gt; )&lt;/li&gt;
&lt;li&gt;群组选择器( &lt;code&gt;selector1,selector2,...,selectorN&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://happylg.cn/categories/CSS/"/>
    
    
      <category term="css" scheme="http://happylg.cn/tags/css/"/>
    
      <category term="css解析器" scheme="http://happylg.cn/tags/css%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    
      <category term="css选择器" scheme="http://happylg.cn/tags/css%E9%80%89%E6%8B%A9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS清除浮动/闭合浮动</title>
    <link href="http://happylg.cn/2017/09/24/css-clearfix/"/>
    <id>http://happylg.cn/2017/09/24/css-clearfix/</id>
    <published>2017-09-24T13:00:46.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>参见<a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="noopener">那些年我们一起清除过的浮动</a></p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>文档流: 文档流是文档中可显示对象在排列时所占用的位置。<br>浮动的定义: 使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。</p><p>浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似<code>inline-block</code>)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的<code>overflow</code>属性为<code>auto</code>,使其自动撑满。<br><a id="more"></a></p><h2 id="清除浮动还是闭合浮动（Enclosing-float-or-Clearing-float）"><a href="#清除浮动还是闭合浮动（Enclosing-float-or-Clearing-float）" class="headerlink" title="清除浮动还是闭合浮动（Enclosing float or Clearing float）"></a>清除浮动还是闭合浮动（Enclosing float or Clearing float）</h2><blockquote><p>很多人都已经习惯称之为清除浮动，以前我也一直这么叫着，但是确切地来说是不准确的。我们应该用严谨的态度来对待代码，也能更好地帮助我们理解开头的三个问题。<br>1）清除浮动: 清除对应的单词是<code>clear</code>，对应CSS中的属性是<code>clear: left | right | both | none</code>；<br>2）闭合浮动: 更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。<br>通过以上实例发现，其实我们想要达到的效果更确切地说是闭合浮动，而不是单纯的清除浮动，在footer上设置<code>clear: both</code>清除浮动并不能解决<code>wrap</code>高度塌陷的问题。<br>结论: 用闭合浮动比清除浮动更加严谨，所以后文中统一称之为: 闭合浮动。<br>参见<a href="https://codepen.io/zxlg/pen/MEbvMO" target="_blank" rel="noopener">DEMO: 高度塌陷</a></p></blockquote><h2 id="为何要闭合浮动？"><a href="#为何要闭合浮动？" class="headerlink" title="为何要闭合浮动？"></a>为何要闭合浮动？</h2><p>要解答这个问题，我们得先说说CSS中的定位机制: 普通流，浮动，绝对定位 （其中<code>position:fixed</code>是<code>position:absolute</code>的一个子类）。<br>1）普通流: 很多人或者文章称之为文档流或者普通文档流，其实标准里根本就没有这个词。如果把文档流直译为英文就是document flow，但标准里只有另一个词，叫做普通流（normal flow)，或者称之为常规流。但似乎大家更习惯文档流的称呼，因为很多中文翻译的书就是这么来的。比如《CSS Mastery》，英文原书中至始至终都只有普通流normal flow（普通流） 这一词，从来没出现过document flow （文档流）<br>2）浮动: 浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样。<strong>当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。</strong>顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。<br>正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。</p><h2 id="闭合浮动的原理——了解hasLayout和Block-formatting-contexts"><a href="#闭合浮动的原理——了解hasLayout和Block-formatting-contexts" class="headerlink" title="闭合浮动的原理——了解hasLayout和Block formatting contexts"></a>闭合浮动的原理——了解hasLayout和Block formatting contexts</h2><h3 id="清除浮动的方式"><a href="#清除浮动的方式" class="headerlink" title="清除浮动的方式"></a>清除浮动的方式</h3><h4 id="1）添加额外标签"><a href="#1）添加额外标签" class="headerlink" title="1）添加额外标签"></a>1）添加额外标签</h4><p>这是在学校老师就告诉我们的 一种方法，通过在浮动元素末尾添加一个空的标签例如<code>&lt;div style=”clear:both”&gt;&lt;/div&gt;</code>，其他标签<code>&lt;br&gt;</code>等亦可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span> <span class="attr">id</span>=<span class="string">"float1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>1）添加额外标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main left"</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"side right"</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear:both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/VMmMmZ" target="_blank" rel="noopener">DEMO: 清除浮动clear:both–空div</a><br>优点: 通俗易懂，容易掌握<br>缺点: 可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦，这是坚决不能忍受的，所以你看了这篇文章之后还是建议不要用了吧。</p><h4 id="2）使用br标签和其自身的html属性"><a href="#2）使用br标签和其自身的html属性" class="headerlink" title="2）使用br标签和其自身的html属性"></a>2）使用<code>br</code>标签和其自身的html属性</h4><p>这个方法有些小众，<code>br</code>有<code>clear=“all | left | right | none”</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span> <span class="attr">id</span>=<span class="string">"float2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>2）使用 br标签和其自身的 html属性<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main left"</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"side right"</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span> <span class="attr">clear</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/aLBLdQ" target="_blank" rel="noopener">DEMO: 清除浮动clear:both–br</a><br>优点: 比空标签方式语义稍强，代码量较少<br>缺点: 同样有违结构与表现的分离，不推荐使用</p><h4 id="3-父元素设置overflow-hidden"><a href="#3-父元素设置overflow-hidden" class="headerlink" title="3) 父元素设置overflow:hidden"></a>3) 父元素设置<code>overflow:hidden</code></h4><p>通过设置父元素<code>overflow</code>值设置为<code>hidden</code>；在IE6中还需要触发<code>hasLayout</code>，例如<code>zoom: 1</code>；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span> <span class="attr">id</span>=<span class="string">"float3"</span> <span class="attr">style</span>=<span class="string">"overflow:hidden; *zoom:1;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>3)父元素设置 overflow <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main left"</span>&gt;</span>.main&#123;float:left;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"side right"</span>&gt;</span>.side&#123;float:right;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span>.footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/wrorrd" target="_blank" rel="noopener">DEMO:清除浮动–父元素设置overflow:hidden</a><br>优点: 不存在结构和语义化问题，代码量极少<br>缺点: 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现<a href="http://plod.popoever.com/archives/000309.html" target="_blank" rel="noopener"><code>overflow:hidden</code>会导致中键失效</a>,所以还是不要使用了。</p><h4 id="4-父元素设置overflow-auto属性"><a href="#4-父元素设置overflow-auto属性" class="headerlink" title="4) 父元素设置overflow:auto属性"></a>4) 父元素设置<code>overflow:auto</code>属性</h4><p>同样IE6需要触发hasLayout，演示和3差不多<br>参见<a href="https://codepen.io/zxlg/pen/QqGqQa" target="_blank" rel="noopener">DEMO:清除浮动–父元素设置overflow:auto</a><br>优点: 不存在结构和语义化问题，代码量极少<br>缺点: 多个嵌套后，firefox某些情况会造成内容全选；IE中<code>mouseover</code>造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生<code>focus</code>等,不要使用</p><h4 id="5）父元素也设置浮动"><a href="#5）父元素也设置浮动" class="headerlink" title="5）父元素也设置浮动"></a>5）父元素也设置浮动</h4><p>优点: 不存在结构和语义化问题，代码量极少<br>缺点: 使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到<code>body</code>，不推荐使用</p><h4 id="6）父元素设置display-table"><a href="#6）父元素设置display-table" class="headerlink" title="6）父元素设置display:table"></a>6）父元素设置<code>display:table</code></h4><p>参见<a href="https://codepen.io/zxlg/pen/veyejG" target="_blank" rel="noopener">DEMO:清除浮动–父元素设置display:table</a><br>优点: 结构语义化完全正确，代码量极少<br>缺点: 盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用</p><h4 id="7）使用-after伪元素"><a href="#7）使用-after伪元素" class="headerlink" title="7）使用::after伪元素"></a>7）使用<code>::after</code>伪元素</h4><p>需要注意的是<code>::after</code>是伪元素（Pseudo-Element），不是伪类（某些CSS手册里面称之为“伪对象”），很多闭合浮动大全之类的文章都称之为伪类，不过csser要严谨一点，这是一种态度。<br>由于IE6-7不支持<code>::after</code>，使用<code>zoom:1</code>触发hasLayout。</p><p>该方法源自于:<a href="http://www.positioniseverything.net/easyclearing.html" target="_blank" rel="noopener">How To Clear Floats Without Structural Markup</a><br>原文全部代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="undefined">    content: ".";</span></span><br><span class="line"><span class="undefined">    display: block;</span></span><br><span class="line"><span class="undefined">    height: 0;</span></span><br><span class="line"><span class="undefined">    clear: both;</span></span><br><span class="line"><span class="undefined">    visibility: hidden;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span><span class="comment">&lt;!-- main stylesheet ends, CC with new stylesheet below... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if IE]&gt;</span></span><br><span class="line"><span class="comment">&lt;style type="text/css"&gt;</span></span><br><span class="line"><span class="comment">  .clearfix &#123;</span></span><br><span class="line"><span class="comment">    zoom: 1; /* triggers hasLayout */</span></span><br><span class="line"><span class="comment">  &#125;  </span></span><br><span class="line"><span class="comment">/* Only IE can see inside the conditional comment</span></span><br><span class="line"><span class="comment">and read this CSS rule. Don't ever use a normal HTML</span></span><br><span class="line"><span class="comment">comment inside the CC or it will close prematurely. */</span></span><br><span class="line"><span class="comment">&lt;/style&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><p>鉴于 IE/Mac的市场占有率极低,我们直接忽略掉,最后精简的代码如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="undefined">        content: ".";</span></span><br><span class="line"><span class="undefined">        display: block;</span></span><br><span class="line"><span class="undefined">        height: 0;</span></span><br><span class="line"><span class="undefined">        clear: both;</span></span><br><span class="line"><span class="undefined">        visibility: hidden;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.clearfix</span> &#123;</span></span><br><span class="line"><span class="css">        *<span class="selector-tag">zoom</span><span class="selector-pseudo">:1</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/MEbEPz" target="_blank" rel="noopener">DEMO:清除浮动–父元素设置::after伪元素</a></p><h3 id="清除浮动方式总结"><a href="#清除浮动方式总结" class="headerlink" title="清除浮动方式总结"></a>清除浮动方式总结</h3><p>通过对比，我们不难发现，其实以上列举的方法，无非有两类:</p><h4 id="利用clear属性清除浮动"><a href="#利用clear属性清除浮动" class="headerlink" title="利用clear属性清除浮动"></a>利用<code>clear</code>属性清除浮动</h4><p><strong>其一，通过在浮动元素的末尾添加一个空元素，设置<code>clear: both</code>属性，<code>::after</code>伪元素其实也是通过content在元素的后面生成了内容为一个点的块级元素；</strong></p><p>当<code>clear</code>应用于非浮动元素时，它将非浮动元素的边框边界移动到所有相关浮动元素外边界的下方。这个行为作用时会导致margin collapsing不起作用。<br>当<code>clear</code>应用于浮动元素时，它将元素的外边界移动到所有相关的浮动元素外边界的下方。这会影响后面浮动元素的布局，后面的浮动元素的位置无法高于它之前的元素。<br>要被清除的相关浮动元素指在相同BFC中的前置浮动。</p><h4 id="使父容器形成BFC"><a href="#使父容器形成BFC" class="headerlink" title="使父容器形成BFC"></a>使父容器形成BFC</h4><p><strong>其二，通过设置父元素<code>overflow</code>或者<code>display: table</code>属性来闭合浮动</strong></p><h3 id="清除浮动-闭合浮动原理"><a href="#清除浮动-闭合浮动原理" class="headerlink" title="清除浮动/闭合浮动原理"></a>清除浮动/闭合浮动原理</h3><p>在CSS2.1里面有一个很重要的概念，但是国内的技术博客介绍到的比较少，那就是<a href="https://www.w3.org/TR/CSS21/visuren.html#block-formatting" target="_blank" rel="noopener">Block formatting contexts</a> （块级格式化上下文），以下简称 BFC。<br>CSS3里面对这个规范做了改动，称之为: <a href="https://www.w3.org/TR/css3-box/#block-level0" target="_blank" rel="noopener">flow root</a>，并且对触发条件进行了进一步说明。</p><h4 id="BFC特性"><a href="#BFC特性" class="headerlink" title="BFC特性"></a>BFC特性</h4><h5 id="1-BFC会阻止垂直外边距叠加"><a href="#1-BFC会阻止垂直外边距叠加" class="headerlink" title="1) BFC会阻止垂直外边距叠加"></a>1) BFC会阻止垂直外边距叠加</h5><p>当两个相邻的块框在同一个BFC中时，只要他们之间没有阻挡（边框，非空内容，padding等），它们之间垂直方向的外边距会发生叠加。<br>换句话说，如果这两个相邻的块框不属于同一个BFC，那么它们的外边距就不会叠加。对于相邻两个元素意义不大，没有必要给他们加一个外壳。但是对于嵌套元素来说就很有必要了，只要把父元素设置为BFC就可以了。这样子元素的<code>margin</code>就不会和父元素的<code>margin</code>发生重叠了。</p><h5 id="2-BFC不会重叠浮动元素"><a href="#2-BFC不会重叠浮动元素" class="headerlink" title="2) BFC不会重叠浮动元素"></a>2) BFC不会重叠浮动元素</h5><p>根据规定，一个BFC的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用（Webkit和IE6在这点上有一个问题——可以看这个<a href="http://www.cssmojo.com/tjkdesign.html" target="_blank" rel="noopener">测试用例</a>）。 </p><h5 id="3-BFC可以包含浮动"><a href="#3-BFC可以包含浮动" class="headerlink" title="3) BFC可以包含浮动"></a>3) BFC可以包含浮动</h5><p>利用这三条特性我们可以用来闭合浮动，也就是说只要父元素形成BFC就可以。</p><h4 id="如何触发BFC"><a href="#如何触发BFC" class="headerlink" title="如何触发BFC"></a>如何触发BFC</h4><ul><li>根元素或其它包含它的元素</li><li>浮动元素 (元素的<code>float</code>不是<code>none</code>)</li><li>绝对定位元素 (元素具有<code>position</code>为<code>absolute</code>或<code>fixed</code>)</li><li>内联块 (元素具有<code>display: inline-block</code>)</li><li>表格单元格 (元素具有<code>display: table-cell</code>，HTML表格单元格默认属性)</li><li>表格标题 (元素具有<code>display: table-caption</code>, HTML表格标题默认属性)</li><li>具有<code>overflow</code>且值不是<code>visible</code>的块元素(<code>hidden</code>，<code>auto</code>，<code>scroll</code>)</li><li><code>display: flow-root</code></li><li><code>column-span: all</code>应当总是会创建一个新的格式化上下文，即便具有<code>column-span: all</code>的元素并不被包裹在一个多列容器中。</li><li><code>fieldset</code>元素</li></ul><p><code>display:table</code>本身并不会创建BFC，但是它会产生<a href="https://www.w3.org/TR/CSS21/tables.html#anonymous-boxes" target="_blank" rel="noopener">匿名框</a>(anonymous boxes)，而匿名框中的<code>display:table-cell</code>可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是<code>display:table</code>。所以通过<code>display:table</code>和<code>display:table-cell</code>创建的BFC效果是不一样的。<br><code>fieldset</code>元素在<a href="http://www.w3.org里目前没有任何有关这个触发行为的信息，直到HTML5标准里才出现。有些浏览器bugs（Webkit，Mozilla）提到过这个触发行为，但是没有任何官方声明。实际上，即使`fieldset`在大多数的浏览器上都能创建新的块级格式化上下文，开发者也不应该把这当做是理所当然的。CSS" target="_blank" rel="noopener">www.w3.org里目前没有任何有关这个触发行为的信息，直到HTML5标准里才出现。有些浏览器bugs（Webkit，Mozilla）提到过这个触发行为，但是没有任何官方声明。实际上，即使`fieldset`在大多数的浏览器上都能创建新的块级格式化上下文，开发者也不应该把这当做是理所当然的。CSS</a> 2.1没有定义哪种属性适用于表单控件，也没有定义如何使用CSS来给它们添加样式。用户代理可能会给这些属性应用CSS属性，建议开发者们把这种支持当做实验性质的，更高版本的CSS可能会进一步规范这个。</p><p>通俗地来说: 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC仍然属于文档中的普通流。<br>至此，您或许明白了为什么<code>overflow:hidden</code>或者<code>auto</code>可以闭合浮动了，真是因为父元素创建了新的BFC。</p><h4 id="hasLayout"><a href="#hasLayout" class="headerlink" title="hasLayout"></a>hasLayout</h4><p>从表现上来说，<code>hasLayout</code>可以等同于 BFC。<br>IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念，由于这个显示引擎自身存在很多的缺陷，直接导致了IE6-7的很多显示bug。当我们说一个元素“得到 layout”，或者说一个元素“拥有 layout” 的时候，我们的意思是指它的微软专有属性<code>[hasLayout]</code>为此被设为了<code>true</code>。IE6-7使用布局的概念来控制元素的尺寸和定位，那些拥有布局（have layout）的元素负责本身及其子元素的尺寸设置和定位。如果一个元素的<code>hasLayout</code>为<code>false</code>，那么它的尺寸和位置由最近拥有布局的祖先元素控制。</p><h4 id="触发hasLayout的条件"><a href="#触发hasLayout的条件" class="headerlink" title="触发hasLayout的条件"></a>触发hasLayout的条件</h4><ul><li><code>position: absolute</code></li><li><code>float: left|right</code></li><li><code>display: inline-block</code></li><li><code>width</code>: 除<code>auto</code>外的任意值</li><li><code>height</code>: 除<code>auto</code>外的任意值(例如很多人闭合浮动会用到 height: 1% )</li><li><code>zoom</code>: 除<code>normal</code>外的任意值</li><li><code>writing-mode</code>: tb-rl</li></ul><p>在 IE7 中，<code>overflow</code>也变成了一个 layout 触发器:</p><ul><li><code>overflow: hidden|scroll|auto</code> （ 这个属性在IE之前版本中没有触发 layout 的功能。 ）</li><li><code>overflow-x|-y: hidden|scroll|auto</code> （CSS3 盒模型中的属性，尚未得到浏览器的广泛支持。他们在之前IE版本中同样没有触发 layout 的功能）</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动；<br>在不支持BFC的浏览器 （IE6-7），通过触发hasLayout闭合浮动。</p><h2 id="闭合浮动改进方法"><a href="#闭合浮动改进方法" class="headerlink" title="闭合浮动改进方法"></a>闭合浮动改进方法</h2><p>上面已经列举了7种闭合浮动的方法，通过第三节分析的原理，我们发现其实更多的: <code>display: table-cell</code>，<code>display: inline-block</code>等只要触发了BFC的属性值都可以闭合浮动。从各个方面比较，<code>::after</code>伪元素闭合浮动无疑是相对比较好的解决方案了，下面详细说说该方法。</p><h3 id="伪元素和伪类"><a href="#伪元素和伪类" class="headerlink" title="伪元素和伪类"></a>伪元素和伪类</h3><p><strong>伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。</strong><br>伪元素使用<code>::</code>，伪类使用<code>:</code>。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;<span class="attribute">content</span>:<span class="string">"."</span>; <span class="attribute">display</span>:block; <span class="attribute">height</span>:<span class="number">0</span>; <span class="attribute">visibility</span>:hidden; <span class="attribute">clear</span>:both; &#125;</span><br><span class="line">.clearfix &#123; *zoom:1; &#125;</span><br></pre></td></tr></table></figure><p>1) <code>display:block</code>使生成的元素以块级元素显示,占满剩余空间;<br>2) <code>height:0</code>避免生成内容破坏原有布局的高度。<br>3) <code>visibility:hidden</code>使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;<br>4）通过<code>content:&quot;.&quot;</code>生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的<code>content:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;</code>,有些版本可能<code>content</code>里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0<code>content:&quot;&quot;</code>仍然会产生额外的空隙；<br>5）<code>zoom: 1</code>触发IE hasLayout。<br>通过分析发现，除了<code>clear: both</code>用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有<code>font-size:0</code>，<code>line-height:0</code>。</p><h3 id="精益求精方案"><a href="#精益求精方案" class="headerlink" title="精益求精方案"></a>精益求精方案</h3><p>由Nicolas Gallagher 大湿提出来的,原文<a href="http://nicolasgallagher.com/micro-clearfix-hack/" target="_blank" rel="noopener">:A new micro clearfix hack</a>，该方法也不存在firefox中空隙的问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For modern browsers */</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,<span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>:table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123; </span><br><span class="line">    <span class="attribute">clear</span>:both;</span><br><span class="line">&#125;<span class="comment">/* For IE 6/7 (trigger hasLayout) */</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">    <span class="attribute">zoom</span>:<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参见<a href="https://codepen.io/zxlg/pen/YrpYwj" target="_blank" rel="noopener">清除浮动–父元素设置::after ::before伪元素</a></p><p>需要注意的是：<br>上面的方法用到了<code>::before</code>伪元素，很多人对这个有些迷惑，到底我什么时候需要用<code>before</code>呢？为什么方案一没有呢？其实它是用来处理<code>margin</code>边距重叠的，由于内部元素<code>float</code>创建了BFC，导致内部元素的<code>margin-top</code>和上一个盒子的<code>margin-bottom</code>发生叠加。如果这不是你所希望的，那么就可以加上<code>before</code>，如果只是单纯的闭合浮动，<code>after</code>就够了！</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.iyunlu.com/view/css-xhtml/55.html" target="_blank" rel="noopener">那些年我们一起清除过的浮动</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">块格式化上下文</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clear" target="_blank" rel="noopener">clear</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参见&lt;a href=&quot;http://www.iyunlu.com/view/css-xhtml/55.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;那些年我们一起清除过的浮动&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;浮动&quot;&gt;&lt;a href=&quot;#浮动&quot; class=&quot;headerlink&quot; title=&quot;浮动&quot;&gt;&lt;/a&gt;浮动&lt;/h2&gt;&lt;p&gt;文档流: 文档流是文档中可显示对象在排列时所占用的位置。&lt;br&gt;浮动的定义: 使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。&lt;/p&gt;
&lt;p&gt;浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似&lt;code&gt;inline-block&lt;/code&gt;)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的&lt;code&gt;overflow&lt;/code&gt;属性为&lt;code&gt;auto&lt;/code&gt;,使其自动撑满。&lt;br&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://happylg.cn/categories/CSS/"/>
    
    
      <category term="css" scheme="http://happylg.cn/tags/css/"/>
    
      <category term="浮动" scheme="http://happylg.cn/tags/%E6%B5%AE%E5%8A%A8/"/>
    
      <category term="清除浮动" scheme="http://happylg.cn/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
      <category term="闭合浮动" scheme="http://happylg.cn/tags/%E9%97%AD%E5%90%88%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>HTTP首部字段解析</title>
    <link href="http://happylg.cn/2017/09/23/http-head/"/>
    <id>http://happylg.cn/2017/09/23/http-head/</id>
    <published>2017-09-23T12:43:11.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-首部字段"><a href="#HTTP-首部字段" class="headerlink" title="HTTP 首部字段"></a>HTTP 首部字段</h2><h3 id="HTTP-首部字段作用"><a href="#HTTP-首部字段作用" class="headerlink" title="HTTP 首部字段作用"></a>HTTP 首部字段作用</h3><p>起传递重要信息的作用。<br>使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。</p><h3 id="HTTP-首部字段结构"><a href="#HTTP-首部字段结构" class="headerlink" title="HTTP 首部字段结构"></a>HTTP 首部字段结构</h3><p>HTTP首部字段是由首部字段名和字段值构成的，中间用冒号<code>:</code>分隔。<br><a id="more"></a></p><h3 id="四种-HTTP-首部字段类型"><a href="#四种-HTTP-首部字段类型" class="headerlink" title="四种 HTTP 首部字段类型"></a>四种 HTTP 首部字段类型</h3><p>HTTP首部字段根据实际用途被分为以下四种类型。</p><h4 id="通用首部字段（General-Header-Fields）"><a href="#通用首部字段（General-Header-Fields）" class="headerlink" title="通用首部字段（General Header Fields）"></a>通用首部字段（<code>General Header Fields</code>）</h4><p>请求报文和响应报文两方都会使用的首部。</p><h4 id="请求首部字段（Request-Header-Fields）"><a href="#请求首部字段（Request-Header-Fields）" class="headerlink" title="请求首部字段（Request Header Fields）"></a>请求首部字段（<code>Request Header Fields</code>）</h4><p>从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p><h4 id="响应首部字段（Response-Header-Fields）"><a href="#响应首部字段（Response-Header-Fields）" class="headerlink" title="响应首部字段（Response Header Fields）"></a>响应首部字段（<code>Response Header Fields</code>）</h4><p>从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p><h4 id="实体首部字段（Entity-Header-Fields）"><a href="#实体首部字段（Entity-Header-Fields）" class="headerlink" title="实体首部字段（Entity Header Fields）"></a>实体首部字段（<code>Entity Header Fields</code>）</h4><p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p><h3 id="HTTP-1-1-首部字段一览"><a href="#HTTP-1-1-首部字段一览" class="headerlink" title="HTTP/1.1 首部字段一览"></a>HTTP/1.1 首部字段一览</h3><p>Http/1.1规范定义了如下47种首部字段。</p><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">控制缓存的行为</td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">逐跳首部、连接的管理</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">报文指令</td></tr><tr><td style="text-align:left">Pragma</td><td style="text-align:left">控制缓存的行为</td></tr><tr><td style="text-align:left">Trailer</td><td style="text-align:left">报文末端的首部一览</td></tr><tr><td style="text-align:left">Transfer-Encoding</td><td style="text-align:left">指定报文主体的传输编码方式</td></tr><tr><td style="text-align:left">Upgrade</td><td style="text-align:left">升级为其他协议</td></tr><tr><td style="text-align:left">Via</td><td style="text-align:left">代理服务器的相关信息</td></tr><tr><td style="text-align:left">Warning</td><td style="text-align:left">错误通知</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">用户代理可处理的媒体类型</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">优先的字符集</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">优先的内容编码</td></tr><tr><td style="text-align:left">Accept-Language</td><td style="text-align:left">优先的语言（自然语言）</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">Web认证信息</td></tr><tr><td style="text-align:left">Expect</td><td style="text-align:left">期待服务器的特定行为</td></tr><tr><td style="text-align:left">From</td><td style="text-align:left">用户的电子邮箱地址</td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">请求资源所在服务器</td></tr><tr><td style="text-align:left">If-Match</td><td style="text-align:left">比较实体标记（ETag)</td></tr><tr><td style="text-align:left">If-Modified-Since</td><td style="text-align:left">比较资源的更新时间</td></tr><tr><td style="text-align:left">If-None-Match</td><td style="text-align:left">比较实体标记（与If-Match相反）</td></tr><tr><td style="text-align:left">If-Range</td><td style="text-align:left">资源未更新时发送实体Byte的范围请求</td></tr><tr><td style="text-align:left">If-Unmodified-Since</td><td style="text-align:left">比较资源的更新时间（与If-Modified-Since相反）</td></tr><tr><td style="text-align:left">Max-Forwards</td><td style="text-align:left">最大传输逐跳数</td></tr><tr><td style="text-align:left">Proxy-Authorization</td><td style="text-align:left">代理服务器要求客户端的认证信息</td></tr><tr><td style="text-align:left">Range</td><td style="text-align:left">实体的字节范围请求</td></tr><tr><td style="text-align:left">Referer</td><td style="text-align:left">对请求中URI的原始获取方</td></tr><tr><td style="text-align:left">TE</td><td style="text-align:left">传输编码的优先级</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">HTTP客户端程序的信息</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Accept-Ranges</td><td style="text-align:left">是否接受字节范围请求</td></tr><tr><td style="text-align:left">Age</td><td style="text-align:left">推算资源创建经过时间</td></tr><tr><td style="text-align:left">ETag</td><td style="text-align:left">资源的匹配信息</td></tr><tr><td style="text-align:left">Location</td><td style="text-align:left">令客户端重定向至指定URI</td></tr><tr><td style="text-align:left">Proxy-Authenticate</td><td style="text-align:left">代理服务器对客户端的认证信息</td></tr><tr><td style="text-align:left">Retry-After</td><td style="text-align:left">对再次发起请求的时机要求</td></tr><tr><td style="text-align:left">Server</td><td style="text-align:left">HTTP服务器的安装信息</td></tr><tr><td style="text-align:left">Vary</td><td style="text-align:left">代理服务器缓存的管理信息</td></tr><tr><td style="text-align:left">WWW-Authenticate</td><td style="text-align:left">服务器对客户端的认证信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">Allow</td><td style="text-align:left">资源可支持的HTTP方法</td></tr><tr><td style="text-align:left">Content-Encoding</td><td style="text-align:left">实体主体适用的编码方式</td></tr><tr><td style="text-align:left">Content-Language</td><td style="text-align:left">实体主体的自然语言</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">实体主体的大小（单位：字节）</td></tr><tr><td style="text-align:left">Content-Location</td><td style="text-align:left">替代对应资源的URI</td></tr><tr><td style="text-align:left">Content-MD5</td><td style="text-align:left">实体主体的报文摘要</td></tr><tr><td style="text-align:left">Content-Range</td><td style="text-align:left">实体主体的位置范围</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">实体主体的媒体类型</td></tr><tr><td style="text-align:left">Expires</td><td style="text-align:left">实体主体过期的日期时间</td></tr><tr><td style="text-align:left">Last-Modified</td><td style="text-align:left">资源的最后修改日期时间</td></tr></tbody></table><h4 id="End-to-end-首部和-Hop-by-hop-首部"><a href="#End-to-end-首部和-Hop-by-hop-首部" class="headerlink" title="End-to-end 首部和 Hop-by-hop 首部"></a>End-to-end 首部和 Hop-by-hop 首部</h4><h5 id="端到端首部（End-to-end-Header）"><a href="#端到端首部（End-to-end-Header）" class="headerlink" title="端到端首部（End-to-end Header）"></a>端到端首部（End-to-end Header）</h5><p>分在此类别中的首部会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</p><h5 id="逐跳首部（Hop-by-hop-Header）"><a href="#逐跳首部（Hop-by-hop-Header）" class="headerlink" title="逐跳首部（Hop-by-hop Header）"></a>逐跳首部（Hop-by-hop Header）</h5><p>​分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本中，如果要使用<code>hop-by-hop</code>首部，需提供<code>Connection</code>首部字段<br>下面列举了HTTP/1.1中的逐跳首部字段。除这8个首部字段之外，其他所有字段都属于端到端首部。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Connection</span><br><span class="line">Keep-Alive</span><br><span class="line">Proxy-Authenticate</span><br><span class="line">Proxy-Authorization</span><br><span class="line">Trailer</span><br><span class="line">TE</span><br><span class="line">Transfer-Enconding</span><br><span class="line">Upgrade</span><br></pre></td></tr></table></figure></p><h2 id="通用首部字段-1"><a href="#通用首部字段-1" class="headerlink" title="通用首部字段"></a>通用首部字段</h2><p>通用首部字段是指，请求报文和响应报文双方都会使用的首部。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>通过指定首部字段<code>Cache-Control</code>的指令，就能操作缓存的工作机制.</p><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><p><code>Connection</code>首部字段具备两个作用。</p><ol><li>控制不在转发给代理的首部字段</li><li>管理持久连接</li></ol><h4 id="控制不在转发给代理的首部字段"><a href="#控制不在转发给代理的首部字段" class="headerlink" title="控制不在转发给代理的首部字段"></a>控制不在转发给代理的首部字段</h4><p>在客户端发送请求和服务器返回响应内，使用<code>Connection</code>首部字段，可控制不再转发给代理的首部字段（即<code>Hop-by-hop</code>首部）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: 不再转发的首部字段名</span><br></pre></td></tr></table></figure></p><h4 id="管理持久连接"><a href="#管理持久连接" class="headerlink" title="管理持久连接"></a>管理持久连接</h4><p>HTTP/1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定<code>Connection</code>首部字段的值为<code>Close</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connection: Keep-Alive</span><br></pre></td></tr></table></figure></p><p>HTTP/1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定<code>Connection</code>首部字段的值为<code>Keep-Alive</code>。</p><h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p>首部字段<code>Date</code>表明创建HTTP报文的日期和时间。<br>HTTP/1.1协议使用在RFC1123中规定的日期时间的格式，如下示例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03 Dul 2012 04:40:59 GMT</span><br></pre></td></tr></table></figure></p><p>之前的HTTP协议版本中使用在RFC850中定义的格式，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tue, 03-Dul-12 04:40:59 GMT</span><br></pre></td></tr></table></figure></p><p>除此之外，还有一种格式。它与C标准库内的<code>asctime()</code>函数的输出格式一致。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date: Tug Dul 03 04:40:59 2012</span><br></pre></td></tr></table></figure></p><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p><code>Pragma</code>是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。<br>所有的中间服务器如果都能以HTTP/1.1为基准，那直接采用<code>Cache-Control:no-cache</code>指定缓存的处理方式是最理想的。但要整体掌握全部中间服务器使用的HTTP协议版本缺失不现实的。因此，发送的请求会同时含有下面两个首部字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure></p><h3 id="Trailer"><a href="#Trailer" class="headerlink" title="Trailer"></a>Trailer</h3><p>首部字段<code>Trailer</code>会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Tue, 03 Jul 2012 04:40:56 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Trailer: Expires</span><br><span class="line">(报文主体）</span><br><span class="line">0</span><br><span class="line">Expires: Tue, 28 Sep 2004 23:59:59 GMT</span><br></pre></td></tr></table></figure></p><p>以上用例中，指定首部字段<code>Trailer</code>的值为<code>Expires</code>，在报文主体之后(分块长度0之后）出现了首部字<code>Expires</code>。</p><h3 id="Transfer-Encoding"><a href="#Transfer-Encoding" class="headerlink" title="Transfer-Encoding"></a>Transfer-Encoding</h3><p>首部字段<code>Transfer-Encoding</code>规定了传输报文主体时采用的编码方式。<br>HTTP/1.1的传输编码仅对分块传输编码有效。</p><h3 id="Upgrade"><a href="#Upgrade" class="headerlink" title="Upgrade"></a>Upgrade</h3><p>首部字段<code>Upgrade</code>用于检测<code>HTTP</code>协议以及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。</p><h3 id="Via"><a href="#Via" class="headerlink" title="Via"></a>Via</h3><p>使用首部字段<code>Via</code>是为了追踪客户端与服务器之间的请求和响应报文的传输路径。<br>报文经过代理或网关时，会先在首部字段<code>Via</code>中附加该服务器的信息，然后再进行转发。</p><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><p>HTTP/1.1的<code>Warning</code>首部是从HTTP/1.0的响应首部（<code>Retry-After</code>）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: 113 gw.hackr.jp:8080 &quot;Heuristic expiration&quot; Tue, 03</span><br></pre></td></tr></table></figure></p><p>Warning首部的格式如下。最后的日期时间部分可省略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning:[警告码][警告的主机:端口号]“[警告内容]”（[日期时间])</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:left">警告码</th><th style="text-align:left">警告内容</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">110</td><td style="text-align:left">Response is stale (响应已过期）</td><td style="text-align:left">代理返回己过期的资源</td></tr><tr><td style="text-align:left">111</td><td style="text-align:left">Revalidation failed (再验证失败））</td><td style="text-align:left">代理再验证资源有效性时失败（服务器无法到达等原因）</td></tr><tr><td style="text-align:left">112</td><td style="text-align:left">Disconnection operation (断开连接操作）</td><td style="text-align:left">代理与互联网连接被故意切断</td></tr><tr><td style="text-align:left">113</td><td style="text-align:left">Heuristic expiration (试探性过期）</td><td style="text-align:left">响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下）</td></tr><tr><td style="text-align:left">199</td><td style="text-align:left">Miscellaneous warning (杂项警告）</td><td style="text-align:left">任意的警告内容</td></tr><tr><td style="text-align:left">214</td><td style="text-align:left">Transformation applied (使用 了转换）</td><td style="text-align:left">代理对内容编码或媒体类型等执行了某些处理时</td></tr><tr><td style="text-align:left">299</td><td style="text-align:left">Miscellaneous persistent warning (持久杂项警告</td><td style="text-align:left">任意的警告内容</td></tr></tbody></table><h2 id="请求首部字段-1"><a href="#请求首部字段-1" class="headerlink" title="请求首部字段"></a>请求首部字段</h2><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。</p><h3 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h3><p><code>Accept</code>首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用<code>type/subtype</code>这种形式，一次指定多种媒体型。</p><h4 id="文本文件"><a href="#文本文件" class="headerlink" title="文本文件"></a>文本文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text/html, text/plain, text/css ...</span><br><span class="line">application/xhtml+xml, application/xml...</span><br></pre></td></tr></table></figure><h4 id="图片文件"><a href="#图片文件" class="headerlink" title="图片文件"></a>图片文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image/jpeg, image/gif，image/png ...</span><br></pre></td></tr></table></figure><h4 id="视频文件"><a href="#视频文件" class="headerlink" title="视频文件"></a>视频文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">video/mpeg, video/quicktime ...</span><br></pre></td></tr></table></figure><h4 id="应用程序使用的二进制文件"><a href="#应用程序使用的二进制文件" class="headerlink" title="应用程序使用的二进制文件"></a>应用程序使用的二进制文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">application/octet-stream, application/zip ...</span><br></pre></td></tr></table></figure><p>当服务器提供多种内容时，将会首先返回权重值（权重值用q表示，默认为1.0，取值0~1，如:q=1.0）最高的媒体类型。</p><h3 id="Accept-Charset"><a href="#Accept-Charset" class="headerlink" title="Accept-Charset"></a>Accept-Charset</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Charset: iso-8859-5, Unicode-1-1;q=0.8</span><br></pre></td></tr></table></figure><p><code>Accept-Charset</code>首部字段可用来通知服务器用户代理<strong>支持的字符集及字符集的相对优先顺序</strong>。另外，可一次性指定多种字符集。与首部字段<code>Accept</code>相同的是可用权重q值来表示相对优先级。</p><h3 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure><p><code>Accept-Encoding</code>首部字段用来告知服务器用户代理<strong>支持的内容编码及内容编码的优先级顺序</strong>。可一次性指定多种内容编码。</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul><h3 id="Accept-Language"><a href="#Accept-Language" class="headerlink" title="Accept-Language"></a>Accept-Language</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept - Language: zh-cn., zh;q=0.7^en-us^en;q=0.3</span><br></pre></td></tr></table></figure><p>首部字段<code>Accept-Language</code>用来告知服务器用户代理能够处理的<strong>自然语言集</strong>（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。</p><h3 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Basic dWVub3NlbjpwYXNzd29yZA==</span><br></pre></td></tr></table></figure><p>首部字段<code>Authorization</code>是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段<code>Authorization</code>加入请求中。共用缓存在接收到含有<code>Authorization</code>首部字段的请求时的操作处理会略有差异。</p><h3 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a>Expect</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expect: 100-continue</span><br></pre></td></tr></table></figure><p>客户端使用首部字段<code>Expect</code>来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 <code>417 Expectation Failed</code>。</p><h3 id="From"><a href="#From" class="headerlink" title="From"></a>From</h3><p>首部字段<code>From</code>用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含<code>From</code>首部字段（但可能会因代理不同，将电子邮件地址记录在<code>User-Agent</code>首部字段内）。</p><h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Host: www.hackr.jp</span><br></pre></td></tr></table></figure><p>首部字段<code>Host</code>会告知服务器，请求的资源所处的互联网主机名和端口号。<code>Host</code>首部字段在HTTP/1.1规范内是<strong>唯——个必须被包含</strong>在请求内的首部字段。</p><h3 id="If-Match"><a href="#If-Match" class="headerlink" title="If-Match"></a>If-Match</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Match: &quot;123456&quot;</span><br></pre></td></tr></table></figure><p>形如<code>If-xxx</code>这种样式的请求首部字段，都可称为<strong>条件请求</strong>。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。<br>首部字段<code>If-Match</code>，属附带条件之一，它会告知服务器匹配资源所用的实体标记（<code>ETag</code>)值。这时的服务器无法使用<code>弱ETag</code>值。（请参照本章有关首部字段<code>ETag</code>的说明）。<br>服务器会比对<code>If-Match</code>的字段值和资源的<code>ETag</code>值，仅当两者一致时，才会执行请求。反之，则返回状态码<code>412 Precondition Failed</code>的响应。</p><h3 id="If-Modified-Since"><a href="#If-Modified-Since" class="headerlink" title="If-Modified-Since"></a>If-Modified-Since</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT</span><br></pre></td></tr></table></figure><p><code>If-Modified-Since</code>用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段<code>Last-Modified</code>来确定。</p><h3 id="If-None-Match"><a href="#If-None-Match" class="headerlink" title="If-None-Match"></a>If-None-Match</h3><p>首部字段<code>If-None-Match</code>属于附带条件之一。它和首部字段<code>If-Match</code>作用相反。用于指定<code>If-None-Match</code>字段值的实体标记（<code>ETag</code>)值与请求资源的<code>ETag</code>不一致时，它就告知服务器处理该请求。</p><h3 id="If-Range"><a href="#If-Range" class="headerlink" title="If-Range"></a>If-Range</h3><p>首部字段<code>If-Range</code>属于附带条件之一。它告知服务器若指定的<code>If-Range</code> 字段值（<code>ETag</code>值或者时间）和请求资源的<code>ETag</code>值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</p><h3 id="If-Unmodified-Since"><a href="#If-Unmodified-Since" class="headerlink" title="If-Unmodified-Since"></a>If-Unmodified-Since</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Unmodified-Since: Thu, 03 ]ul 2012 00:00:00 GMT</span><br></pre></td></tr></table></figure><p>首部字段<code>If-Unmodified-Since</code>和首部字段<code>If-Modified-Since</code>的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码<code>412 Precondition Failed</code>作为响应返回。</p><h3 id="Max-Forwards"><a href="#Max-Forwards" class="headerlink" title="Max-Forwards"></a>Max-Forwards</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Max-Forwards: 10</span><br></pre></td></tr></table></figure><p>通过<code>TRACE</code>方法或<code>OPTIONS</code>方法，发送包含首部字段<code>Max-Forwards</code>的请求时， 该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，<code>Max-Forwards</code>的值减1后重新赋值。当服务器接收到<code>Max-Forwards</code>值为0的请求时，则不再进行转发，而是直接返回响应。</p><h3 id="Proxy-Authorization"><a href="#Proxy-Authorization" class="headerlink" title="Proxy-Authorization"></a>Proxy-Authorization</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</span><br></pre></td></tr></table></figure><p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段<code>Proxy-Authorization</code>的请求，以告知服务器认证所需要的柄息。</p><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Range: bytes=5001-10000</span><br></pre></td></tr></table></figure><p>接收到附带<code>Range</code>首部字段请求的服务器，会在处理请求之后返回状态码为<code>206 Partial Content</code>的响应。无法处理该范围请永时，则会返回状态码<code>200 OK</code>的响应及全部资源。</p><h3 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Referer: http://www.hackr.jp/index.htm</span><br></pre></td></tr></table></figure><p>首部字段<code>Referer</code>会告知服务器请求的原始资源的URI</p><h3 id="TE"><a href="#TE" class="headerlink" title="TE"></a>TE</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TE: gzip, deflate;q=0.5</span><br></pre></td></tr></table></figure><p>首部字段<code>TE</code>会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段<code>Accept-Encoding</code>的功能很相像，但是用于传输编码。</p><h3 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; W0W64; nv:13.0) Gee</span><br></pre></td></tr></table></figure><p>首部字段<code>User-Agent</code>会将创建请求的浏览器和用户代理名称等信息传达给服务器。<br>由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。</p><h2 id="响应首部字段-1"><a href="#响应首部字段-1" class="headerlink" title="响应首部字段"></a>响应首部字段</h2><p>响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p><h3 id="Accept-Ranges"><a href="#Accept-Ranges" class="headerlink" title="Accept-Ranges"></a>Accept-Ranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure><p>首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。</p><h3 id="Age"><a href="#Age" class="headerlink" title="Age"></a>Age</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Age: 600</span><br></pre></td></tr></table></figure><p>首部字段<code>Age</code>能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。<br>若创建该响应的服务器是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段<code>Age</code>。</p><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;34e544327886546ce7676aff67678acd67&quot;</span><br></pre></td></tr></table></figure><p>首部字段<code>ETag</code>能告知客户端实体标识。它是一种可将资源以字符串形式做<em>唯一性标识</em>的方式。服务器会为每份资源分配对应的<code>ETag</code>。</p><p><strong>强ETag值和弱Tag值</strong><br>强<code>ETag</code>值，不论实体发生多么细微的变化都会改变其值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: &quot;usagi-1234&quot;</span><br></pre></td></tr></table></figure></p><p>弱<code>ETag</code>值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变<code>ETag</code>值。这时，会在字段值最开始处附加<code>W/</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: W/&quot;usagi-1234n</span><br></pre></td></tr></table></figure></p><h3 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Location: http://www.usagidesign.jp/sample.html</span><br></pre></td></tr></table></figure><p>使用首部字段<code>Location</code>可以将响应接收方引导至某个与请求URI位置不同的资源。<br>基本上，该字段会配合<code>3xx: Redirection</code>的响应，提供重定向的。</p><h3 id="Proxy-Authenticate"><a href="#Proxy-Authenticate" class="headerlink" title="Proxy-Authenticate"></a>Proxy-Authenticate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy-Authenticate: Basic realm = &quot;UsagidesignAuth&quot;</span><br></pre></td></tr></table></figure><p>首部字段<code>Proxy-Authenticate</code>会把由代理服务器所要求的认证信息发送给客户端。</p><h3 id="Retry-After"><a href="#Retry-After" class="headerlink" title="Retry-After"></a>Retry-After</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retry-After: 120</span><br></pre></td></tr></table></figure><p>首部字段<code>Retry-After</code>告知客户端应该在多久之后再次发送请求。主要配合状态码<code>503 Service Unavailable</code>响应，或<code>3xx Redirect</code>响应一起使用。</p><h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Server: Apache/2.2.6 (Unix) PHP/5.2.5</span><br></pre></td></tr></table></figure><p>首部字段<code>Server</code>告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。</p><h3 id="Vary"><a href="#Vary" class="headerlink" title="Vary"></a>Vary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></table></figure><p>首部字段<code>Vary</code>可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。</p><h3 id="WWW-Authenticate"><a href="#WWW-Authenticate" class="headerlink" title="WWW-Authenticate"></a>WWW-Authenticate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WWW-Authentic ate: Basic realm= &quot;Usagidesign Auth&quot;</span><br></pre></td></tr></table></figure><p>首部字段<code>WWW-Authenticate</code>用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（<code>Basic</code>或是<code>Digest</code>)和带参数提示的质询（<code>challenge</code>)。状态码<code>401 Unauthorized</code>响应中，肯定带有首部字段<code>WWW-Authenticate</code>。</p><h2 id="实体首部字段-1"><a href="#实体首部字段-1" class="headerlink" title="实体首部字段"></a>实体首部字段</h2><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。</p><h3 id="Allow"><a href="#Allow" class="headerlink" title="Allow"></a>Allow</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Allow: GET, HEAD</span><br></pre></td></tr></table></figure><p>首部字段<code>Allow</code>用于通知客户端能够支持<code>Request-URI</code>指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码<code>405 Method Not Allowed</code>作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段<code>Allow</code>后返回。</p><h3 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br></pre></td></tr></table></figure><p>首部字段<code>Content-Encoding</code>会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。</p><p>主要采用以下4种内容编码的方式。</p><ul><li>gzip</li><li>compress</li><li>deflate</li><li>identity</li></ul><h3 id="Content-Language"><a href="#Content-Language" class="headerlink" title="Content-Language"></a>Content-Language</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Language: zh-CN</span><br></pre></td></tr></table></figure><p>首部字段<code>Content-Language</code>会告知客户端，实体主体使用的自然语言(指中文或英文等语言）。</p><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content- Length: 15000</span><br></pre></td></tr></table></figure><p>首部字段<code>Content-Length</code>表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用<code>Content-Length</code>首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开,可参考RFC2616的4.4。</p><h3 id="Content-Location"><a href="#Content-Location" class="headerlink" title="Content-Location"></a>Content-Location</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Location: http://www.hackr.jp/index-ja.html</span><br></pre></td></tr></table></figure><p>首部字段<code>Content-Location</code>给出与报文主体部分相对应的URI和首部字段<code>Location</code>不同，<code>Content-Location</code>表示的是报文主体返回资源对应的URI。</p><h3 id="Content-MD5"><a href="#Content-MD5" class="headerlink" title="Content-MD5"></a>Content-MD5</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-MD5: 0GFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==</span><br></pre></td></tr></table></figure><p>首部字段<code>Content-MD5</code>是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Range: bytes 5001-10000/10000</span><br></pre></td></tr></table></figure><p>针对范围请求，返回响应时使用的首部字段<code>Content-Range</code>，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。</p><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure><p>首部字段<code>Content-Type</code>说明了实体主体内对象的媒体类型。和首部字段<code>Accept</code>一样，只能使用<code>type/subtype</code>形式赋值。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Dul 2012 08:26:05 GMT</span><br></pre></td></tr></table></figure><p>首部字段<code>Expires</code>会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段<code>Expires</code>的响应后，会以缓存来应答请求，在<code>Expires</code>字段值指定的时间之前，响应的副本会一直被保卷。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 23 May 2012 09:59:55 GMT</span><br></pre></td></tr></table></figure><p>首部字段<code>Last-Modified</code>指明资源最终修改的时间。一般来说，这个值就是<code>Request-URI</code>指定资源被修改的时间。但类似使用CGI脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。</p><h2 id="Cookie-服务的首部字段"><a href="#Cookie-服务的首部字段" class="headerlink" title="Cookie 服务的首部字段"></a>Cookie 服务的首部字段</h2><p>至2013年5月，Cookie的规格标准文档有以下4种。</p><ol><li>网景公司颁布的规格标准</li><li>RFC2109</li><li>RFC2965</li><li>RFC6265</li></ol><p><strong>Cookie</strong>服务的首部字段</p><table><thead><tr><th style="text-align:left">首部字段名</th><th style="text-align:left">说明</th><th style="text-align:left">首部类型</th></tr></thead><tbody><tr><td style="text-align:left">Set-Cookie</td><td style="text-align:left">开始状态管理所使用的Cookie信息</td><td style="text-align:left">响应首部字段</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">服务器接收到的Cookie信息</td><td style="text-align:left">请求首部字段</td></tr></tbody></table><h3 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: status=enable; expires=Tue, 05 Dul 2011 07:26:31</span><br></pre></td></tr></table></figure><p>当服务器准备开始管理客户端的状态时，会事先告知各种信息。</p><h4 id="expires属性"><a href="#expires属性" class="headerlink" title="expires属性"></a>expires属性</h4><p>Cookie的<code>expires</code>属性指定浏览器可发送Cookie的有效期。</p><h4 id="path属性"><a href="#path属性" class="headerlink" title="path属性"></a>path属性</h4><p>Cookie的<code>path</code>属性可用于限制指定Cookie的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。</p><h4 id="domain属性"><a href="#domain属性" class="headerlink" title="domain属性"></a>domain属性</h4><p>通过Cookie的<code>domain</code>属性指定的域名可做到与结尾匹配一致。比如，当指定<code>example.com</code>后，除<code>example.com</code>以外，<code>www.example.com</code>或<code>www2.example.com</code>等都可以发送Cookie。</p><h4 id="secure属性"><a href="#secure属性" class="headerlink" title="secure属性"></a>secure属性</h4><p>Cookie的<code>secure</code>属性用于限制Web页面仅在HTTPS安全连接时，才可以发送Cookie。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=value; secure</span><br></pre></td></tr></table></figure><h4 id="HttpOnly属性"><a href="#HttpOnly属性" class="headerlink" title="HttpOnly属性"></a>HttpOnly属性</h4><p>Cookie的<code>HttpOnly</code>属性是Cookie的扩展功會泛，它使JavaScript脚本无法获得Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS)对Cookie的信息窃取。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: status=enable</span><br></pre></td></tr></table></figure><p>首部字段<code>Cookie</code>会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的<code>Cookie</code>。接收到多个<code>Cookie</code>时，同样可以以多个<code>Cookie</code>形式发送。</p><h2 id="非标准首部字段"><a href="#非标准首部字段" class="headerlink" title="非标准首部字段"></a>非标准首部字段</h2><p>HTTP首部字段是可以自行扩展的。所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段。</p><ol><li><code>X-Frame-Options</code></li><li><code>X-XSS-Protection</code></li><li><code>DNT</code></li><li><code>P3P</code></li></ol><h3 id="X-Frame-Options"><a href="#X-Frame-Options" class="headerlink" title="X-Frame-Options"></a>X-Frame-Options</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Frame-Options: DENY</span><br></pre></td></tr></table></figure><p>首部字段<code>X-Frame-Options</code>属于HTTP响应首部，用于控制网站内容在其他Web网站的<code>Frame</code>标签内的显示问题。其主要目的是为了防止点击劫持（click jacking)攻击。</p><h3 id="X-XSS-Protection"><a href="#X-XSS-Protection" class="headerlink" title="X-XSS-Protection"></a>X-XSS-Protection</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-XSS-Protection: 1</span><br></pre></td></tr></table></figure><p>首部字段<code>X-XSS-Protection</code>属于HTTP响应首部，它是针对跨站脚本攻击（XSS)的一种对策，用于控制浏览器XSS防护机制的开关。</p><h3 id="DNT"><a href="#DNT" class="headerlink" title="DNT"></a>DNT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DNT: 1</span><br></pre></td></tr></table></figure><p>首部字段<code>DNT</code>属于HTTP请求首部，其中<code>DNT</code>是”Do Not Track”的简称，意为拒绝个人信息被收集，是表不拒绝被精准广告追踪的一种方法。</p><h3 id="P3P"><a href="#P3P" class="headerlink" title="P3P"></a>P3P</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDe</span><br></pre></td></tr></table></figure><p>首部字段<code>P3P</code>属于HTTP响应首部，通过利用<code>P3P</code> (“The Platform for Privacy Preferences”，在线隐私偏好平台）技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://github.com/Silence--Thinker/Study-HTTP-Book/blob/master/%E7%AC%AC6%E7%AB%A0HTTP%E9%A6%96%E9%83%A8.md" target="_blank" rel="noopener">《图解HTTP》第6章HTTP首部</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-首部字段&quot;&gt;&lt;a href=&quot;#HTTP-首部字段&quot; class=&quot;headerlink&quot; title=&quot;HTTP 首部字段&quot;&gt;&lt;/a&gt;HTTP 首部字段&lt;/h2&gt;&lt;h3 id=&quot;HTTP-首部字段作用&quot;&gt;&lt;a href=&quot;#HTTP-首部字段作用&quot; class=&quot;headerlink&quot; title=&quot;HTTP 首部字段作用&quot;&gt;&lt;/a&gt;HTTP 首部字段作用&lt;/h3&gt;&lt;p&gt;起传递重要信息的作用。&lt;br&gt;使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。&lt;/p&gt;
&lt;h3 id=&quot;HTTP-首部字段结构&quot;&gt;&lt;a href=&quot;#HTTP-首部字段结构&quot; class=&quot;headerlink&quot; title=&quot;HTTP 首部字段结构&quot;&gt;&lt;/a&gt;HTTP 首部字段结构&lt;/h3&gt;&lt;p&gt;HTTP首部字段是由首部字段名和字段值构成的，中间用冒号&lt;code&gt;:&lt;/code&gt;分隔。&lt;br&gt;
    
    </summary>
    
      <category term="网络" scheme="http://happylg.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTP" scheme="http://happylg.cn/tags/HTTP/"/>
    
      <category term="首部" scheme="http://happylg.cn/tags/%E9%A6%96%E9%83%A8/"/>
    
      <category term="首部字段" scheme="http://happylg.cn/tags/%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5/"/>
    
  </entry>
  
  <entry>
    <title>行内元素与块级元素及元素嵌套问题总结</title>
    <link href="http://happylg.cn/2017/09/22/block-and-inline/"/>
    <id>http://happylg.cn/2017/09/22/block-and-inline/</id>
    <published>2017-09-22T14:13:57.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>CSS格式：<code>display:block;</code><br>总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;<br>宽度(<code>width</code>)、高度(<code>height</code>)、内边距(<code>padding</code>)和外边距(<code>margin</code>)都可控制;<br><a id="more"></a><br>块级元素表：</p><table><thead><tr><th style="text-align:center">块级元素标签</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;address&gt;</code></td><td style="text-align:center">定义地址</td></tr><tr><td style="text-align:center"><code>&lt;caption&gt;</code></td><td style="text-align:center">定义表格标题</td></tr><tr><td style="text-align:center"><code>&lt;dd&gt;</code></td><td style="text-align:center">定义列表中定义条目</td></tr><tr><td style="text-align:center"><code>&lt;div&gt;</code></td><td style="text-align:center">定义文档中的分区或节</td></tr><tr><td style="text-align:center"><code>&lt;dl&gt;</code></td><td style="text-align:center">定义列表</td></tr><tr><td style="text-align:center"><code>&lt;dt&gt;</code></td><td style="text-align:center">定义列表中的项目</td></tr><tr><td style="text-align:center"><code>&lt;fieldset&gt;</code></td><td style="text-align:center">定义一个框架集</td></tr><tr><td style="text-align:center"><code>&lt;form&gt;</code></td><td style="text-align:center">创建 HTML 表单</td></tr><tr><td style="text-align:center"><code>&lt;h1&gt;</code></td><td style="text-align:center">定义最大的标题</td></tr><tr><td style="text-align:center"><code>&lt;h2&gt;</code></td><td style="text-align:center">定义副标题</td></tr><tr><td style="text-align:center"><code>&lt;h3&gt;</code></td><td style="text-align:center">定义标题</td></tr><tr><td style="text-align:center"><code>&lt;h4&gt;</code></td><td style="text-align:center">定义标题</td></tr><tr><td style="text-align:center"><code>&lt;h5&gt;</code></td><td style="text-align:center">定义标题</td></tr><tr><td style="text-align:center"><code>&lt;h6&gt;</code></td><td style="text-align:center">定义最小的标题</td></tr><tr><td style="text-align:center"><code>&lt;hr&gt;</code></td><td style="text-align:center">创建一条水平线</td></tr><tr><td style="text-align:center"><code>&lt;legend&gt;</code></td><td style="text-align:center">元素为<code>fieldset</code>元素定义标题</td></tr><tr><td style="text-align:center"><code>&lt;li&gt;</code></td><td style="text-align:center">标签定义列表项目</td></tr><tr><td style="text-align:center"><code>&lt;noframes&gt;</code></td><td style="text-align:center">为那些不支持框架的浏览器显示文本，于<code>frameset</code>元素内部</td></tr><tr><td style="text-align:center"><code>&lt;noscript&gt;</code></td><td style="text-align:center">定义在脚本未被执行时的替代内容</td></tr><tr><td style="text-align:center"><code>&lt;ol&gt;</code></td><td style="text-align:center">定义有序列表</td></tr><tr><td style="text-align:center"><code>&lt;ul&gt;</code></td><td style="text-align:center">定义无序列表</td></tr><tr><td style="text-align:center"><code>&lt;p&gt;</code></td><td style="text-align:center">标签定义段落</td></tr><tr><td style="text-align:center"><code>&lt;pre&gt;</code></td><td style="text-align:center">定义预格式化的文本</td></tr><tr><td style="text-align:center"><code>&lt;table&gt;</code></td><td style="text-align:center">标签定义HTML表格</td></tr><tr><td style="text-align:center"><code>&lt;tbody&gt;</code></td><td style="text-align:center">标签表格主体（正文）</td></tr><tr><td style="text-align:center"><code>&lt;td&gt;</code></td><td style="text-align:center">表格中的标准单元格</td></tr><tr><td style="text-align:center"><code>&lt;tfoot&gt;</code></td><td style="text-align:center">定义表格的页脚（脚注或表注）</td></tr><tr><td style="text-align:center"><code>&lt;th&gt;</code></td><td style="text-align:center">定义表头单元格</td></tr><tr><td style="text-align:center"><code>&lt;thead&gt;</code></td><td style="text-align:center">标签定义表格的表头</td></tr><tr><td style="text-align:center"><code>&lt;tr&gt;</code></td><td style="text-align:center">定义表格中的行</td></tr></tbody></table><h3 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h3><p>和相邻的内联元素在同一行;<br>水平方向的left/right（<code>padding-left</code>, <code>padding-right</code>, <code>margin-left</code>, <code>margin-right</code>）都产生边距效果;<br>宽度(<code>width</code>)、高度(<code>height</code>)、<strong>内边距的<code>top/bottom</code>(<code>padding-top</code>/<code>padding-bottom</code>)和外边距的<code>top</code>/<code>bottom</code>(<code>margin-top</code>/<code>margin-bottom</code>)都不可改变</strong>，就是里面文字或图片的大小;</p><p>行内元素列表：</p><table><thead><tr><th style="text-align:center">行内元素标签</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;a&gt;</code></td><td style="text-align:center">标签可定义锚</td></tr><tr><td style="text-align:center"><code>&lt;abbr&gt;</code></td><td style="text-align:center">表示一个缩写形式</td></tr><tr><td style="text-align:center"><code>&lt;acronym&gt;</code></td><td style="text-align:center">定义只取首字母缩写</td></tr><tr><td style="text-align:center"><code>&lt;b&gt;</code></td><td style="text-align:center">字体加粗</td></tr><tr><td style="text-align:center"><code>&lt;bdo&gt;</code></td><td style="text-align:center">可覆盖默认的文本方向</td></tr><tr><td style="text-align:center"><code>&lt;big&gt;</code></td><td style="text-align:center">大号字体加粗</td></tr><tr><td style="text-align:center"><code>&lt;br&gt;</code></td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center"><code>&lt;cite&gt;</code></td><td style="text-align:center">引用进行定义</td></tr><tr><td style="text-align:center"><code>&lt;code&gt;</code></td><td style="text-align:center">定义计算机代码文本</td></tr><tr><td style="text-align:center"><code>&lt;dfn&gt;</code></td><td style="text-align:center">定义一个定义项目</td></tr><tr><td style="text-align:center"><code>&lt;em&gt;</code></td><td style="text-align:center">定义为强调的内容</td></tr><tr><td style="text-align:center"><code>&lt;i&gt;</code></td><td style="text-align:center">斜体文本效果</td></tr><tr><td style="text-align:center"><code>&lt;img&gt;</code></td><td style="text-align:center">向网页中嵌入一幅图像</td></tr><tr><td style="text-align:center"><code>&lt;input&gt;</code></td><td style="text-align:center">输入框</td></tr><tr><td style="text-align:center"><code>&lt;kbd&gt;</code></td><td style="text-align:center">定义键盘文本</td></tr><tr><td style="text-align:center"><code>&lt;label&gt;</code></td><td style="text-align:center">标签为<code>input</code>元素定义标注（标记）</td></tr><tr><td style="text-align:center"><code>&lt;q&gt;</code></td><td style="text-align:center">定义短的引用</td></tr><tr><td style="text-align:center"><code>&lt;samp&gt;</code></td><td style="text-align:center">定义样本文本</td></tr><tr><td style="text-align:center"><code>&lt;select&gt;</code></td><td style="text-align:center">创建单选或多选菜单</td></tr><tr><td style="text-align:center"><code>&lt;small&gt;</code></td><td style="text-align:center">呈现小号字体效果</td></tr><tr><td style="text-align:center"><code>&lt;span&gt;</code></td><td style="text-align:center">组合文档中的行内元素</td></tr><tr><td style="text-align:center"><code>&lt;strong&gt;</code></td><td style="text-align:center">语气更强的强调的内容</td></tr><tr><td style="text-align:center"><code>&lt;sub&gt;</code></td><td style="text-align:center">定义下标文本</td></tr><tr><td style="text-align:center"><code>&lt;sup&gt;</code></td><td style="text-align:center">定义上标文本</td></tr><tr><td style="text-align:center"><code>&lt;textarea&gt;</code></td><td style="text-align:center">多行的文本输入控件</td></tr><tr><td style="text-align:center"><code>&lt;tt&gt;</code></td><td style="text-align:center">打字机或者等宽的文本效果</td></tr><tr><td style="text-align:center"><code>&lt;var&gt;</code></td><td style="text-align:center">定义变量</td></tr></tbody></table><h3 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h3><p>将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。使其同时具有block的宽高特性和inline的同行特性</p><h2 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h2><p>引用自:<a href="https://www.zhihu.com/question/37797740/answer/73555038" target="_blank" rel="noopener">HTML 标签的嵌套规则</a></p><ol><li><p>块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; ------ 对　　</span><br><span class="line">&lt;a href=”#”&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; ------ 对　　</span><br><span class="line">&lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; ------ 错</span><br></pre></td></tr></table></figure></li><li><p>块级元素不能放在<code>&lt;p&gt;</code>里面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; ------ 错</span><br><span class="line">&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; ------ 错</span><br></pre></td></tr></table></figure></li><li><p>有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：<code>h1</code>、<code>h2</code>、<code>h3</code>、<code>h4</code>、<code>h5</code>、<code>h6</code>、<code>p</code>、<code>dt</code></p></li><li><code>li</code>内可以包含<code>div</code>标签—-这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明：<code>li</code>和<code>div</code>标签都是装载内容的容器，地位平等，没有级别之分（例如：<code>h1</code>、<code>h2</code>这样森严的等级制度^_^），要知道，<code>li</code>标签连它的父级<code>ul</code>或者是<code>ol</code>都 可以容纳的，为什么有人会觉得<code>li</code>偏偏容纳不下一个<code>div</code>呢？　</li><li>块级元素与块级元素并列、内嵌元素与内嵌元素并列<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; ------ 对</span><br><span class="line">&lt;div&gt;&lt;a href=”#”&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; ------ 对</span><br><span class="line">&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; ------ 错</span><br></pre></td></tr></table></figure></li></ol><h3 id="HTML5元素分类"><a href="#HTML5元素分类" class="headerlink" title="HTML5元素分类"></a>HTML5元素分类</h3><p>引用自：<a href="http://blog.shaochuancs.com/w3c-html5-content-model/" target="_blank" rel="noopener">元素分类与内容模型</a><br>在HTML5中，标准制定者重新定义了HTML元素的分类，并根据这一新的分类定义了元素的内容模型(Content Model) – 对于一个元素而言，哪些子元素是合法的，而哪些子元素是非法的。<br>HTML5中，元素主要分为7类：</p><ol><li>Metadata</li><li>Flow</li><li>Sectioning</li><li>Heading</li><li>Phrasing</li><li>Embedded</li><li>Interactive</li></ol><p><img src="/img/content-model.jpg" alt="Content Model"></p><h4 id="Metadata（元数据元素）"><a href="#Metadata（元数据元素）" class="headerlink" title="Metadata（元数据元素）"></a>Metadata（元数据元素）</h4><p>顾名思义，<strong>Metadata元素意指那些定义文档元数据信息的元素</strong> — 其作用包括：影响文档中其它节点的展现与行为、定义文档与其它外部资源之间的关系等。以下元素属于Metadata：<code>base</code>, <code>link</code>, <code>meta</code>, <code>noscript</code>, <code>script</code>, <code>style</code>, <code>template</code>, <code>title</code>。</p><h4 id="Flow（流式元素）"><a href="#Flow（流式元素）" class="headerlink" title="Flow（流式元素）"></a>Flow（流式元素）</h4><p><strong>所有可以放在body标签内</strong>，构成文档内容的元素均属于Flow元素。因此，除了<code>base</code>, <code>link</code>, <code>meta</code>, <code>style</code>, <code>title</code>等只能放在<code>head</code>标签内的元素外，剩下的所有元素均属于Flow元素。具体包含：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b，</span><br><span class="line">bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， </span><br><span class="line">del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form，</span><br><span class="line">h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， </span><br><span class="line">ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， </span><br><span class="line">object， ol， output， p， pre， progress， q， ruby， s， samp， script， section，</span><br><span class="line">select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup，</span><br><span class="line">svg， table，textarea， time， u， ul， var， video， wbr， text</span><br></pre></td></tr></table></figure></p><h4 id="Sectioning（章节元素）"><a href="#Sectioning（章节元素）" class="headerlink" title="Sectioning（章节元素）"></a>Sectioning（章节元素）</h4><p>Sectioning意指定义页面结构的元素，具体包含以下四个：<code>article</code>, <code>aside</code>, <code>nav</code>, <code>section</code>。</p><h4 id="Heading（标题元素）"><a href="#Heading（标题元素）" class="headerlink" title="Heading（标题元素）"></a>Heading（标题元素）</h4><p>所有标题元素属于Heading，也即以下6个元素：<code>h1</code>, <code>h2</code>, <code>h3</code>, <code>h4</code>, <code>h5</code>, <code>h6</code>。</p><h4 id="Phrasing（段落元素）"><a href="#Phrasing（段落元素）" class="headerlink" title="Phrasing（段落元素）"></a>Phrasing（段落元素）</h4><p><strong>所有可以放在p标签内，构成段落内容的元素均属于Phrasing元素</strong>。因此，所有Phrasing元素均属于Flow元素。在HTML5标准文档中，关于Phrasing元素的原始定义为：</p><blockquote><p>Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.</p></blockquote><p>对于这一定义，个人认为不应当使用“text”这一容易引起误解的词，事实上，一个元素即使不是文本，只要能包含在p标签中成为段落内容的一部分，就可以称之为Phrasing元素。比如：<code>audio</code>、<code>video</code>、<code>img</code>、<code>select</code>、<code>input</code>等元素(经测试，这些元素都可以放置在p标签中)。<br>具体包含如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b，</span><br><span class="line">bdi， bdo， br， button， canvas， cite， code， command， datalist， </span><br><span class="line">del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， </span><br><span class="line">ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素），</span><br><span class="line">mark， math， meter， noscript， object， output， progress， q， ruby， s，</span><br><span class="line">samp， script，select， small， span， strong， sub， sup， svg， textarea，</span><br><span class="line">time， u， var， video， wbr， text</span><br></pre></td></tr></table></figure></p><p>Phrasing元素内部一般只能包含别的Phrasing元素。<br>关于Phrasing元素，<a href="https://stackoverflow.com/questions/30233447/what-is-the-difference-between-phrasing-content-and-flow-content" target="_blank" rel="noopener">Stackoverflow上有一个比较精彩的问答</a>，可供参考。</p><h4 id="Embedded（嵌入元素）"><a href="#Embedded（嵌入元素）" class="headerlink" title="Embedded（嵌入元素）"></a>Embedded（嵌入元素）</h4><p>所有用于在网页中<strong>嵌入外部资源的元素</strong>均属于Embedded元素，具体包含以下9个：<code>audio</code>, <code>video</code>, <code>img</code>, <code>canvas</code>, <code>svg</code>, <code>iframe</code>, <code>embed</code>, <code>object</code>, <code>math</code>。</p><h4 id="Interactive（交互元素）"><a href="#Interactive（交互元素）" class="headerlink" title="Interactive（交互元素）"></a>Interactive（交互元素）</h4><p>所有与用户交互有关的元素均属于Interactive元素，包括<code>a</code>, <code>input</code>, <code>textarea</code>, <code>select</code>等。<br>具体包含如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a， audio（如果设置了controls属性）， button， details， embed， iframe，</span><br><span class="line">img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label，</span><br><span class="line">menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， </span><br><span class="line">textarea， video（如果设置了controls属性）</span><br></pre></td></tr></table></figure></p><h3 id="HTML5内容模型-Content-Model"><a href="#HTML5内容模型-Content-Model" class="headerlink" title="HTML5内容模型(Content Model)"></a>HTML5内容模型(Content Model)</h3><p>根据以上元素分类，HTML5标准文档定义了任何元素的内容模型 — 对于该元素而言，何种子元素才是合法的。<br>比如，对于p元素而言，其内容模型为Phrasing, 这意味着<code>p</code>元素只接受Phrasing元素为子元素，而对于像<code>div</code>这样的非Phrasing元素则并不接受。类似的，<code>li</code>元素的内容模型为Flow，因此任何可以放置在<code>body</code>中的元素都可以作为<code>li</code>元素的子元素。</p><h4 id="透明内容模型-Transparent-content-models"><a href="#透明内容模型-Transparent-content-models" class="headerlink" title="透明内容模型(Transparent content models)"></a>透明内容模型(Transparent content models)</h4><p>值得注意的是，HTML5标准文档在定义元素的内容模型时，会使用一类特殊的分类：<strong>透明内容模型(transparent) — 对于内容模型为透明(transparent)的元素而言，其子元素的合法性由其父元素所决定；如果其父元素的内容模型仍为透明，则查看其祖父元素的情况，并依此类推；如果向上推演至body标签仍未找到任何内容模型非透明的父级元素，则该透明元素内部可包含任何Flow元素。</strong><br>透明元素目前W3C中也没有给出明确的包含哪些元素，从段落元素中推断透明内容模型元素有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, ins, del, map</span><br></pre></td></tr></table></figure></p><p><strong>典型的具有透明内容模型的元素为<code>a</code>元素</strong>。因此，当<code>a</code>出现在<code>p</code>标签中时，<code>a</code>不能接受<code>div</code>作为子元素；而当<code>a</code>出现在<code>div</code>标签中时，<code>a</code>可以接受<code>div</code>作为子元素。对此，<a href="http://www.zhihu.com/question/34952563" target="_blank" rel="noopener">知乎上有一个问答解释了这种现象</a>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://www.zhihu.com/question/34952563/answer/60672228" target="_blank" rel="noopener">a 标签为什么能够包含块级元素？</a></li><li><a href="http://blog.shaochuancs.com/w3c-html5-content-model/" target="_blank" rel="noopener">W3C HTML5标准阅读笔记 – 元素分类与内容模型(Content Model)</a></li><li><a href="http://www.w3.org/TR/html5/dom.html#content-models" target="_blank" rel="noopener">content-models</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;区别&quot;&gt;&lt;a href=&quot;#区别&quot; class=&quot;headerlink&quot; title=&quot;区别&quot;&gt;&lt;/a&gt;区别&lt;/h2&gt;&lt;h3 id=&quot;块级元素&quot;&gt;&lt;a href=&quot;#块级元素&quot; class=&quot;headerlink&quot; title=&quot;块级元素&quot;&gt;&lt;/a&gt;块级元素&lt;/h3&gt;&lt;p&gt;CSS格式：&lt;code&gt;display:block;&lt;/code&gt;&lt;br&gt;总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;&lt;br&gt;宽度(&lt;code&gt;width&lt;/code&gt;)、高度(&lt;code&gt;height&lt;/code&gt;)、内边距(&lt;code&gt;padding&lt;/code&gt;)和外边距(&lt;code&gt;margin&lt;/code&gt;)都可控制;&lt;br&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://happylg.cn/categories/HTML/"/>
    
    
      <category term="html" scheme="http://happylg.cn/tags/html/"/>
    
      <category term="inline" scheme="http://happylg.cn/tags/inline/"/>
    
      <category term="block" scheme="http://happylg.cn/tags/block/"/>
    
      <category term="inline-block" scheme="http://happylg.cn/tags/inline-block/"/>
    
      <category term="嵌套" scheme="http://happylg.cn/tags/%E5%B5%8C%E5%A5%97/"/>
    
  </entry>
  
  <entry>
    <title>跨域总结</title>
    <link href="http://happylg.cn/2017/09/22/cross-origin/"/>
    <id>http://happylg.cn/2017/09/22/cross-origin/</id>
    <published>2017-09-21T16:46:14.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h2><p>同源定义：协议+域名+端口号。同源表示三者均相等。</p><blockquote><p>同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。</p></blockquote><p>浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。</p><h3 id="无同源策略的危害"><a href="#无同源策略的危害" class="headerlink" title="无同源策略的危害"></a>无同源策略的危害</h3><ol><li>接口请求：从其他网站发起请求从而导致的CSRF攻击。</li><li>DOM查询：由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom。从而更能轻易获取用户密码等隐私数据。</li></ol><p>同源策略可以预防某些恶意行为，但实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。<br><a id="more"></a></p><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP是JSON with padding（填充式 JSON 或参数式 JSON）的简写，JSONP由两部分组成：<strong>回调函数和数据</strong>。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 客户端部分</span></span><br><span class="line"><span class="comment">// JSONP跨域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkJsonp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.setAttribute(<span class="string">'src'</span>, <span class="string">'http://127.0.0.1:8081/jsonp?name=zxlg&amp;age=26&amp;callback=handleRes'</span>)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 客户端响应处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleRes</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = res;</span><br><span class="line">    alert(name + <span class="string">' is '</span> + age + <span class="string">' years old'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.服务端部分(express)</span></span><br><span class="line">app.get(<span class="string">'/jsonp'</span>, (req, res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; query &#125; = req</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, callback &#125; = query</span><br><span class="line">  <span class="keyword">const</span> response = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(callback + <span class="string">'('</span> + <span class="built_in">JSON</span>.stringify(response) + <span class="string">')'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其实JSONP也是需要服务端支持，服务端必须返回执行的代码，即<code>Fn(param)</code>，所以一般后端使用cors机制处理跨域机制比较好。</p><h3 id="空iframe-from"><a href="#空iframe-from" class="headerlink" title="空iframe+from"></a>空iframe+from</h3><p>jsonp只能发送get请求，使用iframe+from可以发起post请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iframePost = <span class="function">(<span class="params">&#123;url, data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先创建一个用来发送数据的iframe.</span></span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    iframe.name = <span class="string">'iframePost'</span></span><br><span class="line">    iframe.style.display = <span class="string">'none'</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line">    <span class="keyword">const</span> form = <span class="built_in">document</span>.createElement(<span class="string">'form'</span>)</span><br><span class="line">    <span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(<span class="string">'input'</span>)</span><br><span class="line">    <span class="comment">// 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话.</span></span><br><span class="line">    iframe.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'iframe post success'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    form.action = url</span><br><span class="line">    <span class="comment">// 在指定的iframe中执行form</span></span><br><span class="line">    form.target = iframe.name</span><br><span class="line">    form.method = <span class="string">'post'</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> name <span class="keyword">in</span> data) &#123;</span><br><span class="line">    node.name = name</span><br><span class="line">    node.value = data[name].toString()</span><br><span class="line">    form.appendChild(node.cloneNode())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 表单元素需要添加到主文档中.</span></span><br><span class="line">    form.style.display = <span class="string">'none'</span></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(form)</span><br><span class="line">    form.submit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表单提交后,就可以删除这个表单,不影响下次的数据发送.</span></span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(form)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方式</span></span><br><span class="line"><span class="keyword">const</span> checkIframe = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    iframePost(&#123;</span><br><span class="line">    url: <span class="string">'http://127.0.0.1:8081/iframePost'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        msg: <span class="string">'iframe + from'</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点是获取请求返回的数据会遇到跨域DOM查询的问题</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><blockquote><p>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p></blockquote><h4 id="简单请求与复杂请求"><a href="#简单请求与复杂请求" class="headerlink" title="简单请求与复杂请求"></a>简单请求与复杂请求</h4><h5 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h5><blockquote><ol><li>请求方法是以下三种方法之一：<code>HEAD, GET POST</code></li><li>HTTP的头信息不超出以下几种字段：<code>Accept, Accept-Language, Content-Language, Last-Event-ID, Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</code></li></ol></blockquote><h5 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h5><blockquote><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者Content-Type字段的类型是<code>application/json</code>。<br>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。<br>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。<br>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。<br>服务器收到”预检”请求以后，检查了<code>Origin、Access-Control-Request-Method和Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p></blockquote><h4 id="实现一个CORS跨域请求"><a href="#实现一个CORS跨域请求" class="headerlink" title="实现一个CORS跨域请求"></a>实现一个CORS跨域请求</h4><h5 id="客户端发起ajax请求"><a href="#客户端发起ajax请求" class="headerlink" title="客户端发起ajax请求"></a>客户端发起ajax请求</h5><p>默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将<code>withCredentials</code>属性设置为<code>true</code>，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的HTTP头部来响应。<code>Access-Control-Allow-Credentials:true</code>。<br>如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p><p>客户端使用axios发起请求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">    baseURL: <span class="string">'http://127.0.0.1:8081'</span>,</span><br><span class="line">    url: <span class="string">'/cors'</span>,</span><br><span class="line">    method: <span class="string">'post'</span>,</span><br><span class="line">    withCredentials: <span class="literal">false</span>, <span class="comment">// 要发送Cookie，服务端必须指定明确的、与请求网页一致的域名</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">'zxlg'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="服务器配置CORS"><a href="#服务器配置CORS" class="headerlink" title="服务器配置CORS"></a>服务器配置CORS</h5><p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务器端设置响应头，各个服务器实现方法略有不同</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'http://127.0.0.1:8080'</span> <span class="comment">// 允许访问的源</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Methods'</span>:<span class="string">'GET,PUT,POST,DELETE'</span> <span class="comment">// 允许使用的请求方法</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Headers'</span>:<span class="string">'Content-Type'</span> <span class="comment">// 允许的头部</span></span><br><span class="line"><span class="string">'Access-Control-Allow-Credentials'</span>:<span class="string">'true'</span>/<span class="string">'flase'</span></span><br></pre></td></tr></table></figure><p>以express为例:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// allow custom header and CORS</span></span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT, POST, GET, DELETE, OPTIONS'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (req.method === <span class="string">'OPTIONS'</span>) &#123;</span><br><span class="line">    res.sendStatus(<span class="number">200</span>) <span class="comment">// 让options请求快速返回</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">'/cors'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name &#125; = req.body</span><br><span class="line">  res.json(&#123;</span><br><span class="line">    resMsg: <span class="string">`hello <span class="subst">$&#123;name&#125;</span>!`</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="跨域DOM查询"><a href="#跨域DOM查询" class="headerlink" title="跨域DOM查询"></a>跨域DOM查询</h2><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage() <span class="comment">// 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (e)=&gt; &#123;</span><br><span class="line">    <span class="comment">// 接收请求</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>Javascript高级程序编程第三版</li><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">跨域资源共享CORS详解–阮一峰</a></li><li><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">不要再问我跨域的问题了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;同源策略&quot;&gt;&lt;a href=&quot;#同源策略&quot; class=&quot;headerlink&quot; title=&quot;同源策略&quot;&gt;&lt;/a&gt;同源策略&lt;/h2&gt;&lt;p&gt;同源定义：协议+域名+端口号。同源表示三者均相等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。&lt;/p&gt;
&lt;h3 id=&quot;无同源策略的危害&quot;&gt;&lt;a href=&quot;#无同源策略的危害&quot; class=&quot;headerlink&quot; title=&quot;无同源策略的危害&quot;&gt;&lt;/a&gt;无同源策略的危害&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;接口请求：从其他网站发起请求从而导致的CSRF攻击。&lt;/li&gt;
&lt;li&gt;DOM查询：由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom。从而更能轻易获取用户密码等隐私数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同源策略可以预防某些恶意行为，但实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://happylg.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="跨域" scheme="http://happylg.cn/tags/%E8%B7%A8%E5%9F%9F/"/>
    
      <category term="cors" scheme="http://happylg.cn/tags/cors/"/>
    
      <category term="jsonp" scheme="http://happylg.cn/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>Canvas和svg总结比较</title>
    <link href="http://happylg.cn/2017/09/21/canvas-and-svg/"/>
    <id>http://happylg.cn/2017/09/21/canvas-and-svg/</id>
    <published>2017-09-21T01:34:24.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>getContext()</code></p><h3 id="描边和填充"><a href="#描边和填充" class="headerlink" title="描边和填充"></a>描边和填充</h3><p><code>strokeStyle</code>：设置描边样式<br><code>fillStyle</code>：设置填充样式<br><code>stroke()</code>：描边<br><code>fill()</code>：填充<br><a id="more"></a></p><h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p><code>fillRect()</code>：填充矩形<br><code>strokeRect()</code>：描边矩形<br><code>clearRect()</code>：清除画布矩形区域</p><h3 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h3><p><code>beginPath()</code>：开始绘制路径<br><code>arc(x, y, radius, startAngle, endAngle, counterclockwise)</code>：以(x,y)为圆心绘制一条弧线，弧线半径为<code>radius</code>，起始和结束角度（用弧度表示）分别为<code>startAngle</code>和<code>endAngle</code>。最后一个参数表示<code>startAngle</code>和<code>endAngle</code>是否按逆时针方向计算，值为<code>false</code>表示按顺时针方向计算。<br><code>arcTo(x1, y1, x2, y2, radius)</code>：从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径<code>radius</code>穿过(x1,y1)。<br><code>bezierCurveTo(c1x, c1y, c2x, c2y, x, y)</code>：从上一点开始绘制一条曲线，到(x,y)为<br>止，并且以(c1x,c1y)和(c2x,c2y)为控制点。<br><code>lineTo(x, y)</code>：从上一点开始绘制一条直线，到(x,y)为止。<br><code>moveTo(x, y)</code>：将绘图游标移动到(x,y)，<strong>不画线</strong>。<br>如果路径已经完成，你想用<code>fillStyle</code>填充它，可以调用<code>fill()</code>方法。另外，还可以调用<code>stroke()</code>方法对路径描边，描边使用的是<code>strokeStyle</code>。最后还可以调用<code>clip()</code>，这个方法可以在路径上创建一个剪切区域。</p><h3 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h3><p>绘制文本主要有两个方法：<code>fillText()</code>和<code>strokeText()</code>。这两个方法都可以接收 4 个参数：要绘制的文本字符串、 x 坐标、 y 坐标和可选的最大像素宽度。<br>这两个方法都以下列 3 个属性为基础:<br><code>font</code>：表示文本样式、大小及字体，用 CSS 中指定字体的格式来指定，例如”10px Arial”。<br><code>textAlign</code>：表示文本对齐方式。可能的值有”start”、”end”、”left”、”right”和”center”。<br>建议使用”start”和”end”，不要使用”left”和”right”，因为前两者的意思更稳妥，能同时<br>适合从左到右和从右到左显示（阅读）的语言。<br><code>textBaseline</code>：表示文本的基线。可能的值有”top”、”hanging”、”middle”、”alphabetic”、<br>“ideographic”和”bottom”。</p><h3 id="变换"><a href="#变换" class="headerlink" title="变换"></a>变换</h3><p><code>rotate(angle)</code>：围绕原点旋转图像<code>angle</code>弧度。<br><code>scale(scaleX, scaleY)</code>：缩放图像，在x方向乘以<code>scaleX</code>，在y方向乘以<code>scaleY</code>。<code>scaleX</code>和<code>scaleY</code>的默认值都是1.0。<br><code>translate(x, y)</code>：将坐标原点移动到(x,y)。执行这个变换之后， 坐标(0,0)会变成之前由(x,y)表示的点。<br><code>transform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code>：直接修改变换矩阵，方式是乘以如下矩阵。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1_1 m1_2 dx</span><br><span class="line">m2_1 m2_2 dy</span><br><span class="line">0 0 1</span><br></pre></td></tr></table></figure></p><p><code>setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)</code>：将变换矩阵重置为默认状态，然后再调用 <code>transform()</code>。</p><p>无论是刚才执行的变换，还是<code>fillStyle</code>、<code>strokeStyle</code>等属性，都会在当前上下文中一直有效，除非再对上下文进行什么修改。虽然没有什么办法把上下文中的一切都重置回默认值，但有两个方法可以跟踪上下文的状态变化。<br>如果你知道将来还要返回某组属性与变换的组合，可以调用<code>save()</code>方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。<br>然后可以对上下文进行其他修改。<br>等想要回到之前保存的设置时，可以调用<code>restore()</code>方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。<br>连续调用<code>save()</code>可以把更多设置保存到栈结构中，之后再连续调用<code>restore()</code>则可以一级一级返回。</p><h3 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">Canvas</a></li><li>Javascript高级程序编程第三版–使用Canvas绘图p445</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Canvas&quot;&gt;&lt;a href=&quot;#Canvas&quot; class=&quot;headerlink&quot; title=&quot;Canvas&quot;&gt;&lt;/a&gt;Canvas&lt;/h2&gt;&lt;h3 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h3&gt;&lt;p&gt;&lt;code&gt;getContext()&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;描边和填充&quot;&gt;&lt;a href=&quot;#描边和填充&quot; class=&quot;headerlink&quot; title=&quot;描边和填充&quot;&gt;&lt;/a&gt;描边和填充&lt;/h3&gt;&lt;p&gt;&lt;code&gt;strokeStyle&lt;/code&gt;：设置描边样式&lt;br&gt;&lt;code&gt;fillStyle&lt;/code&gt;：设置填充样式&lt;br&gt;&lt;code&gt;stroke()&lt;/code&gt;：描边&lt;br&gt;&lt;code&gt;fill()&lt;/code&gt;：填充&lt;br&gt;
    
    </summary>
    
      <category term="HTML" scheme="http://happylg.cn/categories/HTML/"/>
    
    
      <category term="canvas" scheme="http://happylg.cn/tags/canvas/"/>
    
      <category term="svg" scheme="http://happylg.cn/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的闭包</title>
    <link href="http://happylg.cn/2017/09/18/js-closure/"/>
    <id>http://happylg.cn/2017/09/18/js-closure/</id>
    <published>2017-09-18T13:58:17.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>通过函数表达式生成的函数为匿名函数，因为<code>function</code>关键字后面没有标识符。匿名函数的<code>name</code>属性是空字符串。<br>通过函数表达式生成的函数不会变量提升，但是通过函数声明的函数会变量提升，即可以在使用后声明。</p><p><code>arguments.callee</code>是一个指向正在执行的函数的指针。可以在递归中使用<br><a id="more"></a></p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。<br>创建闭包的方式就是在一个函数内部创建另外一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testClosure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = testClosure();</span><br><span class="line"><span class="keyword">var</span> a = func();</span><br></pre></td></tr></table></figure></p><p>即使这个内部函数被返回了,而且在其他地方被调用了，但他仍然可以访问变量a，因为内部函数的作用域链中包含了<code>testClosure()</code>的作用域。<br>当某个函数被调用时，会创建一个执行环境(excution text)及相应的作用域链。但在作用域链中，<strong>使用<code>arguments</code>和其他命名参数的值来初始化函数的活动对象(activation object)。</strong>在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数处于第三位，……直至作用域链的终点全局执行环境。</p><h3 id="普通函数执行"><a href="#普通函数执行" class="headerlink" title="普通函数执行"></a>普通函数执行</h3><p>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而局部环境的变量对象，则只在函数执行的过程中存在。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p><h4 id="创建函数"><a href="#创建函数" class="headerlink" title="创建函数"></a>创建函数</h4><p>在创建<code>compare()</code>函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的<code>[[Scope]]属性中</code>。</p><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><p>当调用<code>compare()</code>函数时，会为函数创建一个执行环境，然后通过复制函数的<code>[[Scope]]</code>属性中的对象构建起执行环境的作用域链。<br>此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中<code>compare()</code>函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。<br><img src="/img/普通函数执行.png" alt="普通函数执行.png"></p><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。<br>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是闭包情况有所区别。</p><h3 id="闭包执行"><a href="#闭包执行" class="headerlink" title="闭包执行"></a>闭包执行</h3><p>在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testClosure</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func = testClosure();</span><br><span class="line"><span class="keyword">var</span> a = func();</span><br><span class="line"></span><br><span class="line"><span class="comment">//解除对匿名函数的引用，以便释放内存</span></span><br><span class="line">func = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p>在匿名函数从<code>testClosure()</code>中被返回后，它的作用域链被初始化包含<code>testClosure()</code>函数的活动对象和全局变量对象。这样匿名函数就可以访问在<code>testClosure()</code>中定义的所有变量。<br>更为重要的是，<code>testClosure()</code>函数执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。<strong>换句话说，当<code>testClosure()</code>函数返回后，其执行环境的作用域链会被销毁，但是它的活动对象仍然留在内存中。直到匿名函数被销毁后，<code>testClosure()</code>函数的活动对象才会被销毁。</strong></p><p>通过设置<code>func = null;</code>解除对匿名函数的引用，以便释放内存，等于通知垃圾回收例程将其清除。</p><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i * i;<span class="comment">//返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值的平方，即位置0的函数返回0^2，位置1的函数返回1^2，以此类推。但实际上，每个函数都返回 10^2。因为每个函数的作用域链中都保存着<code>count()</code>函数的活动对象，所以它们引用的都是同一个变量<code>i</code>。 当<code>count()</code>函数返回后，变量<code>i</code>的值是10，此时每个函数都引用着保存变量<code>i</code>的同一个变量对象，所以在每个函数内部<code>i</code>的值都是 10。</p><p>可以建立另一个匿名函数并立即执行，将<code>i</code>传入其中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr.push(</span><br><span class="line">            (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> n * n;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)(i)</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>“创建一个匿名函数并立刻执行” 理论上讲，创建一个匿名函数并立刻执行可以这么写：<br><code>function (x) { return x * x } (3);</code>，但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：<code>(function (x) { return x * x }) (3);</code>这种方法理论上可以模仿块级作用域。</p><h3 id="闭包中的this对象"><a href="#闭包中的this对象" class="headerlink" title="闭包中的this对象"></a>闭包中的this对象</h3><p>参见我的博客<a href="http://happylg.cn/2017/08/05/js-scope/#this对象">this对象</a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"The Window"（在非严格模式下）</span></span><br></pre></td></tr></table></figure></p><p>每个函数在被调用时都会自动取得两个特殊变量：<code>this</code>和<code>arguments</code>。内部函数在搜索这两个变量时，只会搜索到其活动变量为止，因此永远不可能直接访问外部函数的这两个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()()); <span class="comment">//"My Object"</span></span><br></pre></td></tr></table></figure><p>在匿名函数中我们把<code>this</code>对象赋值给了一个名叫<code>that</code>的变量。而在定义了闭包之后，闭包也可以访问这个变量。即使函数返回之后，<code>that</code>也仍然引用着<code>object</code>，所以调用之后返回了<code>My Object</code>。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href>Javascript高级程序编程第三版p178</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h2&gt;&lt;p&gt;通过函数表达式生成的函数为匿名函数，因为&lt;code&gt;function&lt;/code&gt;关键字后面没有标识符。匿名函数的&lt;code&gt;name&lt;/code&gt;属性是空字符串。&lt;br&gt;通过函数表达式生成的函数不会变量提升，但是通过函数声明的函数会变量提升，即可以在使用后声明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;arguments.callee&lt;/code&gt;是一个指向正在执行的函数的指针。可以在递归中使用&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
      <category term="closure" scheme="http://happylg.cn/tags/closure/"/>
    
      <category term="闭包" scheme="http://happylg.cn/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>Web安全总结(前端)</title>
    <link href="http://happylg.cn/2017/09/14/web-security/"/>
    <id>http://happylg.cn/2017/09/14/web-security/</id>
    <published>2017-09-14T00:30:29.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>参见我的博客<a href="http://happylg.cn/2017/08/05/http/#HTTPS">HTTPS</a></p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><p>CSRF(Cross Site Request Forgery, 跨站请求伪造)</p><p>A(黑客网站) –&gt; 发起用户不知情的请求(附带浏览器中的token信息) –&gt; B(银行网站)</p><h3 id="防御策略"><a href="#防御策略" class="headerlink" title="防御策略"></a>防御策略</h3><ol><li>Referrer</li><li>token(url, 请求体)</li><li>自定义请求头部</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;&lt;/a&gt;HTTPS&lt;/h2&gt;&lt;p&gt;参见我的博客&lt;a href=&quot;http://happylg.cn/2017/08/05/http/#HTTPS&quot;&gt;H
      
    
    </summary>
    
      <category term="前端" scheme="http://happylg.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="HTTPS" scheme="http://happylg.cn/tags/HTTPS/"/>
    
      <category term="XSS" scheme="http://happylg.cn/tags/XSS/"/>
    
      <category term="CSRF" scheme="http://happylg.cn/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>Web应用客户端存储</title>
    <link href="http://happylg.cn/2017/09/05/client-storage/"/>
    <id>http://happylg.cn/2017/09/05/client-storage/</id>
    <published>2017-09-05T12:08:22.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<hr><p>2017-09-06更新： 简要叙述客户端存储，indexdDB未完成</p><hr><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>客户端用于存储会话信息， cookie 是一小块可以客户端设置也可以在服务器端设置<br>的信息，每次发起请求时都会传送它。</p><p>在 JavaScript 中通过<code>document.cookie</code>可以访问 cookie。<br>cookie 的限制使其可以存储少量数据，然而对于大量数据效率很低。</p><p>HTTP请求头：<code>Cookie: name=value</code><br>HTTP响应头：<code>Set-Cookie: name=value</code></p><a id="more"></a><h3 id="cookie构成"><a href="#cookie构成" class="headerlink" title="cookie构成"></a>cookie构成</h3><p><code>name=value;</code><br><code>expires=expiration_time;</code><br><code>path=domain.path;</code><br><code>domain=domain.name;</code><br><code>secure</code></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>浏览器中对于 cookie 的尺寸也有限制。大多数浏览器都有大约 4096B（加减 1）的长度限制。为了最佳的浏览器兼容性，最好将整个 cookie 长度限制在 4095B（含 4095）以内。尺寸限制影响到一个域下所有的 cookie，而并非每个 cookie 单独限制。</p><p>由于所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能。cookie 信息越大，完成对服务器请求的时间也就越长。尽管浏览器对 cookie 进行了大小限制，不过最好还是尽可能在 cookie 中少存储信息，以避免影响性能。</p><p>一定不要在 cookie 中存储重要和敏感的数据。 cookie 数据并非存储在一个安全环境中，其中包含的任何数据都可以被他人访问。</p><h2 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h2><p>提供一种在cookie之外存储会话数据的途径<br>提供一种存储大量可以跨会话存在的数据的机制</p><h3 id="Storage类型"><a href="#Storage类型" class="headerlink" title="Storage类型"></a>Storage类型</h3><p>Storage对象方法:<br><code>clear()</code><br><code>getItem(name)</code><br><code>key(index)</code><br><code>removeItem(name)</code><br><code>setItem(name,value)</code></p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>浏览器关闭删除<br>跨页面刷新而存在<br>用于在一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除</p><h3 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h3><p>数据保留到Javascript删除或者用户清除浏览器缓存<br>要访问同一个localStorage对象，页面必须同源(协议+域名+端口)(子域名无效)<br>跨会话持久化数据并遵循跨域安全策略</p><h3 id="限制-1"><a href="#限制-1" class="headerlink" title="限制"></a>限制</h3><p>对于 localStorage 而言，大多数桌面浏览器会设置每个来源 5MB 的限制。 Chrome 和 Safari 对每个来源的限制是 2.5MB。而 iOS 版 Safari 和 Android 版 WebKit 的限制也是 2.5MB。</p><p>对 sessionStorage 的限制也是因浏览器而异。有的浏览器对 sessionStorage 的大小没有限制，但 Chrome、Safari、 iOS 版 Safari 和 Android 版 WebKit 都有限制，也都是 2.5MB。 IE8+和 Opera 对sessionStorage 的限制是 5MB。</p><h2 id="IndexdDB"><a href="#IndexdDB" class="headerlink" title="IndexdDB"></a>IndexdDB</h2><p>用对象保存数据而不是表保存数据<br>异步操作：<code>onerror()</code>,<code>onsuccess()</code></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>创建对象存储空间时，需要定义一个键，然后就可以添加数据。<br><code>var store = db.createObjectStore(&quot;users&quot;, { keyPath: &quot;username&quot; });</code><br><code>keyPath</code>即为键，而且必须全局唯一。</p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p><code>add( obj )</code>,添加已有键，报错；插入新值<br><code>put( obj )</code>,添加已有键，重写原来对象；更新对象</p><h3 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h3><p>跨过创建对象存储空间这一步之后，接下来的所有操作都是通过事务来完成的。在数据库对象上调用<code>transaction()</code>方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction(arr,IDBTransaction);</span><br></pre></td></tr></table></figure><p>arr表示存储空间的数组或对象。<br>用 IDBTransaction 接口定义的如下常量表示： <code>READ_ONLY</code>(0)表示只读， <code>READ_WRITE</code>(1)表示读写，<code>VERSION_CHANGE</code>(2)表示改变。<br>然后可以使用<code>add()</code>和<code>put()</code>方法，使用<code>get()</code>可以取得值，使用<code>delete()</code>可以删除对象， 而使用<code>clear()</code>则可以删除所有对象。<code>get()</code>和<code>delete()</code>方法都接收一个对象键作为参数，而所有这 5 个方法都会返回一个新的请求对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transaction = db.transaction(<span class="string">"users"</span>, IDBTransaction.READ_WRITE);</span><br><span class="line"><span class="keyword">var</span> request = db.transaction(<span class="string">"users"</span>).objectStore(<span class="string">"users"</span>).get(<span class="string">"007"</span>);</span><br></pre></td></tr></table></figure><h3 id="游标查询"><a href="#游标查询" class="headerlink" title="游标查询"></a>游标查询</h3><p>可以使用游标在对象存储空间中查询特定的对象。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。<br>在对象存储空间上调用<code>openCursor()</code>方法可以创建游标。与 IndexedDB 中的其他操作一样，<code>openCursor()</code>方法返回的是一个请求对象，因此必须为该对象指定<code>onsuccess</code>和<code>onerror</code>事件处理程序。<br>在 onsuccess 事件处理程序执行时，可以通过<code>event.target.result</code>取得存储空间中的下一个对象。在结果集中有下一项时，这个属性中保存一个 IDBCursor 的实例，在没有下一项时，这个属性的值为<code>null</code>。<br>IDBCursor 的实例有以下几个属性。<br><code>direction</code>：数值，表示游标移动的方向。</p><ul><li>默认值为<code>IDBCursor.NEXT(0)</code>，表示下一项;</li><li><code>IDBCursor.NEXT_NO_DUPLICATE(1)</code>表示下一个不重复的项;</li><li><code>DBCursor.PREV</code>(2)表示前一项;</li><li><code>IDBCursor.PREV_NO_DUPLICATE</code>(4)表示前一个不重复的项。</li></ul><p><code>key</code>：对象的键。<br><code>value</code>：实际的对象。<br><code>primaryKey</code>：游标使用的键。可能是对象键，也可能是索引键（稍后讨论索引键）。</p><p>检索：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cursor = event.target.result;</span><br><span class="line">    <span class="keyword">if</span> (cursor)&#123; <span class="comment">//必须要检查</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Key: "</span> + cursor.key + <span class="string">", Value: "</span> +</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(cursor.value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请记住，这个例子中的<code>cursor.value</code>是一个对象，这也是为什么在显示它之前先将它转换成 JSON字符串的原因</p><h3 id="键范围"><a href="#键范围" class="headerlink" title="键范围"></a>键范围</h3><p>键范围（key range）为使用游标增添了一些灵活性。键范围由 IDBKeyRange 的实例表示。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是为了提高查询速度而基于特定的属性创建的。</p><h3 id="设定游标方向"><a href="#设定游标方向" class="headerlink" title="设定游标方向"></a>设定游标方向</h3><h3 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h3>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;2017-09-06更新： 简要叙述客户端存储，indexdDB未完成&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;Cookie&quot;&gt;&lt;a href=&quot;#Cookie&quot; class=&quot;headerlink&quot; title=&quot;Cookie&quot;&gt;&lt;/a&gt;Cookie&lt;/h2&gt;&lt;p&gt;客户端用于存储会话信息， cookie 是一小块可以客户端设置也可以在服务器端设置&lt;br&gt;的信息，每次发起请求时都会传送它。&lt;/p&gt;
&lt;p&gt;在 JavaScript 中通过&lt;code&gt;document.cookie&lt;/code&gt;可以访问 cookie。&lt;br&gt;cookie 的限制使其可以存储少量数据，然而对于大量数据效率很低。&lt;/p&gt;
&lt;p&gt;HTTP请求头：&lt;code&gt;Cookie: name=value&lt;/code&gt;&lt;br&gt;HTTP响应头：&lt;code&gt;Set-Cookie: name=value&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://happylg.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="数据存储" scheme="http://happylg.cn/tags/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/"/>
    
      <category term="客户端存储" scheme="http://happylg.cn/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AD%98%E5%82%A8/"/>
    
      <category term="Cookie" scheme="http://happylg.cn/tags/Cookie/"/>
    
      <category term="localStorage" scheme="http://happylg.cn/tags/localStorage/"/>
    
      <category term="sessionStorage" scheme="http://happylg.cn/tags/sessionStorage/"/>
    
  </entry>
  
  <entry>
    <title>Web缓存总结</title>
    <link href="http://happylg.cn/2017/09/04/http-cache/"/>
    <id>http://happylg.cn/2017/09/04/http-cache/</id>
    <published>2017-09-04T06:03:23.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么使用Web缓存"><a href="#为什么使用Web缓存" class="headerlink" title="为什么使用Web缓存"></a>为什么使用Web缓存</h2><ol><li>减少网络带宽消耗</li><li>降低服务器压力</li><li>减少网络延迟，加快页面打开速度</li></ol><h2 id="Web缓存类型"><a href="#Web缓存类型" class="headerlink" title="Web缓存类型"></a>Web缓存类型</h2><h3 id="数据库数据缓存"><a href="#数据库数据缓存" class="headerlink" title="数据库数据缓存"></a>数据库数据缓存</h3><p>Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。<br><a id="more"></a></p><h3 id="服务器端缓存"><a href="#服务器端缓存" class="headerlink" title="服务器端缓存"></a>服务器端缓存</h3><h4 id="代理服务器缓存"><a href="#代理服务器缓存" class="headerlink" title="代理服务器缓存"></a>代理服务器缓存</h4><p>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。</p><h4 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h4><p>CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><h3 id="浏览器端缓存"><a href="#浏览器端缓存" class="headerlink" title="浏览器端缓存"></a>浏览器端缓存</h3><p>浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。</p><h3 id="Web应用层缓存"><a href="#Web应用层缓存" class="headerlink" title="Web应用层缓存"></a>Web应用层缓存</h3><p>应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。</p><h2 id="浏览器缓存规则"><a href="#浏览器缓存规则" class="headerlink" title="浏览器缓存规则"></a>浏览器缓存规则</h2><p>对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的<code>Meta</code>标签中定义的。</p><h3 id="不能使用缓存"><a href="#不能使用缓存" class="headerlink" title="不能使用缓存"></a>不能使用缓存</h3><p>定义任何时候都不使用缓存，返回的响应码为200。</p><p>http头部：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br></pre></td></tr></table></figure><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>定义使用缓存，在缓存未过期之前，或未定义强制进行服务器校验，使用浏览器中的保存的缓存，返回的响应码为200。</p><p>HTTP头部：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: max-age: XXX   // 缓存可以使用XXX秒</span><br><span class="line"><span class="attribute">Expires</span>: XXX                  // 缓存可以使用到XXX(日期)</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache       // 定义强制进行服务器校验</span><br><span class="line"><span class="attribute">Pragma</span>: no-cache             //  定义强制进行服务器校验(HTTP/1.0 中规定的通用首部)</span><br></pre></td></tr></table></figure><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>进行服务器校验时，发现缓存文件未发生改变，使用浏览器中的缓存，返回的响应码为304。</p><p>HTTP头部：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Last-Modified</span>: XXX        // 文件最后修改时间</span><br><span class="line"><span class="attribute">Etag</span>: XXX                 // 文件对应的唯一标识符（md5标志）</span><br></pre></td></tr></table></figure><h3 id="从服务器获取资源"><a href="#从服务器获取资源" class="headerlink" title="从服务器获取资源"></a>从服务器获取资源</h3><p>进行服务器校验时，发现缓存文件已发生改变，使用服务器返回数据，返回的响应码为200。</p><h2 id="http首部字段"><a href="#http首部字段" class="headerlink" title="http首部字段"></a>http首部字段</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h4><p>通用首部字段：请求报文和响应报文均能使用</p><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control</td><td style="text-align:center">控制缓存行为</td></tr><tr><td style="text-align:center">Pragma</td><td style="text-align:center">HTTP1.0遗留，值为“no-cache”禁止缓存</td></tr></tbody></table><h4 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h4><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">if-Match</td><td style="text-align:center">比较ETag是否一致</td></tr><tr><td style="text-align:center">if-None-Match</td><td style="text-align:center">比较ETag是否不一致</td></tr><tr><td style="text-align:center">if-Modified-Since</td><td style="text-align:center">比较最后资源更新的时间是否一致</td></tr><tr><td style="text-align:center">if-Unmodified-Since</td><td style="text-align:center">比较最后资源更新的时间是否不一致</td></tr></tbody></table><h4 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h4><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">ETag</td><td style="text-align:center">资源的匹配信息</td></tr></tbody></table><h4 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h4><table><thead><tr><th style="text-align:center">字段名称</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">Expires</td><td style="text-align:center">HTTP1.0遗留，实体主体开始时间</td></tr><tr><td style="text-align:center">Last-Modified</td><td style="text-align:center">资源最后一次修改时间</td></tr></tbody></table><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p><strong>“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题</strong>，http1.1新增了<code>Cache-Control</code>来定义缓存过期时间，若报文中同时出现了<code>Pragma</code>、<code>Expires</code> 和<code>Cache-Control</code>，会以<code>Cache-Control</code>为准。</p><h4 id="Cache-Control请求指令表"><a href="#Cache-Control请求指令表" class="headerlink" title="Cache-Control请求指令表"></a>Cache-Control请求指令表</h4><table><thead><tr><th style="text-align:center">参数</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">Cache-Control: max-age=seconds</td><td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td></tr><tr><td style="text-align:center">Cache-Control: max-stale[=seconds]</td><td>表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间 (单位秒)，表示响应不能超过的过时时间。</td></tr><tr><td style="text-align:center">Cache-Control: min-fresh=seconds</td><td>表示客户端希望在指定的时间内获取最新的响应。</td></tr><tr><td style="text-align:center">Cache-control: no-cache</td><td>强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器</td></tr><tr><td style="text-align:center">Cache-control: no-store</td><td>缓存不应存储有关客户端请求或服务器响应的任何内容。</td></tr><tr><td style="text-align:center">Cache-control: no-transform</td><td>不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改。</td></tr><tr><td style="text-align:center">Cache-control: only-if-cached</td><td>表明如果缓存存在，只使用缓存，无论原始服务器数据是否有更新。</td></tr></tbody></table><h4 id="Cache-Control响应指令表"><a href="#Cache-Control响应指令表" class="headerlink" title="Cache-Control响应指令表"></a>Cache-Control响应指令表</h4><table><thead><tr><th style="text-align:center">参数</th><th>意义</th></tr></thead><tbody><tr><td style="text-align:center">Cache-control: must-revalidate</td><td>缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源</td></tr><tr><td style="text-align:center">Cache-control: no-cache</td><td>强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器</td></tr><tr><td style="text-align:center">Cache-control: no-store</td><td>缓存不应存储有关客户端请求或服务器响应的任何内容</td></tr><tr><td style="text-align:center">Cache-control: no-transform</td><td>不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改</td></tr><tr><td style="text-align:center">Cache-control: public</td><td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存</td></tr><tr><td style="text-align:center">Cache-control: private</td><td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）</td></tr><tr><td style="text-align:center">Cache-control: proxy-revalidate</td><td>与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略</td></tr><tr><td style="text-align:center">Cache-Control: max-age=seconds</td><td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间</td></tr><tr><td style="text-align:center">Cache-control: s-maxage=seconds</td><td>覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-store</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache, no-store, must-revalidate</span><br></pre></td></tr></table></figure><p>缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br></pre></td></tr></table></figure><p>每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Cache-Control</span>: max-age=3600, must-revalidate</span><br></pre></td></tr></table></figure><p>它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。传递标记起来的最终修改时间的请求报文首部字段有：<code>If-Modified-Since</code>和<code>If-Unmodified-Since</code>。</p><h4 id="If-Modified-Since-Last-Modified-value"><a href="#If-Modified-Since-Last-Modified-value" class="headerlink" title="If-Modified-Since: Last-Modified-value"></a>If-Modified-Since: Last-Modified-value</h4><p>示例为<code>If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT</code><br>该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。<br>当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。</p><h4 id="If-Unmodified-Since-Last-Modified-value"><a href="#If-Unmodified-Since-Last-Modified-value" class="headerlink" title="If-Unmodified-Since: Last-Modified-value"></a>If-Unmodified-Since: Last-Modified-value</h4><p>告诉服务器，若<code>Last-Modified</code>没有匹配上（资源在服务端的最后更新时间改变了），则应当返回<code>412(Precondition Failed)</code>状态码给客户端。<br>当遇到下面情况时，<code>If-Unmodified-Since</code>字段会被忽略：</p><ol><li><code>Last-Modified</code>值对上了（资源在服务端没有新的修改）；</li><li>服务端需返回2XX和412之外的状态码；</li><li>传来的指定日期不合法</li></ol><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>为了解决上述<code>Last-Modified</code>可能存在的不准确的问题，Http1.1还推出了<code>ETag</code>实体首部字段。服务器会通过某种算法，给资源计算得出一个唯一标识符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上<code>ETag: 唯一标识符</code>一起返回给客户端。客户端会保留该<code>ETag</code>字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的<code>ETag</code>跟自己服务器上该资源的<code>ETag</code>是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现<code>ETag</code>匹配不上，那么直接以常规<code>GET</code>200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果<code>ETag</code>是一致的，则直接返回304知会客户端直接使用本地缓存即可。请求报文中有两个首部字段<code>If-None-Match</code>和<code>If-Match</code>可以带上<code>ETag</code>值。</p><h4 id="If-None-Match-ETag-value"><a href="#If-None-Match-ETag-value" class="headerlink" title="If-None-Match: ETag-value"></a>If-None-Match: ETag-value</h4><p>示例为<code>If-None-Match: &quot;56fcccc8-1699&quot;</code><br>告诉服务端如果<code>ETag</code>没匹配上需要重发资源数据，否则直接回送304和响应报头即可。<br>当前各浏览器均是使用的该请求首部来向服务器传递保存的<code>ETag</code>值。</p><h4 id="If-Match-ETag-value"><a href="#If-Match-ETag-value" class="headerlink" title="If-Match: ETag-value"></a>If-Match: ETag-value</h4><p>告诉服务器如果没有匹配到<code>ETag</code>，或者收到了“*”值而当前并没有该资源实体，则应当返回<code>412(Precondition Failed)</code>状态码给客户端。否则服务器直接忽略该字段。<code>If-Match</code>的一个应用场景是，客户端走<code>PUT</code>方法向服务端请求上传/更替资源，这时候可以通过<code>If-Match</code>传递资源的<code>ETag</code>。</p><p>如果<code>Last-Modified</code>和<code>ETag</code>同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。</p><h3 id="HTTP1-0缓存"><a href="#HTTP1-0缓存" class="headerlink" title="HTTP1.0缓存"></a>HTTP1.0缓存</h3><h4 id="Prama"><a href="#Prama" class="headerlink" title="Prama"></a>Prama</h4><p><code>Pragma</code>是HTTP/1.0标准中定义的一个<code>header</code>属性，请求中包含<code>Pragma</code>的效果跟在头信息中定义<code>Cache-Control: no-cache</code>相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的<code>Cache-control</code>头。通常定义<code>Pragma</code>以向后兼容基于HTTP/1.0的客户端。<br>当该字段值为<code>no-cache</code>的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。</p><p><code>Pragma</code>属于通用首部字段，在客户端上使用时，常规要求我们往html上加上这段meta元标签（而且可能还得做些hack放到body后面去）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它告诉浏览器每次请求页面时都不要读缓存，都得往服务器发一次请求才行。 事实上这种禁用缓存的形式用处很有限：</p><ol><li>仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别<code>Cache-Control: no-store</code>的meta标签（见出处）。</li><li>在IE中识别到该meta标签含义，并不一定会在请求字段加上<code>Pragma</code>，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。</li></ol><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>有了<code>Pragma</code>来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，<code>Expires</code>就是做这件事的首部字段。<br><code>Expires</code>的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2017 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。<br>在客户端我们同样可以使用meta标签来知会IE（也仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"mon, 18 apr 2016 14:30:00 GMT"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把<code>content</code>里的值写为“-1”或“0”。注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。</p><p>通过<code>Pragma</code>禁用缓存，又给<code>Expires</code>定义一个还未到期的时间，刷新页面时发现均发起了新请求，<code>Pragma</code>字段的优先级会更高。</p><h2 id="离线应用"><a href="#离线应用" class="headerlink" title="离线应用"></a>离线应用</h2><h3 id="离线应用之AppCache"><a href="#离线应用之AppCache" class="headerlink" title="离线应用之AppCache"></a>离线应用之AppCache</h3><p><strong>已废弃，使用Service Workers代替</strong><br>HTML5 提供一种应用程序缓存机制，使得基于web的应用程序可以离线运行。开发者可以使用 Application Cache (AppCache) 接口设定浏览器应该缓存的资源并使得离线用户可用。 在处于离线状态时，即使用户点击刷新按钮，应用也能正常加载与工作。</p><h4 id="启用应用缓存"><a href="#启用应用缓存" class="headerlink" title="启用应用缓存"></a>启用应用缓存</h4><p>服务端：<br>在服务器上添加MIME TYPE支，让服务器能够识别manifest后缀的文件,<code>AddType text/cache-manifest manifest</code></p><p>前端页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">manifest</span>=<span class="string">"example.appcache"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>manifest 特性与 缓存清单(cache manifest) 文件关联，这个文件包含了浏览器需要为你的应用程序缓存的资源(文件)列表。你应当在每一个意图缓存的页面上添加 manifest 特性。浏览器不会缓存不带有manifest 特性的页面，除非这个页面已经被写在清单文件内的列表里了。你没有必要添加所有你意图缓存的页面的清单文件，浏览器会暗中将用户访问过的并带有 manifest 特性的所有页面添加进应用缓存中。</p><h4 id="缓存清单"><a href="#缓存清单" class="headerlink" title="缓存清单"></a>缓存清单</h4><p>缓存清单文件中的段落： CACHE， NETWORK，与 FALLBACK</p><p>CACHE:<br>这是缓存文件中记录所属的默认段落。在 CACHE: 段落标题后(或直接跟在 CACHE MANIFEST 行后)列出的文件会在它们第一次下载完毕后缓存起来。</p><p>NETWORK:<br>在 NETWORK: 段落标题下列出的文件是需要与服务器连接的白名单资源。所有类似资源的请求都会绕过缓存，即使用户处于离线状态。可以使用通配符。</p><p>FALLBACK:<br>FALLBACK: 段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。</p><p>CACHE， NETWORK， 和 FALLBACK 段落可以以任意顺序出现在缓存清单文件中，并且每个段落可以在同一清单文件中出现多次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># v1 2011-08-14</span><br><span class="line"># This is another comment</span><br><span class="line">index.html</span><br><span class="line">cache.html</span><br><span class="line">style.css</span><br><span class="line">image1.png</span><br><span class="line"></span><br><span class="line"># Use from network if available</span><br><span class="line">NETWORK:</span><br><span class="line">network.html</span><br><span class="line"></span><br><span class="line"># Fallback content</span><br><span class="line">FALLBACK:</span><br><span class="line">/ fallback.html</span><br></pre></td></tr></table></figure><h4 id="加载文档"><a href="#加载文档" class="headerlink" title="加载文档"></a>加载文档</h4><p>使用AppCache文档加载流程：</p><ul><li>如果应用缓存存在，浏览器直接从缓存中加载文档与相关资源，不会访问网络。这会提升文档加载速度。</li><li>浏览器检查清单文件列出的资源是否在服务器上被修改。</li><li>如果清单文件被更新了, 浏览器会下载新的清单文件和相关的资源。 这都是在后台执行的，基本不会影响到webapp的性能。</li></ul><h4 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h4><p>缓存文件更新控制不灵活:就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。</p><h3 id="离线应用之Service-Workers"><a href="#离线应用之Service-Workers" class="headerlink" title="离线应用之Service Workers"></a>离线应用之Service Workers</h3><p>AppCache — 看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是它假定你使用时会遵循诸多规则，如果你不严格遵循这些规则，会出现很大的问题。客户端和服务器之间加入一个Service Workers，主要是为了实现离线处理和消息推送等，让web app可以和native app开始真正意义上的竞争。</p><h4 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h4><p>1、非主线程<br>平常浏览器窗口中跑的页面运行的是主JavaScript线程，DOM和window全局变量都是可以访问的。而Service Worker是走的另外的线程，可以理解为在浏览器背后默默运行的一个线程，脱离浏览器窗体，因此，window以及DOM都是不能访问的，此时我们可以使用self访问全局上下文</p><p>2、异步<br>Service Worker设计为完全异步，同步API（如XHR和localStorage）不能在Service Worker中使用。Service workers大量使用Promise，因为通常它们会等待响应后继续，并根据响应返回一个成功或者失败的操作，这些场景非常适合Promise</p><p>3、https协议<br>Service Worker对协议也有要求，必须是https协议的</p><h4 id="Service-Worker生命周期"><a href="#Service-Worker生命周期" class="headerlink" title="Service Worker生命周期"></a>Service Worker生命周期</h4><ol><li>Download – 下载注册的JS文件</li><li>Install – 安装</li><li>Activate – 激活</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">/* 安装后... */</span> &#125;);</span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">/* 激活后... */</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//响应和拦截各种请求</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">/* 请求后... */</span> &#125;);</span><br></pre></td></tr></table></figure><p>目前Service Worker的所有应用都是基于上面3个事件的，例如离线开发中，<code>install</code>用来缓存文件，<code>activate</code>用来缓存更新，<code>fetch</code>用来拦截请求直接返回缓存数据。三者构成了完整的缓存控制结构。</p><h4 id="Cache和CacheStorage"><a href="#Cache和CacheStorage" class="headerlink" title="Cache和CacheStorage"></a>Cache和CacheStorage</h4><p><code>Cache</code>直接和请求打交道，<code>CacheStorage</code>和<code>Cache</code>对象打交道，可以直接使用全局的<code>caches</code>属性访问<code>CacheStorage</code>。<br><code>Cache</code>和<code>CacheStorage</code>的出现让浏览器的缓存类型又多了一个：之前有memoryCache和diskCache，现在又多了个ServiceWorker cache。参见<a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener">具体API</a></p><h4 id="借助Service-Worker和cacheStorage离线开发"><a href="#借助Service-Worker和cacheStorage离线开发" class="headerlink" title="借助Service Worker和cacheStorage离线开发"></a>借助Service Worker和cacheStorage离线开发</h4><p>1.在页面上注册一个Service Worker，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'./cache.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.将<code>cache.js</code>这个JS中复制如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> VERSION = <span class="string">'v1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//把cache.addAll()方法中缓存文件数组换成你希望缓存的文件数组。</span></span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">'./start.html'</span>,</span><br><span class="line">        <span class="string">'./static/jquery.min.js'</span>,</span><br><span class="line">        <span class="string">'./static/mm.jpg'</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存更新</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.waitUntil(</span><br><span class="line">    caches.keys().then(<span class="function"><span class="keyword">function</span>(<span class="params">cacheNames</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">        cacheNames.map(<span class="function"><span class="keyword">function</span>(<span class="params">cacheName</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 如果当前版本和缓存版本不一致</span></span><br><span class="line">          <span class="keyword">if</span> (cacheName !== VERSION) &#123;</span><br><span class="line">            <span class="keyword">return</span> caches.delete(cacheName);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获请求并返回缓存数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(caches.match(event.request).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fetch(event.request);</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    caches.open(VERSION).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      cache.put(event.request, response);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> response.clone();</span><br><span class="line">  &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> caches.match(<span class="string">'./static/mm.jpg'</span>);</span><br><span class="line">  &#125;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.alloyteam.com/2012/03/web-cache-1-web-cache-overview/" target="_blank" rel="noopener">【Web缓存机制系列】1 – Web缓存的作用与类型</a></li><li><a href="http://www.alloyteam.com/2012/03/web-cache-2-browser-cache/" target="_blank" rel="noopener">【Web缓存机制系列】2 – Web缓存的作用与类型</a></li><li><a href="http://www.cnblogs.com/vajoy/p/5341664.html" target="_blank" rel="noopener">浅谈浏览器http的缓存机制</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">Cache-Control</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP缓存</a></li><li><a href="http://www.alloyteam.com/2012/03/web-cache-4-html5-web-cache/" target="_blank" rel="noopener">【Web缓存机制系列】4 – Web缓存的作用与类型</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Using_the_application_cache" target="_blank" rel="noopener">使用应用缓存</a></li><li><a href="http://www.zhangxinxu.com/wordpress/2017/07/service-worker-cachestorage-offline-develop/" target="_blank" rel="noopener">借助Service Worker和cacheStorage缓存及离线开发</a></li><li>Javascript高级程序编程 第三版</li><li><a href="https://www.cnblogs.com/lyzg/p/5125934.html" target="_blank" rel="noopener">浏览器缓存知识小结及应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么使用Web缓存&quot;&gt;&lt;a href=&quot;#为什么使用Web缓存&quot; class=&quot;headerlink&quot; title=&quot;为什么使用Web缓存&quot;&gt;&lt;/a&gt;为什么使用Web缓存&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;减少网络带宽消耗&lt;/li&gt;
&lt;li&gt;降低服务器压力&lt;/li&gt;
&lt;li&gt;减少网络延迟，加快页面打开速度&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;Web缓存类型&quot;&gt;&lt;a href=&quot;#Web缓存类型&quot; class=&quot;headerlink&quot; title=&quot;Web缓存类型&quot;&gt;&lt;/a&gt;Web缓存类型&lt;/h2&gt;&lt;h3 id=&quot;数据库数据缓存&quot;&gt;&lt;a href=&quot;#数据库数据缓存&quot; class=&quot;headerlink&quot; title=&quot;数据库数据缓存&quot;&gt;&lt;/a&gt;数据库数据缓存&lt;/h3&gt;&lt;p&gt;Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://happylg.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="http" scheme="http://happylg.cn/tags/http/"/>
    
      <category term="缓存" scheme="http://happylg.cn/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="离线应用" scheme="http://happylg.cn/tags/%E7%A6%BB%E7%BA%BF%E5%BA%94%E7%94%A8/"/>
    
      <category term="前端优化" scheme="http://happylg.cn/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>浏览器渲染原理总结</title>
    <link href="http://happylg.cn/2017/09/04/how-browers-work/"/>
    <id>http://happylg.cn/2017/09/04/how-browers-work/</id>
    <published>2017-09-04T05:33:36.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器主要部件"><a href="#浏览器主要部件" class="headerlink" title="浏览器主要部件"></a>浏览器主要部件</h2><p>浏览器主要部件图：<br><img src="/img/浏览器组件.png" alt="浏览器主要部件图"><br>User Interface<br>用户接口。浏览器中的地址栏、前进后退、书签菜单等。除了网页显示区域以外的都是。<br>Brower engine<br>浏览器引擎。查询与操作渲染引擎的接口。<br>Rendering engine<br>渲染引擎。负责显示请求的内容<br>Data Persistence<br>持久层。HTML5规定了完整的浏览器中的数据库：web database<br>Networking<br>网络。用于网络请求，例如HTTP请求。<br>JavaScript Interpreter<br>用于解析执行JavaScript代码<br>UI Backend<br>绘制基础原件，比如组合框、窗口。<br><a id="more"></a></p><h2 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h2><p>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。</p><p>渲染主流程图：<br><img src="/img/渲染主流程图.png" alt="渲染主流程图.png"><br>解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树</p><p>Webkit内核渲染图：<br><img src="/img/Webkit内核渲染.png" alt="Webkit内核渲染"></p><p>Gecko内核渲染图：<br><img src="/img/Gecko内核渲染.jpg" alt="Gecko内核渲染"></p><p>尽管webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，webkit则使用render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂。</p><p>分析上图可知浏览器的渲染页面分为以下几个步骤：<br>(1) 解析</p><ol><li>HTML/SVG/XHTML，事实上Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。</li><li>CSS，解析CSS会产生CSS Rule Tree。</li><li>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree。</li></ol><p>(2) 渲染<br>解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。<br>注意：Rendering Tree 渲染树并不等同于DOM树，因为一些像<code>head</code>元素或<code>display:none</code>的东西就没必要放在渲染树中了。CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element，也就是DOM结点，即所谓的Frame。然后计算每个Frame（也就是每个Element）的位置，这又叫layout和<code>reflow</code>过程。</p><p>(3) 绘制<br>最后通过调用操作系统Native GUI的API绘制。</p><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>HTML解析流程图：<br><img src="/img/HTML解析流程.png" alt="HTML解析流程"><br>解析由两部分组成：分词+构建树。<br>分词是词法分析，把输入解析成符号序列。构建树的过程就是在不断处理分词器完成的节点。除了把元素添加到DOM树上，还会将其添加到一个开放元素堆栈，用于纠正嵌套错误和标签未关闭错误。<br>但其实浏览器比我们想象的更强大更包容。浏览器的错误处理相当统一，虽然这不是当前HTML规范的一部分。当很多格式不良的HTML文档出现在很多网站，浏览器会尝试用和其他浏览器一样的方式修复错误。</p><p>DOM树构建图：<br><img src="/img/DOM树构建.png" alt="DOM树构建"><br>输出的树，也就是解析树，是由DOM元素及属性节点组成的。DOM和标签基本是一一对应的关系。</p><p>CSS树构建图：<br><img src="/img/css解析树.png" alt="CSS解析"></p><h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>渲染基本流程：</p><ol><li>计算CSS样式</li><li>构建Render Tree</li><li>Layout – 定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性 ……</li><li>正式开画</li></ol><p><img src="/img/渲染基本流程.jpg" alt="渲染基本流程"><br>注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属会导致重新Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的CSS rule没有被匹配到，等。这里重要要说两个概念，一个是<code>reflow</code>，另一个是<code>repaint</code>。</p><h3 id="渲染树与DOM树的关系"><a href="#渲染树与DOM树的关系" class="headerlink" title="渲染树与DOM树的关系"></a>渲染树与DOM树的关系</h3><p>渲染树与对应DOM树图：<br><img src="/img/渲染树与对应DOM树.png" alt="渲染树与对应DOM树"><br>渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，例如<code>head</code>元素。另外，<code>display</code>属性为<code>none</code>的元素也不会在渲染树中出现（<code>visibility</code>属性为<code>hidden</code>的元素将出现在渲染树中）。</p><p>还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如，<code>select</code>元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的html，根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。</p><p>一些渲染对象和所对应的Dom节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。</p><h2 id="重绘和重排"><a href="#重绘和重排" class="headerlink" title="重绘和重排"></a>重绘和重排</h2><p>当用户与网页交互，或者脚本程序改动修改网页时，前文提到的一些操作将会重复执行，因为网页的内在结构已经发生了改变，即发生重排或重绘。</p><h3 id="重绘-repaint"><a href="#重绘-repaint" class="headerlink" title="重绘(repaint)"></a>重绘(<code>repaint</code>)</h3><p>屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。当改变那些不会影响元素在网页中的位置的元素样式时，譬如<code>background-color</code>(背景色)， <code>border-color</code>(边框色)， <code>visibility</code>(可见性)，浏览器只会用新的样式将元素<code>repaint</code>一次(这就是<code>repaint</code>，或者说重新构造样式)。</p><h3 id="重排-reflow-relayout"><a href="#重排-reflow-relayout" class="headerlink" title="重排(reflow/relayout)"></a>重排(<code>reflow</code>/<code>relayout</code>)</h3><p>当改变影响到文本内容或结构，或者元素位置时，<code>reflow</code>或者说重新布局就会发生。<code>reflow</code>意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是<code>reflow</code>，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫<code>reflow</code>）<code>reflow</code> 会从<code>&lt;html&gt;</code>这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在<code>reflow</code>过程中，可能会增加一些<code>frame</code>，比如一个文本字符串必需被包装起来。</p><p>这些改变通常由以下事件触发：</p><ul><li>DOM操作(元素添加，删除，修改，或者元素顺序的改变);</li><li>内容变化，包括表单域内的文本改变;</li><li>CSS属性的计算或改变(改变元素尺寸、位置);</li><li>添加或删除样式表(改变元素尺寸、位置);</li><li>更改<code>&#39;class&#39;</code>的属性(改变元素尺寸、位置);</li><li>动画效果进行计算和改变 CSS 属性值(改变元素尺寸、位置);</li><li>浏览器窗口的操作(缩放，滚动);</li><li>当你修改网页的默认字体时。</li><li>伪类激活(<code>:hover</code>)。</li></ul><p><code>reflow</code>的成本比<code>repaint</code>的成本高得多的多。DOM Tree里的每个结点都会有<code>reflow</code>方法，一个结点的<code>reflow</code>很有可能导致子结点，甚至父点以及同级结点的<code>reflow</code>。在一些高性能的电脑上也许还没什么，但是如果<code>reflow</code>发生在手机上，那么这个过程是非常痛苦和耗电的。</p><p>当然，浏览器不会像上面那样，每改一次样式就 <code>reflow</code> 或 <code>repaint</code> 一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次 <code>reflow</code> ，这又叫<strong>异步 <code>reflow</code> 或增量异步 <code>reflow</code></strong> 。但是有些情况浏览器是不会这么做的，比如：<code>resize</code>窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 <code>reflow</code>。</p><h3 id="浏览器渲染优化"><a href="#浏览器渲染优化" class="headerlink" title="浏览器渲染优化"></a>浏览器渲染优化</h3><ol><li>创建有效的 HTML 和 CSS ，不要忘记指定文档编码，比如<code>&lt;meta charset=&quot;utf-8&quot;&gt;</code>。</li><li>CSS 样式应该包含在<code>&lt;head&gt;</code>中， Javascript 脚本出现在<code>&lt;body&gt;</code>末尾。</li><li>减少 CSS 嵌套层级和选择适当的选择器，可参考 如何提升 CSS 选择器性能。</li><li>不要通过 Javascript 逐条修改 DOM 的样式，提前定义好 CSS 的<code>class</code>进行操作。</li><li>尽量减少将 DOM 节点属性值放在循环当中，会导致大量读写此属性值。</li><li>尽可能的为产生动画的 HTML 元素使用<code>fixed</code>或<code>absolute</code>的<code>position</code>，那么修改他们的 CSS 是不会 <code>reflow</code> 的。<br>注：<code>display:none</code>会触发<code>reflow</code>，而<code>visibility:hidden</code>只会触发<code>repaint</code>，因为没有发现位置变化。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://taligarsiel.com/Projects/howbrowserswork1.htm" target="_blank" rel="noopener">How browsers work</a></li><li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" target="_blank" rel="noopener">How browsers work 译文</a></li><li><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">浏览器的渲染原理简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浏览器主要部件&quot;&gt;&lt;a href=&quot;#浏览器主要部件&quot; class=&quot;headerlink&quot; title=&quot;浏览器主要部件&quot;&gt;&lt;/a&gt;浏览器主要部件&lt;/h2&gt;&lt;p&gt;浏览器主要部件图：&lt;br&gt;&lt;img src=&quot;/img/浏览器组件.png&quot; alt=&quot;浏览器主要部件图&quot;&gt;&lt;br&gt;User Interface&lt;br&gt;用户接口。浏览器中的地址栏、前进后退、书签菜单等。除了网页显示区域以外的都是。&lt;br&gt;Brower engine&lt;br&gt;浏览器引擎。查询与操作渲染引擎的接口。&lt;br&gt;Rendering engine&lt;br&gt;渲染引擎。负责显示请求的内容&lt;br&gt;Data Persistence&lt;br&gt;持久层。HTML5规定了完整的浏览器中的数据库：web database&lt;br&gt;Networking&lt;br&gt;网络。用于网络请求，例如HTTP请求。&lt;br&gt;JavaScript Interpreter&lt;br&gt;用于解析执行JavaScript代码&lt;br&gt;UI Backend&lt;br&gt;绘制基础原件，比如组合框、窗口。&lt;br&gt;
    
    </summary>
    
      <category term="前端" scheme="http://happylg.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="浏览器" scheme="http://happylg.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="渲染" scheme="http://happylg.cn/tags/%E6%B8%B2%E6%9F%93/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中this与对象原型</title>
    <link href="http://happylg.cn/2017/09/03/js-this-and-proto/"/>
    <id>http://happylg.cn/2017/09/03/js-this-and-proto/</id>
    <published>2017-09-03T13:39:45.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>参见我的博客<a href="http://happylg.cn/2017/08/05/js-scope/#this对象">this对象</a></p><h2 id="javascript对象"><a href="#javascript对象" class="headerlink" title="javascript对象"></a>javascript对象</h2><p>参见<a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch3.md" target="_blank" rel="noopener">你不懂JS: this 与对象原型–第三章：对象</a></p><p>JS 中的对象拥有字面形式（比如 <code>var a = { .. }</code>）和构造形式（比如 <code>var a = new Array(..)</code>）。字面形式几乎总是首选，但在某些情况下，构造形式提供更多的构建选项。</p><p>许多人声称“Javascript 中的一切都是对象”，这是不对的。对象是六种（或七中，看你从哪个方面说）基本类型之一。对象有子类型，包括 <code>function</code>，还可以被行为特化，比如 <code>[object Array]</code> 作为内部的标签表示子类型数组。<br><a id="more"></a><br>对象是键/值对的集合。通过 <code>.propName</code> 或 <code>[&quot;propName&quot;]</code> 语法，值可以作为属性访问。不管属性什么时候被访问，引擎实际上会调用内部默认的 <code>[[Get]]</code> 操作（在设置值时调用 <code>[[Put]]</code> 操作），它不仅直接在对象上查找属性，在没有找到时还会遍历 <code>[[Prototype]]</code> 链（见第五章）。</p><p>属性有一些可以通过属性描述符控制的特定性质，比如 <code>writable</code> 和 <code>configurable</code>。另外，对象拥有它的不可变性（它们的属性也有），可以通过使用 <code>Object.preventExtensions(..)</code>、<code>Object.seal(..)</code>、和 <code>Object.freeze(..)</code> 来控制几种不同等级的不可变性。</p><p>属性不必非要包含值 —— 它们也可以是带有<code>getter/setter</code>的“访问器属性”。它们也可以是可枚举或不可枚举的，这控制它们是否会在 <code>for..in</code> 这样的循环迭代中出现。</p><p>你也可以使用 ES6 的 <code>for..of</code> 语法，在数据结构（数组，对象等）中迭代 <strong>值</strong>，它寻找一个内建或自定义的 <code>@@iterator</code> 对象，这个对象由一个 <code>next()</code> 方法组成，通过这个 <code>next()</code> 方法每次迭代一个数据。</p><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类是一种设计模式。许多语言提供语法来启用自然而然的面向类的软件设计。JS 也有相似的语法，但是它的行为和你在其他语言中熟悉的工作原理 <strong>有很大的不同</strong>。</p><p><strong>类意味着拷贝。</strong>当一个传统的类被实例化时，就发生了类的行为向实例中拷贝。当类被继承时，也发生父类的行为向子类的拷贝。</p><p>多态（在继承链的不同层级上拥有同名的不同函数）也许看起来意味着一个从子类回到父类的相对引用链接，但是它仍然只是拷贝行为的结果。</p><p>JavaScript <strong>不会自动地</strong> （像类那样）在对象间创建拷贝。</p><p>mixin 模式常用于在 <em>某种程度上</em> 模拟类的拷贝行为，但是这通常导致像显式假想多态那样（<code>OtherObj.methodName.call(this, ...)</code>）难看而且脆弱的语法，这样的语法又常导致更难懂和更难维护的代码。</p><p>明确的 mixin 和类 <em>拷贝</em> 又不完全相同，因为对象（和函数！）仅仅是共享的引用被复制，不是对象/函数自身被复制。不注意这样的微小之处通常是各种陷阱的根源。</p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch3.md" target="_blank" rel="noopener">你不懂JS: this 与对象原型–第三章：对象</a></li><li><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch4.md" target="_blank" rel="noopener">你不懂JS: this 与对象原型–第四章: 混合（淆）“类”的对象</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this&quot;&gt;&lt;a href=&quot;#this&quot; class=&quot;headerlink&quot; title=&quot;this&quot;&gt;&lt;/a&gt;this&lt;/h2&gt;&lt;p&gt;参见我的博客&lt;a href=&quot;http://happylg.cn/2017/08/05/js-scope/#this对象&quot;&gt;this对象&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;javascript对象&quot;&gt;&lt;a href=&quot;#javascript对象&quot; class=&quot;headerlink&quot; title=&quot;javascript对象&quot;&gt;&lt;/a&gt;javascript对象&lt;/h2&gt;&lt;p&gt;参见&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/this%20%26%20object%20prototypes/ch3.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;你不懂JS: this 与对象原型–第三章：对象&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JS 中的对象拥有字面形式（比如 &lt;code&gt;var a = { .. }&lt;/code&gt;）和构造形式（比如 &lt;code&gt;var a = new Array(..)&lt;/code&gt;）。字面形式几乎总是首选，但在某些情况下，构造形式提供更多的构建选项。&lt;/p&gt;
&lt;p&gt;许多人声称“Javascript 中的一切都是对象”，这是不对的。对象是六种（或七中，看你从哪个方面说）基本类型之一。对象有子类型，包括 &lt;code&gt;function&lt;/code&gt;，还可以被行为特化，比如 &lt;code&gt;[object Array]&lt;/code&gt; 作为内部的标签表示子类型数组。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
      <category term="原型" scheme="http://happylg.cn/tags/%E5%8E%9F%E5%9E%8B/"/>
    
      <category term="prototype" scheme="http://happylg.cn/tags/prototype/"/>
    
      <category term="this" scheme="http://happylg.cn/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中并发编程与事件循环</title>
    <link href="http://happylg.cn/2017/09/02/js-eventLoop/"/>
    <id>http://happylg.cn/2017/09/02/js-eventLoop/</id>
    <published>2017-09-02T01:48:34.000Z</published>
    <updated>2019-08-12T12:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Javascript单线程原因"><a href="#Javascript单线程原因" class="headerlink" title="Javascript单线程原因"></a>Javascript单线程原因</h2><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><h2 id="事件循环原理"><a href="#事件循环原理" class="headerlink" title="事件循环原理"></a>事件循环原理</h2><p>事件循环可视化描述：<br><img src="/img/eventLoop.svg" alt="eventLoop可视化描述"><br>栈：执行栈<br>堆：存储对象<br>队列：消息队列或任务队列<br><a id="more"></a><br>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>异步任务执行顺序：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</li><li>主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</li><li>一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p>只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。</p><h3 id="任务队列特点"><a href="#任务队列特点" class="headerlink" title="任务队列特点"></a>任务队列特点</h3><p>“任务队列”是一个事件的队列（也可以理解成消息的队列）。<br>只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。<br>主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。</p><h3 id="永不阻塞"><a href="#永不阻塞" class="headerlink" title="永不阻塞"></a>永不阻塞</h3><p>每一个消息执行完成后，其它消息才会被执行。<br>一个很有趣的事件循环 (event loop) 模型特性在于，Javascript 跟许多其它语言不同，它永不阻塞。通常由事件或者回调函数进行 I/O (input/output)处理 。所以当一个应用正等待IndexedDB 的查询的返回或者一个 XHR 的请求返回时，它仍然可以处理其它事情例如用户输入。</p><h3 id="setTimeout和setInterval"><a href="#setTimeout和setInterval" class="headerlink" title="setTimeout和setInterval"></a>setTimeout和setInterval</h3><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><p>调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，<code>setTimeout</code>消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间而非确切的时间。<code>setTimeout(fn,time)</code>表示经过time时间插入到消息队列中，也就是任务队列中。<br>零延迟 (Zero delay) 并不是意味着回调会立即执行。在零延迟调用<code>setTimeout</code>时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量执行完成的时间。</p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h4><p>创建的定时器确保了定时器代码规则的插入到任务队列中。<br>问题是定时器代码可能在代码再次被添加到队列之前还没能完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。js引擎能避免这个问题，当使用<code>setInteval()</code>时，仅当没有该定时器的任何其他实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中最小时间间隔为指定间隔。<br>这个重复的定时器的规则有两个问题：</p><ol><li>某些间隔会被跳过</li><li>多个定时器的代码执行之间的间隔比预期要小。</li></ol><p><code>setInterval</code>会产生回调堆积，特别是时间很短的时候。</p><p><img src="/img/setInterval.png" alt="setInterval Bug图"><br>这个例子中的第 1 个定时器是在 205ms 处添加到队列中的，但是直到过了 300ms 处才能够执行。当执行这个定时器代码时，在 405ms 处又给队列添加了另外一个副本。在下一个间隔，即 605ms 处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。结果是，在这个时间点上的定时器代码不会被添加到队列中。结果在 5ms 处添加的定时器代码结束之后， 405ms 处添加的定时器代码就立刻执行。</p><p>避免这个两个缺点，可使用<code>setTimeout</code>链式调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//处理中</span></span><br><span class="line">    setTimeout(<span class="built_in">arguments</span>.callee, interval);</span><br><span class="line">&#125;, interval);</span><br></pre></td></tr></table></figure></p><p>这个模式链式调用了<code>setTimeout()</code>，每次函数执行的时候都会创建一个新的定时器。第二个<code>setTimeout()</code>调用使用了<code>arguments.callee</code>来获取对当前执行的函数的引用，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。这个模式主要用于重复定时器。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener">Concurrency model and Event Loop</a></li><li>Javascript高级程序设计(第3版)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Javascript单线程原因&quot;&gt;&lt;a href=&quot;#Javascript单线程原因&quot; class=&quot;headerlink&quot; title=&quot;Javascript单线程原因&quot;&gt;&lt;/a&gt;Javascript单线程原因&lt;/h2&gt;&lt;p&gt;JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。&lt;/p&gt;
&lt;h2 id=&quot;事件循环原理&quot;&gt;&lt;a href=&quot;#事件循环原理&quot; class=&quot;headerlink&quot; title=&quot;事件循环原理&quot;&gt;&lt;/a&gt;事件循环原理&lt;/h2&gt;&lt;p&gt;事件循环可视化描述：&lt;br&gt;&lt;img src=&quot;/img/eventLoop.svg&quot; alt=&quot;eventLoop可视化描述&quot;&gt;&lt;br&gt;栈：执行栈&lt;br&gt;堆：存储对象&lt;br&gt;队列：消息队列或任务队列&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
      <category term="eventLoop" scheme="http://happylg.cn/tags/eventLoop/"/>
    
  </entry>
  
</feed>
