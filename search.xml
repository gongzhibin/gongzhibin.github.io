<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《薛兆丰的经济学讲义》读书笔记]]></title>
    <url>%2F2019%2F07%2F22%2Fecnomics-lecture-notes%2F</url>
    <content type="text"><![CDATA[总评这是一本让你思维得到拓展的一本书，配合经典的法院判例，生动的诠释了枯燥难懂的经济学词汇，能够培养自己的经济学思维，让你变得更理性，值得一读。 四大基本约束 东西不够 生命有限 互相依赖 需要协调 稀缺，为何商业是最大的慈善真实世界 | 经济学的视角战俘营里的经济学战俘营是一个微型社会，有人的地方就有交易 货币： 香烟， 劣币驱逐良币 价格与价格波动： 面包的价格会随发放面包的时间波动 通胀与紧缩： 营房周围发生爆炸，差点没命，今朝有酒今朝醉， 都抽起了香烟，导致通货紧缩。听说红十字会送一批香烟过来，物品价格大涨，但是之后被证实为谣言，导致泡沫被戳破，价格大幅回落。 结论：经济规律在哪里都起作用 马粪争夺案一个人将马粪堆积起来放在路边准备明天再收取，但是第二天过来发现马粪被人收走了。 四种说法： 溯源说： 马粪归马的主人 位置说： 在什么位置就是谁的，在公家的马路上，所以谁都可以拿走 标记说： 若给马粪做了标记，那就是你的 劳动说： 帮工们花了功夫才把马粪堆好，所以应该给付出劳动的人 法官最后支持了劳动说，只有这样社会的财富才会越来越多。 公正背后是效率的考量： 保护产权是要消耗资源的，这种消耗越大，资源的净值越低；社会的道德规范越是能够帮助降低这种消耗，社会财富的积累就越多。当我们讨论公正的问题时，背后的含义往往是：这是符合效率标准的。不是单人效率的考量，而是整体社会长远发展的效率的考量。因为有效，所以公平。 看得见的和看不见的破窗理论：窗子打碎了，花钱买一块新玻璃，可以推动经济的发展。殊不知，买玻璃的钱可以节省下来去做其他的事，这个社会的财富减少了。破窗理论变种：战争和国家发展（战争有利于国家发展），工人就业（机器影响工人就业），节省物资（使用塑料袋不环保） 区分愿望与结果坏人干坏事的影响其实有限，而美好愿望不一定带来美好结果，好人好心不一定干好事：如最近的租房补贴 经济学是研究“事与愿违”的规律。美好的愿望不一定带来美好的结果，坏人干坏事的影响其实有限。那些一眼就能看出好坏的思想，我们能够识别并抵制，倒是那些用良好愿望包装起来的思想，我们比较难以识别。经济学与自然科学相同的地方在于，它研究的是不以人的意志为转移的客观规律–经济学关心的是事与愿违的现象，而不是事与愿符的现象。 人性观 | 人是理性与自私的吗？不确定性、进化与经济理论一种说法：经济学是建立在“人是理性的”这一认识基础之上的。它假定人是理性的，每个人都想用最小的代价来获得最大的利益。 万物存活看条件，和理性与否无关。现实世界中，往往不存在最优，其实每个人生活在世界上，追求的不是最优，而是存活。（阿尔钦）经济学关系的是存活的条件。经济学研究的是在什么条件下，人能够存活下来，而如果条件发生了改变，人们存活的情况又会发生怎样的改变。（进化论视角） 亚当·斯密的人性观 人是自私的，那些完全不自私的人，连自己都不爱的人，自暴自弃的人，在社会上是不会受到尊重的。 人不仅仅是自私的，同时还具有同情心，也就是有一种设身处地为他人着想的能力。 人的同情心是随着人与人之间距离的拉远而急速减弱的。 正因如此，斯密写下了这样一段警世恒言：“我们的晚餐，并非来自屠户、酿酒商或面包师的恩惠，而是出自他们自利的打算。我们不说唤起他们利他心的话，而说唤起他们利己心的话。我们不说自己有需要，而说对他们有利。” 小圈子靠爱心，大世界靠市场斯密的重要建议是：不要搞混了，不要在家庭、朋友圈里斤斤计较，过分讲究市场规则，也不要在市场上强求陌生人表现出不切实际的爱心。 铅笔的故事一只铅笔是由成千上万人合作完成的。 亚当 · 斯密“看不见的手”——在没有强制的情况下合作的可能性 商业是最大的慈善四大原因让行善扶贫难见成效: 缺乏反馈机制(无论好坏的慈善，反馈都是想继续要) 委托代理问题(花的不是自己的钱) 所托非人问题(比如由某企业造成的贫困，又让某企业去扶贫) 养懒汉效应 商业从根部上大幅度改善了我们的生活，商业是最大的慈善 区别对待 | 选择的标准稀缺经济学最基本假设不是人本理性或人本自私，这都不是完全成立的。最基本的假设是：稀缺！ 稀缺是一个基本事实 稀缺的原因有二： 我们想要的东西， 别人也想要。且人的需求在不断变化，不断升级 人的欲望无限。物质越丰富，需求就越新奇 选择和歧视由于东西总是不够的，资源总是稀缺的，人们在利用有限资源的时候，就不得不对资源的用途进行选择；而每当要做选择时，都必须采取某种选择的标准；一旦确定了选择标准，就意味着存在区别对待，而区别对待就是歧视。 只要稀缺不可避免，选择就不可避免，区别对待就不可避免，歧视也就不可避免。 稀缺必然导致歧视。所以我们不应该问要不要歧视，而是要问应该如何歧视。 凡歧视必得付代价贝克尔在博士论文《歧视经济学》（ The Economics ofDiscrimination ）中说，歧视别人的人，自己也得付出代价。 起源 偏好 信息不对称 房间突然出现一只老虎，你拔腿就跑的故事是说，人们经常以偏概全做判断，那是不得已，因为信息费用很高。以偏概全做判断当然会发生错误，但是跟人们要付出的成本相比，还是值得的。 代价经常有人说，美国人怎么样、日本人怎么样、韩国人怎么样。这都是一种以偏概全的视角，这种视角是一种歧视。但了解陌生人是有成本的，以偏概全（歧视）能让我们以最低的成本获取一些初步的印象。 当然，以偏概全是要付出代价的。错误的歧视，有可能要付出巨大代价。 顺着这个思路去想，我们会明白歧视造成的后果越严重，人们就越有积极性去减少歧视。如果歧视带来的后果不太严重，人们就会很随便地歧视别人。当我们不需要付出多少代价时，就会纵容自己歧视的习惯；当我们要付出很高代价时，就会节制自己歧视的习惯。 因为在偏远的小镇，居民的同质性强，歧视外人不会有多大损失，而在纽约这样的多种族集聚的地方，如果歧视别人，就得蒙受巨大的损失。并不是人生下来就心胸宽广，人们不歧视别人的心态，是在竞争当中慢慢习得的。 成本，不要只盯着钱选择偏好 | 放弃的最大价值一句话给成本下定义成本就是放弃了的最大代价Cost is the best opportunity foregone. 沉没成本不是成本成本是放弃了的最大代价，而如果没什么可放弃的，也就不存在成本。沉没成本，就是指那些已经发生但不可收回的支出。当我们没办法再收回、没办法再放弃时，就不存在成本。凡是提到成本，我们一定是向前（未来）看，而不是向后（过去）看的。所以，沉没成本不是成本。 你的成本由别人定义 负面的感受不是成本 你的成本由别人决定 你的职业范围由社会决定 今天的人喜欢讲“不忘初心”，但为什么不忘初心那么难呢？因为当初你有“初心”的时候，选择的机会可能没那么多，所以比较容易坚持。但随着境遇的变化，机会增加，你要坚持原来的看法就越来越难了，成本就越来越高了，放弃的东西就越来越多了。因此“不忘初心”不是一件容易的事。 其实，你今天能选择的职业，只是一个非常狭窄的范围，这是今天大多数人都认可而存在的职业范围。你在这当中要选择自己兴趣最大、付出成本最低，而且在相当一段长时间里总收入最高的职业。 经济学的看法是：你拥有你的生命，但是你的生命是怎么度过的，你的职业是怎么选择的，很大程度上是由社会上其他人决定的。 经济学的看法是：你拥有你的生命，但是你的生命是怎么度过的，你的职业是怎么选择的，很大程度上是由社会上其他人决定的。 别只盯着钱货币成本有别于全部成本（时间成本，假货损失的成本） 给士兵发薪水比免费征兵更便宜：义务征兵时，政府付出的货币成本确实比较低，但是他没有看到另外一个重要成本，就是放弃了的最大代价。 一个青年，被征去当兵以后，就不能从事他原来的职业了。这时虽然多了一个廉价的士兵，但可能少了一位化学家、一个小提琴手，或是一位企业家。总的来说，义务兵制的成本是非常高的，因为它放弃的代价是不可估量的。 有人会说，那兵源问题如何解决呢？最好的办法，是采用志愿兵制，政府出钱请士兵。政府说我出1元钱请人当兵，当然没人愿意干，出两元钱也没人愿意，出100元、1000元呢？最后可能出到2000元时，就开始有人愿意了。 第一个愿意接受2000元去当兵的人，是在别处机会最少的人，也是认为当兵能给他带来最大满足感的人，这种人是最适合当兵的。也就是说，政府能够以最低的代价招募到最合适的兵，这才是我们解决兵源问题的好办法。 经济学家米尔顿·弗里德曼曾经给美国政府提过不少建议，大多数都没被接受。但是这一条，建议将征兵制改为志愿兵制，就被美国政府接受了。这对于减少美国的国防总成本，提高征兵效率，提高兵员质量，有极大的帮助。 中间商赚差价，让商品价格更便宜：在大多数情况下，中间商在帮助我们减少总成本，而不是增加总成本，而中间商之间的竞争，会使物流的总成本降到最低。 资源的价值 | 重新理解盈利和亏损从成本的角度理解盈利和亏损凡是盈利都是意外当我们得知这个碗不是一个普通的碗，而是一个珍贵古董的时候，我们获得了盈利。凡是盈利都是意外，英文叫作windfall profit，也译成“横财”。横财是在我们意识到这个商品的价值跟预期不一样的瞬间产生的。 从那一刻起，这个产品的价值就发生了变化。我们继续使用这个产品的成本，就要以新的价值为标准进行估算了。赚取利润只是瞬间的事情，一旦赚取了利润，这个碗就变成了另外一种资源。如果我们再把这个碗用作其他用途，那么放弃了的最大代价，就要以它在博物馆里赚取收入的水平来计算了。所以说，盈利提高了资源未来使用的成本。 亏损会降低资源使用成本无论是盈利还是亏损，在经济学里，都是意外发生的。每当发生意外，我们就重新调整资源的未来估值，而资源使用的成本，就要按照这个新的估值来计算。所以，一旦出现盈利，资源的使用成本就会提高；一旦出现亏损，资源的使用成本就会下降。 重新估值不难，难的是找出盈利或亏损的原因[未完待续]]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端渲染与nuxt]]></title>
    <url>%2F2019%2F06%2F06%2Fnuxt%2F</url>
    <content type="text"><![CDATA[服务端渲染优势 有利于SEO 首屏加载时间减少 劣势 开发 客户端代码不能用在服务端 需要一个服务端环境，耗费更多的服务器资源 vue服务端渲染服务端渲染时已经得到了数据的状态，默认情况下禁用响应式，只有beforeCreate和created会在服务的渲染时会被调用。 避免在beforeCreate和created生命周期中产生全局副作用的代码，ssr没有不能操作之后的生命周期以消除这些副作用。 通用代码不可接受特定平台的 API, 比如window和document nuxt基础认知开箱即用的基于vue的ssr框架 特性nuxt.config.js配置文件，构建nuxt的重要文件 nuxt服务端渲染 服务端渲染：第一次加载，网址访问或者刷新页面等，不走前端路由而直接访问服务器 客户端渲染：通过前端路由访问 生命周期 其中，红框只在服务端执行，黄框在服务端和客户端均执行，绿框只在客户端执行 服务端是没有window和document，所以使用window和document时需要加执行环节判断 异步数据加载，asyncData和fetchasync: 数据获取（会在服务端执行）fetch: 数据获取，存于store 参数为ctx会有大量数据，以供调用 支持ES7 async进行异步获取数据 page目录与路由Nuxt依据pages目录结构自动生成vue-router模块的路由配置。 middleware页面渲染之前执行，可做一些登录态等的处理 plugins初始化vue实例前执行的代码，可以按照一些vue插件等 [未完待续]]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何选择相同类的第一个和最后一个元素]]></title>
    <url>%2F2019%2F04%2F29%2Ffirst-and-last-class-selector%2F</url>
    <content type="text"><![CDATA[引言项目中，使用 1234div:first-child // 父元素的第一个div元素div:first-of-type // 父元素下的div元素中的第一个div:last-childdiv:last-of-type 四个伪类，选出第一个或最后一个元素，并赋予相应的样式。 但是遇到了一个问题，就是如果对一个class类使用伪类，会发生意想不到的效果。因为这些伪类的作用对象是元素(tag)而不是类(class)，所以如果相同的类却有不同的元素类型，会发生不同的效果。 使用last-of-type选择最后一个类选择出父元素内的最后一个class为item的子元素。 代码如下： 123456789101112&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;p class="item"&gt;&lt;/p&gt;&lt;/div&gt; 12345678910111213.container &#123; margin-bottom: 20px;&#125;.container .item &#123; width: 100px; height: 10px; margin-bottom: 5px; background-color: #0f0;&#125;.container .item:last-of-type &#123; background-color: #f00;&#125; 代码中对最后的元素使用:last-of-type修饰改为红色，比较两个模块可以看出，当不同的元素拥有相同的类时，不同元素的最后一个都会变为红色，无法选出最后一个类。first也是类似。代码见：https://codepen.io/zxlg/pen/pBBjmJ 使用last-child选择最后一个类代码如下： 123456789101112131415&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="container"&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div class="item"&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.container &#123; margin-bottom: 20px;&#125;.container .item &#123; width: 100px; height: 10px; margin-bottom: 5px; background-color: #0f0;&#125;.container .item:last-child &#123; background-color: #f00;&#125; 代码中对最后的元素使用:last-child修饰改为红色，比较两个模块可以看出，当最后一个元素的类不是设定的类item, 则无法选出父元素内的子元素的最后一个类。first也是类似。代码见：https://codepen.io/zxlg/pen/ZZZWdP 可用的选择第一个类的方法网上有类似的讨论，只能得到一个实现获取第一个类的方法。如上所示： 123456.A &#123; // 所有.A元素&#125;.A ~ .A &#123; // 所有.A元素其前拥有兄弟元素.A&#125; 两个作用域相减，得到第一个.A的元素。 若想要实现选中某个类的最后一个，只能暂用js去实现较为稳妥。 参考文献 CSS3选择器:nth-child和:nth-of-type之间的差异 CSS selector for first element with class]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>front</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛克菲勒留给儿子的38封信]]></title>
    <url>%2F2019%2F04%2F05%2FRockefeller-s-38-letters-to-his-son%2F</url>
    <content type="text"><![CDATA[总评身处这个迷茫，诱惑重重的时代，听着”平凡才是真“的“箴言”，很多青年错把平庸当作平凡，殊不知那些历经精彩的人生，回首往事时去谈平凡才有意味，譬如杨慎的《临江仙》，“滚滚长江东逝水，浪花淘尽英雄。是非成败转头空。青山依旧在，几度夕阳红。白发渔樵江渚上，惯看秋月春风。一壶浊酒喜相逢。古今多少事，都付笑谈中”。杨慎，金科状元，明朝三大才子之手，时正任翰林院修撰的杨慎，因“大礼议”受廷杖，削夺官爵，定罪为谪戍终老于云南永昌卫。而你又知道古今多少事？所以骚年，不要为赋新词强说愁，你需要的是把握当下，勇往直前，思考的是做好当下的每一件事，并做到知行合一，走向成功。 无意中在雪球上看到了关于这本书的几篇文章，当时就决定好好看下这本书。看完之后颇有感慨，一些人生道理是我们没有真正知道的，所以更谈不上知行合一，以此记录下来一些总结和感悟，以备查阅。 书籍总结第1封 好的起点并不决定好的终点 试想，我们这个世界如同一座高山，当你的父母生活在山巅时，你注定不会生活在山脚下；当你的父母生活在山脚下时，注定你不会生活在山巅。在多数情况下，父母所处的位置决定了孩子的人生起点。 但这并不意味着，起点不同，其人生结果也不同。世界上永远没有贫、富世袭之说，也永远没有成、败世袭之说，有的只是奋斗与成功的真理。我坚信，我们的命运由我们的行动决定，而并非完全由我们的出身决定。 第2封 运气靠策划 运气是策划的残余物质 通过了解自己的目标，了解自己的实力和资源创造运气 第3封 天堂与地狱的距离 事实上，雇主想要按时工作、诚实努力的雇员，他只将加薪与升迁机会留给那些极其努力、忠心、热心、效率高爱做事的雇员，因为他在做生意，而不是在做慈善事业，他需要的是那些更有价值的人。 一个人的野心不管有多么大，他至少得先起步才能到达高峰。一旦起步，继续前进就容易多了。工作越困难或不愉快，越要立刻去做，否则等的时间越久，就变得越困难、可怕。这有点儿像打枪，你瞄准时间越长，射击的机会就越渺茫。 第4封 自动自发，立即行动 看看那些庸碌无为的普通人，你会发现，他们说的远比做的多，甚至只说不做。但他们个个都是找借口的行家，总会找各种借口来开脱，直到最后证明这件事不应该、没有能力或已经来不及做为止。 缺乏行动之人都有一个坏习惯：喜欢维持现状，拒绝改变。 我还没听过有人因为没有打扰别人、没有采取行动或要等别人下令才做事而受到赞扬的。那些在商界、政府、军队中的领袖，都是很有才能又实干、自动自发的人。那些站在场外袖手旁观的人永远当不上领导者。 第5封 心怀接受挑战的决心 要想在竞争中获胜，就要经常保持警觉，当你不断看到对手想削弱你时，那就是竞争的开始。这时你需要知道自己拥有什么，也需要知道友善、温情可能会害了你，而后就是动用所有的资源和技巧，去赢得胜利。 当然，要想在竞争中获胜，勇气只是赢得胜利的其中一面，还要有实力。 第6封 为幸福前途抵押生命 借钱不是坏事，只要你不把它看成像救生圈一样，只在危机时使用，而把它看做一种有力的工具，就可以用它来创造机会。否则，你就会掉入恐惧失败的泥潭而终无大成。 慎重贷款！高杠杆也是容易出人命的！ 人生就是不断抵押的过程，为前途我们抵押青春，为幸福我们抵押生命。如果你不敢逼近底线，你就输了。为成功我们抵押冒险不值得吗？ 在我从银行家手里接过巨款时，我抵押出去的不光是我的企业，还有诚实。我视合同、契约为神物，严格遵守合同，从不拖欠债务。我对投资人、银行家、客户，包括竞争对手，从不忘以诚相待，在同他们讨论问题时都坚持讲真话，从不捏造或含糊其辞，我深信谎言在阳光下就会暴露。 第7封 精神破产更可怕 我把失败当做一杯烈酒，咽下的是苦涩，吐出的却是精神。 人人都痛恨失败，然而，一旦避免失败成为你做事的动机，你就走上了怠惰之路。这非常可怕，甚至是种灾难。因为这预示着人可能要丧失可能存在的机会。 害怕失败而不敢冒险，不敢冒险就会错失眼前的机会。所以，儿子，为了避免机会丧失、保住竞争资格，遭受失败与挫折也物有所值！ 乐观之人在苦难中看到机会，悲观之人在机会中会看到苦难。 梦想+失败+挑战=成功之道 年轻人，你的人生旅程才刚刚开始，所以我告诉你一个对未来很有帮助的启示，我并未失败过一万次，我只是发明了一万种行不通的方法。 人生的字典没有失败，只有发现了一种行不通的方法。 第9封 信念带领人走向成功 我从不相信失败是成功之母，我坚信信心是成功之父。胜利是一种习惯，失败也是一种习惯。如果想成功，就得取得持续性的胜利。我不喜欢取得一时的胜利，我要的是持续性胜利，只有这样我才能成为强者。信心激发了我成功的动力。 采取“暂且试试看，但我想还是不会有什么结果”的态度，最后一定会失败。“不信”是消极力量。当你心中不以为然或产生怀疑时，你就会想出各种理由来支持你的“不信”。怀疑、不信、潜意识里认为会失败的倾向，以及内心不渴望成功都是导致失败的主因。心中存疑，就会失败。相信会胜利，就必定成功。 发自内心的相信自己。 信心的大小决定成就的大小。庸庸碌碌、得过且过的人，他们只能得到微小的报酬。他们相信不能做出伟大事业，他们就真的做不到。他们认为自己很不重要，他们所做的每一件事都显得无足轻重。久而久之，连他们的言行举止都会透露出缺乏自信。如果他们不能将自信抬高，他们就会在自我评估中畏缩，变得越来越渺小。而且他们如何看待自己，别人就会怎么看待他们，于是这种人在众人的眼光下就会变得更渺小。积极向前的人坚信自己有更大的价值，他就能得到很高的报酬。他相信他能处理艰巨的任务，真的就能做到。他所做的每一件事情，他的待人接物，他的个性、见解和想法，都证明他是专家，是一位重要人物。 照亮我的道路，不断给我勇气，让我愉快地正视人生理想的，正是信心。我无时无刻都不忘增强自信。我用成功的信念取代失败的想法。当面临困境时，我想到的是“我能赢”，而不是“我可能会输”。当与人竞争时，我想到的是“我和他们一样出色”，而不是“我没法跟他们比”。当机会出现时，我想到的是“我能做到”，而不是“我做不到”。 我经常提醒自己：你比你想象的还好。 成功的人只是相信自己、肯定自己所作所为的平凡人。永远不要、绝对不要廉价出售自己。 第10封 相信自己，忠于自己 我一直坚守一个原则：我可以欺骗敌人，但绝不欺骗自己。回击正在射击我的敌人，永远不会让我良心不安。 只有在对自己有利无害的情况下，我才表露自己的情感；我可以让对手教导我，但我永远不教导对手，无论我对那件事了解有多深；不管别人如何催促，不考虑周全绝不行动；我有自己的真理，只对自己负责；小心那些要求我以诚相待的人，他们是想在我这里捞到好处。 三思而行，不要因为别人的催促而匆忙行动。 第11封 贪心大有裨益 静静地回溯历史，检视人类的脚印，我们能得出这样的结论：没有一个社会不是建立在贪心之上。那些企图诋毁我的人，看似道德的守望者，但他们有谁不想独占自己拥有的东西？有谁不想掌控所有好的东西？有谁不想控制每个人都需要的一切？虚伪之人实在是太多了。 贪心没什么不好，我觉得贪心是件好事，人人都可以贪心。从贪心开始，才会有希望！” “贪”在这里更多的表达的是进取心 就像那些演化家所告诉我们的那样，自然界不是仁慈无私的场所，而是适者生存的天地，我所在的文明社会也同样如此。如果你不贪心，或许你就会被别人吃掉，毕竟可口的甜点很少。 实际上，只要追逐名利的世界一天不被摧毁，只要幸福一天不变得像空气那样唾手可得，人类就一天不能停止贪心。 任何力量都不能阻止我放弃贪心，因为我想成功。贪心之下实现的成功并非罪恶，成功是一种高尚的追求，如果能以高尚的行为去获取成功，对人类的贡献会远比贫困时所能做的更多，我做到了！ 第12封 地狱里住满了好人 在这个世界上能出人头地的人，都是那些懂得去寻找自己理想环境的人，如果找不到理想环境，就会自己创造出来。 第13封 天下没有免费的午餐 这则故事的寓意很简单，一只动物要靠人类供给食物时，它的机智会消失，麻烦会随之而来。同样的情形也适用于人类，如果你想让一个人残废，只要给他一对拐杖再等上几个月就能达到目的；换言之，如果在一定时间段给一个人免费的午餐，他就会养成不劳而获的习惯。 资助金钱是一种错误，它会使一个人失去动力，不再节俭勤奋，而变得懒惰、不思进取。更为重要的是，当你向一个人施舍时，就等于否定了他的尊严，抢走了他的命运，这在我看来很不道德。作为富人，我有责任成为造福于人类的使者，却不能成为塑造懒汉的始作俑者。 授人以鱼不如授人以渔 第14封 懂得装傻的人才是真聪明 一头猪好好被夸奖一番，它就能爬上树。善于驱使别人的经营者、领导者或大有作为的人，他们懂得尊敬和赞美他人的艺术。这意味着他们要付出感情。而付出深厚感情的领导者最终必赢得胜利，并获得下属的更多敬重。 但是，受自尊心的驱使，很多有知识的人对“不懂”总是难以启齿，好像向别人请教是丢人的事，这是自作聪明，这种人永远都不会理解那句伟大的格言——每一次说不懂的机会，都会成为我们人生的转折点。 直至今日我都能清晰地记得一次装傻的情景，当我正为如何筹到1.5万美元而大伤脑筋时，我走在大街上都在苦思冥想它。说来很可笑，正当我满脑子闪现出借钱的想法时，有位银行家拦住了我的去路，他在马车上低声问我：“你想用5万美元吗，洛克菲勒先生？”我交了好运吗？我都不相信自己的耳朵了，但那一刻我并未表现出丝毫的急切，我看了看对方，慢条斯理地告诉他：“是这样……能给我24小时考虑考虑吗？”最终，我以最有利的条件与他达成了借款合同。 装傻会带给你很多的好处。它的含义是摆低姿态，换言之，就是隐藏你的聪明。越是聪明的人越有装傻的必要，因为就像那句格言所说的——越是成熟的稻子，越垂下稻穗。 “让我想想再说”，是我在经商中始终奉行的格言。我做事总有一个习惯，作决定之前，先冷静地思考，但我一旦作出决定，就将义无反顾地执行到底。 让我想想！ 第15封 财富是勤奋的副产品 但机会如同时间一样是平等的，为何我能抓住机遇成为巨富，而很多人却与机会擦肩而过呢？难道真如诋毁我的人所说，是因为我贪得无厌吗？不！是勤奋！机会只留给勤奋之人！我自年少时就笃信一条成功法则：财富是意外之物，是勤奋工作的副产品。每个目标的达成都来自勤奋思考与踏实行动。 第16封 不给失败找借口 在我看来找借口是一种思想疾病，而严重染有这种病的人，无一例外都会失败，当然一般人也有一些轻微症状。但是，一个人越是成功，越不会找借口，处处亨通的人与那些没有什么作为的人之间最大的差异，就在于是否找借口。 有一句老话说得好：“我一直在为自己的破鞋子懊恼，直到我遇见一位没有脚的人。” 我从不屈从于运气，我相信因果定律。看看那些似是好运当头的人，你会发现并不是运气使然，而是计划和积极的思想带来的成果。再看看那些“运气不好”的人，你会发现背后都有明确的成因。成功者能面对挫折，从失败中学习，再创契机。平庸者往往就此灰心丧气。 不给失败找借口，要为成功找理由 第17封 手中握有成功的种子 对于一个要去创业的贫寒之人而言，他们常常苦恼于没有资本。如果他们再害怕失败，就会变得犹疑不决，像蜗牛般缓慢行进，甚至止步于成功之路，而永无出头之日，所以我在给那个年轻人的回信中特别提醒他：“从贫穷通往富裕之路永远畅通无阻，重要的是你要有这样的信念：‘我就是最大的资本。’你要锻炼信念，不停地探究迟疑的原因，直到信念取代怀疑。你要了解，你自己不信的事，你无法达成；信念是带你前进的力量。” 投资自己，让自己变得更强大，才能在需要你的时候不至于无能为力。 印度戈尔康达钻石矿。 阿拉伯人的故事却带给我宝贵的人生教诲：你的钻石不在遥远的高山与大海之间，如果你下定决心去挖掘，钻石就在你家的后院。重要的是真诚地相信自己。 每个人都有理想，这种理想决定了他的努力和判断方向。就此意义而言，我觉得不相信自己的人就跟窃贼一样，因为任何一个不肯定自己，而且未充分发挥本身才能的人，可以说是向自己偷窃的人；而且在这个过程中，由于创造力低落，他也等于是从社会偷窃。由于没有人会从他自己那里故意偷窃，那些向自己偷窃的人，显然都是无意中偷窃了。然而这一罪状仍很严重，因为其所造成的损失跟故意偷窃一样严重。 不相信自己 –&gt; 没有为自己(社会)创造应有的财富和价值 –&gt; 偷窃了自己(社会)的价值 第18封 无权当穷人 儿子，没有比为赚钱而赚钱的人更可悲、更可鄙的，我懂得赚钱之道：要让金钱当我的奴隶，而不能让金钱奴役我。 和平年代，没有任何理由做一个穷人。 第19封 时刻怀有做第一的心态 人之所以被创造出来是有目的的，一个人不是在计划成功，就是在计划失败。 我相信勤奋会致富，但不相信努力为别人工作就一定成功。我住进百万富翁大街前就发现，我身边的很多穷人都是工作最努力的人。现实就是如此残酷，不管雇员努力与否，替老板工作而变得富有的人少之又少。替老板工作所得的薪金，只能在合理预期的情况下让雇员活下去，尽管雇员可能会赚到不少钱，但变得富有却很难。我一直视“努力工作定会致富”为谎言，从不把为别人工作当做积累可观财富的过程；相反，我非常相信为自己工作才能富有。我采取的一切行动都忠于我的伟大梦想和为实现这一梦想而不断达成的各个目标。 为自己工作！ 第20封 敢于冒险才能创造机会 好奇才能发现机会，冒险才能利用机会。 如果你想知道既冒险又不招致失败的秘诀，你只需要记住一句话：大胆筹划，谨慎实施。 大胆假设，小心求证 第21封 侮辱是一种强大的动力 对他人的报复，就是对自己的攻击。 我知道任何轻微的侮辱都可能伤及尊严。但是，尊严不是天赐的，也不是别人给的，是你自己缔造的。尊严是精神产品，每个人的尊严都属于他自己，你认为自己有尊严，你就有尊严。所以，如果有人伤害你的感情、尊严，你要不为所动。如果死守你的尊严，就没有人能伤害你。 自己对自身的尊重是尊重中最重要的部分。 第22封 用实力让对手恐惧 要完成一笔好交易，最好的方法是强调其价值。而很多人会犯强调价格而非价值的错误 第23封 合作精神尤为重要 范德比尔特将军一定明白了这样一个道理：往上爬的时候要对别人好一点儿，因为你走下坡路的时候会碰到他们。 第24封 相信自己才能成功 成功不能用一个人的身高、体重、学历或家庭背景来衡量，而是以他思想的“大小”来决定。我们思想的大小决定我们成就的大小。这其中最重要的一条就是我们要看重自己，克服人类最大的弱点——自卑，千万不要廉价出卖自己。你们比你们想象中的更伟大，所以，要将你们的思想扩大到你们真实的程度，绝不要看轻自己。 看重自己，你比想象的更强大。 第25封 让每一分钱都带来效益 我之所以能取得巨大的成就，就在于我首先经营了人——所有的人。 我喜欢查尔斯先生最喜欢的一句格言：“珍惜时间和金钱。”我一直认为这是一句凝聚了伟大智慧的箴言。我相信绝大多数人都会喜欢它，却难以将其变成自己的思想信念和价值观，并永远溶入自己的血液中。 每一刻都是关键，每一个决定都会影响生命的过程，所以，我们要有作出决定的策略。作决定不易太快，遇到重要问题时，如果没有想好最后一步，就永远不要迈出第一步，要相信总有时间思考问题，也总有时间付诸行动，要有促进计划成熟的耐心。但一旦作出决定，就要像斗士那样忠实地去执行。 世界上有两种人永远不会富有：第一种是及时行乐者，他们喜欢过奢侈的生活，像苍蝇叮臭肉那样痴迷于奢侈品，他们挥霍无度，竭尽所能要拥有精美的服饰、昂贵的汽车、豪华的住宅以及价格不菲的艺术品。这种生活的确令人着迷，但缺乏理性，及时行乐者缺乏这样的警惕：他们这样做是在寻找增加负债的方法，他们会成为可怜的车奴、房奴，而一旦破产，他们就完了！第二种人喜欢攒钱，把钱存在银行里固然保险，但这跟把钱冷冻起来没什么两样，要知道靠利息不能发财。但有一种人会成为富人，比如在座的诸位，我们不寻找花销的方法，我们寻找、培养和管理各种投资的方法，因为我们知道财富是可以用来增值的，我们会把钱拿来投资创造更多的财富。但我们还要知道，让每一分钱都能带来效益！这正如约翰一贯的经商原则——每一分钱都要让它物有所值！” 珍惜时间和金钱”这句话却一直与我相伴。我没有理由浪费生命，浪费生命就等于扼杀自己，世界上没有比糟蹋自己更大的悲剧了。 我也不把安逸和享乐看做生活目的本身，因为我称其为猪的理想。 创造是人的价值! 第26封 忍耐就是策略 忍耐并非盲目的容忍，你需要冷静地考量情势，搞清你的决定是否会偏离或有害你的目标。 在我看来，忍耐并非忍气吞声，也绝非卑躬屈膝，它是一种策略，同时也是一种性格磨炼，它所孕育出的是好胜之心。 能忍人所不能忍之忤，才能为人所不能为之事。 在任何时候冲动都是我们最大的敌人。如果忍耐能化解不该发生的冲突，这样的忍耐永远是值得的；但是，如果坚持一意孤行，非但不能化解危机，还会带来更大的灾难。 在这个世界上我们要忍耐的人和事太多太多，而引诱我们感情用事的人和事也太多太多。所以，你要修炼自己管理情绪和控制情感的能力，要注意在作决策时不要受情绪所左右，而是完全根据需要来作决定，要永远知道自己想要什么。你还需要知道，在机会的世界里，没有太多的机会可以争取，如果你真的想成功，你一定要掌握并保护自己的机会，更要设法抢夺别人的机会。记住，要天天怀有一些忍耐的心，它会给你带来快乐、机遇和成功。 第27封 幸运之神眷顾勇者 幸运儿是因为幸运才表现得自信和大胆，还是他们的“运气”是自信和大胆的结果呢？我的答案是后者。 越努力，越幸运 第28封 用更好的办法把事情做得更好 我的用人原则是被委以重任者要能找出更好的方法把事情做得更好。 各种计划都不可能达到绝对的完美，这意味着一切事物可以无止境地进行改良。我深知这一道理，所以我经常会再寻找一些更好的方法。我不会问自己：“我能不能做得更好？”我知道我一定办得到，所以我会问：“我要怎样才能做得更好？” ## 第29封 结束意味着另一个开始 第一个策略：一开始就要下决心，关注竞争状况和竞争者的资源。 第二个策略：研究和检视对手的情况，然后善用这种知识，来形成自己的优势。 第三个策略：你必须拥有积极正确的心态。 第30封 不要让小人拖后腿 我喜欢同那些永不屈服的人交朋友。有个聪明人说得好：我要挑战令人厌恶的逆境，因为智者告诉我，那是通往成功最明智的方向。只是这种人少之又少。 这种人绝不让悲观左右一切，绝不屈从各种阻力，更不相信自己只能浑浑噩噩虚度一生。他们活着的目的就是获得成就。这种人很乐观，因为他们一定要完成自己的心愿。这种人很容易成为各个领域的佼佼者。他们能真正地享受人生，也真正了解生命的可贵与价值。他们都盼望新的每一天，以及跟别人之间的新接触，因为他们把这些看成丰富人生的历练而热烈地接受。 你要多加防范那些说你不行的人，只能把他们的警告当做证明你一定办得到的挑战。你还要特别防范消极者破坏你迈向成功的计划，这种人随处可见，他们似乎专门破坏别人的进步与努力。千万要小心，要多多注意那些消极者，千万不要让他们破坏你的计划。不要让那些思想颓废、心胸狭窄的人妨碍你进步。那些幸灾乐祸、善妒之人都想看你失败，不要给他们机会。 第31封 目的是一切，做目的主义者 目的是我领导的依据，目的就是一切。 杰出的领导者都善于动用两种无形的力量：信任和尊重。当你诚实地说出你的目的时，你也传递了这样的信息：“因为我对你有足够的信任，所以我愿意向你表白。”它将开启让人信任之门，而在大门外，你拥抱的不仅是下属的能力，还有来自他们的忠诚——要凝聚力量来帮助你的忠诚。信赖别人并使别人信赖我，是我一生取得成就的重要因素。 公开你的目的，更能避免无益的推论。 目的表明的力量无可取代，它所传达出的不仅是一项声明，同时也是领导者对于个人行为勇敢坚决的誓言。 想想你看这本书，看这篇文章的目的是什么？ 第32封 认清职责，拒绝推诿 如果我们想要永久生存，那么我们的领导方式就意味着断然拒绝为了任何理由，去责难任何一个人或任何一件事。责难就如同一片沼泽，一旦失足跌落进去，你便失去了立足点和前进的方向，你会变得动弹不得，陷入憎恨和挫折的困顿之中。结果只有一个：失去下属的尊重与支持。一旦落入这步田地，那你就好似一个将王冠拱手让给他人的国王，无法再主宰一切。 我的下属都知道我的基本原则：在标准石油公司没有责难、没有借口！这是我坚持的信条，每一个人都知道。我不会因为他们犯错而惩罚他们，但是我绝不能容忍不负责任的行为存在。我们的信念就是要彻底奉行。我们的箴言是支持、鼓励和尊重将被全心接受与加倍颂扬。只会找借口而不提供解决方式，在标准石油公司是无法容忍的。 第33封 善用每个人的智慧 做你喜欢做的事，而其他事，就交由喜欢做这件事的人去做。 最完美的人就是那彻底投身于自己最擅长的活动的人。” 与很多人不同，我不以自己的好恶为优先选拔人才的标准，我用人并不会看他身上贴着什么标签，我看中的是他在工作中展示出来的能力。我喜欢自己的喜好，但更喜欢效率。 第34封 策略性思考是关键 我想你也可以获得这样的赞誉，只是你需要克制找寻简单、单向解决方案的冲动，乐于尝试能达成目标的各种可能性办法，拥有在困难面前付诸行动的耐心、勇气和胆略，以及不达目的决不收手的执着精神。 作为总裁，我只为部属设立清楚明确的方向或策略，但不会将自我局限于过分僵化的行动计划中。 第37封 充实你的心灵 我们不能读那些文字商人的书，他们的书犹如瘟疫，散布无耻的邪念、讹误的消息和自负的愚蠢，他们的书只配捧在那些浅薄、庸俗的人手里。我们需要的是能给我们带来行动的信心与力量，能够将我们的人生推到另一个新高度和引导我们行善的书， # 结语 财富达到美国２.4%的那个男人，打破富不过三代说法的一个富六代家族创始人，捐献了自身财富的３５％的慈善家。希望这些他交给儿子的话能帮助到犹豫和迷茫的你。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书，励志书籍</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack+vue+vue-router]]></title>
    <url>%2F2018%2F08%2F23%2Fwebpack-vue-vue-router%2F</url>
    <content type="text"><![CDATA[webpack + vue + vue-router学习笔记安装webpack12npm initnpm i -D webpack webpack-cli 建立代码目录 使用webpack终端1234# &#123;extry file&#125;出填写入口文件的路径，本文中就是上述main.js的路径，# &#123;destination for bundled file&#125;处填写打包文件的存放路径# 填写路径的时候不用添加&#123;&#125;webpack &#123;entry file&#125; -o &#123;destination for bundled file&#125; 命令：webpack app/main.js public/bundle.js 出错及更正：ERROR in multi ./hello.js bundle.js Module not found: Error: Can&#39;t resolve &#39;bundle.js，更正：webpack版本过高,原来的命令已经不适用了，更换打包命令：webpack app/main.js -o public/bundle.js 配置文件根目录新建webpack.config.js，代码如下： 123456789101112131415const path = require('path');module.exports = &#123; // 环境 mode: "development", // 唯一入口 entry: path.resolve(__dirname, 'app/main.js'), // 出口 output: &#123; // 打包后文件所在目录 path: path.resolve(__dirname, 'public'), // 文件名 filename: 'bundle.js' &#125;&#125; 根目录运行webpack打包程序 npm配置npm配置文件package.json中配置scripts可以运行相应命令 12345678910111213141516&#123; "name": "vue-router-manual", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "build": "webpack" &#125;, "author": "", "license": "ISC", "devDependencies": &#123; "webpack": "^4.16.5", "webpack-command": "^0.4.1" &#125;&#125; 运行npm run build或者npm run-script build即可让webpack打包代码 搭建本地服务器安装依赖：npm i -D webpack-dev-serverwebpack配置： 123456789// webpack本地服务器devServer: &#123; contentBase: path.resolve(__dirname, 'public'), // 本地服务器所加载的页面所在目录 historyApiFallback: true, // 不跳转 inline: true, // 实时刷新 compress: true, // 是否压缩 host: '127.0.0.1', port: 9000,&#125; 运行webpack-dev-server即可启动本地服务器 应用vue框架 其中src中的main.js为入口文件。 1234567891011// main.jsimport Vue from 'vue';// import Router from 'vue-router';import App from './app.vue';let root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(root) app.vue为单页面组件。 123456789101112131415161718&lt;template&gt; &lt;div class=&quot;test&quot;&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg: &quot; vue + vue-router + webpack&quot; &#125;; &#125; &#125;;&lt;/script&gt;&lt;style&gt; .test &#123; color: coral; &#125;&lt;/style&gt; 安装loaderswebpack中安装并使用loader进行代码的打包 1234# npm一次性安装多个依赖模块，模块之间用空格隔开npm i -D html-webpack-pluginnpm i -D vue vue-loader vue-template-compilernpm i -D babel-core babel-loader babel-preset-es2015 style-loader css-loader url-loader file-loader webpack配置完善为： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// webpack.config.jsconst path = require('path');const htmlWebpackPlugin = require('html-webpack-plugin');const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = &#123; // 环境 mode: "development", // 生成Source Maps，使调试更容易 // eval-source-map只能在开发阶段使用 // devtools: 'eval-source-map', // 唯一入口 entry: path.resolve(__dirname, 'src/main.js'), // 出口 output: &#123; path: path.resolve(__dirname, 'dist'), // 打包后文件所在目录 filename: 'index.js' // 文件名 &#125;, plugins: [ new htmlWebpackPlugin(), new VueLoaderPlugin() ], module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: &#123; loader: 'babel-loader', &#125; &#125;, &#123; test: /\.vue$/, use: &#123; loader: 'vue-loader', &#125; &#125;, &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.(gif|jpg|jpeg|svg)$/, use: &#123; loader: 'url-loader', options: &#123; limit: 1024, name: 'name.[hash:6].[ext]' &#125; &#125; &#125; ] &#125;, // webpack本地服务器 devServer: &#123; contentBase: path.resolve(__dirname, 'public'), // 本地服务器所加载的页面所在目录 historyApiFallback: true, // 不跳转 inline: true, // 实时刷新 compress: true, // 是否压缩 host: '127.0.0.1', port: 9000, &#125;&#125; 错误及解决 选项配置错误 1234567891011121314151617Options Validation Erroroptions.module should match some schema in anyOfoptions.module.rules[2] should match some schema in anyOfoptions.module.rules[2].use should be stringoptions.module.rules[2].use should pass "instanceof" keyword validationoptions.module.rules[2].use should match some schema in anyOfoptions.module.rules[2].use should pass "instanceof" keyword validationoptions.module.rules[2].use should match some schema in anyOfoptions.module.rules[2].use should be objectoptions.module.rules[2].use should match some schema in anyOfoptions.module.rules[2].use[0] should match some schema in anyOfoptions.module.rules[2].use[0] should be stringoptions.module.rules[2].use[0] should pass "instanceof" keyword validationoptions.module.rules[2].use[0] should match some schema in anyOfoptions.module.rules[2].use[0].loader should be stringoptions.module.rules[2].use[0].loader should match some schema in anyOf rules[2]配置错误，不能为数组，只能为字符串解决方案：将原代码 12345678&#123; test: /\.css$/, use: [ &#123; loader: ['style-loader', 'css-loader'] &#125; ]&#125;, 更改为： 123456789101112&#123; test: /\.css$/, use: [ &#123; loader: 'style-loader', // loader: ['style-loader', 'css-loader'] &#125;, &#123; loader: 'css-loader', &#125; ]&#125;, 或者更改为： 1234&#123; test: /\.css$/, use: ['style-loader', 'css-loader']&#125;, 2.vue-loader插件显性引入 123Error1: Module Error (from ./node_modules/vue-loader/lib/index.js):vue-loader was used without the corresponding plugin.Make sure to include VueLoaderPlugin in your webpack config. webpack4.X更新之后，需要显性引入vue-loader插件解决方案：const VueLoaderPlugin = require(&#39;vue-loader/lib/plugin&#39;);详见vue-loader 3.vue-template-compiler需要作为单独的依赖 123Error2: Module build failed (from ./node_modules/vue-loader/lib/index.js):Error: [vue-loader] vue-template-compiler must be installed as a peer dependency,or a compatible compiler implementation must be passed via options. 解决方案：npm i -D vue-template-compiler 应用vue-router安装依赖：npm i -D vue-router main.js入口文件中，新建vue实例，参数中传入router，components，template 12345678910111213import Vue from 'vue'import App from './App'import router from './router'Vue.config.productionTip = false/* eslint-disable no-new */new Vue(&#123; el: '#app', router, components: &#123; App &#125;, template: '&lt;App/&gt;'&#125;) app.vue使用 router-link 组件来导航。通过传入 to 属性指定链接，&lt;router-link&gt; 默认会被渲染成一个 &lt;a&gt; 标签。&lt;router-view/&gt; 为路由出口，路由匹配到的组件将渲染在这里 12345678910111213&lt;template&gt;&lt;div&gt; &lt;h1&gt;你好&lt;/h1&gt; &lt;router-link to=&quot;/helloworld&quot;&gt;欢迎&lt;/router-link&gt; &lt;router-view/&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;name: &apos;App&apos;&#125;&lt;/script&gt; routerrouter定义了跳转路由渲染的组件 12345678910111213141516171819202122import Vue from 'vue';import Router from 'vue-router';import HelloWorld from '@/components/HelloWorld';import Home from '@/components/Home';Vue.use(Router);export default new Router(&#123; mode: 'history', routes: [ &#123; path: '/', name: 'Home', component: Home &#125;, &#123; path: '/helloworld', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) 问题解决 vue使用template时更改vue使用模块 12345vue.runtime.esm.js:588 [Vue warn]:You are using the runtime-only build of Vuewhere the template compiler is not available.Either pre-compile the templates into render functions,or use the compiler-included build. 运行时构建不包含模板编译器，因此不支持 template 选项，只能用 render 选项，但即使使用运行时构建，在单文件组件中也依然可以写模板，因为单文件组件的模板会在构建时预编译为 render 函数。运行时构建比独立构建要轻量30%，只有 17.14 Kb min+gzip大小。就是说，如果我们想使用template，我们不能直接在客户端使用npm install之后的vue。 此时，再去看查vue模块，在webpack配置文件添加: 12345678module.exports = &#123; // 省略... resolve: &#123; alias: &#123; 'vue': 'vue/dist/vue.js' &#125; &#125;,&#125; 2.默认的代码目录使用@替换，webpack配置文件添加： 123456789module.exports = &#123; // 省略... resolve: &#123; alias: &#123; 'vue': 'vue/dist/vue.js', '@': path.resolve(__dirname,'src') &#125; &#125;&#125; 3.引入文件必须加后缀，否则报错，webpack配置文件添加： 1234567891011module.exports = &#123; // 省略... resolve: &#123; alias: &#123; 'vue': 'vue/dist/vue.js', '@': path.resolve(__dirname,'src'), &#125;, // 引入文件可不加后缀 extensions: ['.js', '.vue', '.json'] &#125;&#125; 4.HTML inject有四个值： true body head false true 默认值，script标签位于html文件的 body 底部body script标签位于html文件的 body 底部head script标签位于html文件的 head中false 不插入生成的js文件，这个几乎不会用到的 12345678const htmlWebpackPlugin = require('html-webpack-plugin');plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;),],]]></content>
      <categories>
        <category>front</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽的实现]]></title>
    <url>%2F2017%2F10%2F13%2Fdrag-and-drop%2F</url>
    <content type="text"><![CDATA[12.5更新 拖拽前端经常使用拖拽进行图片上传，那么拖拽是如何实现的呢？使用拖拽基本过程如下：首先定义哪些元素是可拖动的，在鼠标左键点击一个可拖动元素进行拖拽；拖拽元素进行移动，拖拽元素的位置发生改变，可以通过绝对定位实现；鼠标释放拖拽元素。 HTML5实现拖拽删除元素实例12&lt;div id="main"&gt;垃圾桶&lt;/div&gt;&lt;div id="test-drag" draggable="true"&gt;拖拽元素区域:拖拽到垃圾桶中删除&lt;/div&gt; Javascript代码： 123456789101112131415161718192021222324252627282930313233343536var dragElement = document.getElementById("test-drag");var targetElement = document.getElementById("main");//拖动对象操作dragElement.ondragstart = function (event) &#123; console.log("开始拖拽"); event.dataTransfer.setData("deleteDiv", this.id);&#125;;dragElement.ondrag = function () &#123; console.log("拖动中");&#125;;dragElement.ondragend = function () &#123; console.log("拖动结束");&#125;;//目标对象操作targetElement.ondragenter = function () &#123; console.log("拖拽对象进入");&#125;;targetElement.ondragleave = function () &#123; console.log("拖拽对象离开");&#125;;targetElement.ondragover = function (event) &#123; console.log("拖拽对象在目标对象上"); event.preventDefault(); //必须阻止默认事件，否则无法触发ondrop&#125;;targetElement.ondrop = function (event) &#123; console.log("拖拽对象松手释放在目标对象上"); var deleteDivId = event.dataTransfer.getData("deleteDiv"); //得到数据--id值 var deleteDiv = document.getElementById(deleteDivId); //根据id值找到相关的元素 deleteDiv.parentNode.removeChild(deleteDiv); //从父元素中删除子节点 &#125;; API可拖拽对象通过设置draggable属性draggable：true 表明可拖拽draggable：false 表明元素不可拖拽draggable：auto 默认，只有img图片,a链接,input文字选中三种情况可拖拽 拖拽对象APIdragstart:可拖拽元素拖拽开始时触发drag:可拖拽元素拖拽触发dragend:可拖拽元素拖拽结束时触发 目标对象APIdragenter:可拖拽元素进入目标放置区域触发dragexit:可拖拽元素不再是拖动操作的直接选择目标。dragleave:可拖拽元素离开目标放置区域触发dragover:可拖拽元素在目标放置区域移动时触发drop:可拖拽元素在目标放置区域放置时触发 注意：dragenter和dragover事件的默认行为是不允许被拖拽元素在其他元素上释放或放置（即无法触发drop事件），需要通过 event.preventDefault()或者return false来阻止默认行为才能触发后续的drop事件。（实测只需要dragover事件阻止默认事件） event.dataTransfer对象属性 DataTransfer对象用于在配置拖拽行为效果，并且在拖拽过程的各事件间传递数据信息。它存储在事件对象当中，下面我们逐步了解它吧。 [object DragEvent]对象继承自[object MouseEvent] 对象，其实就多了个{DataTransfer} dataTransfer属性 [object DataTransfer]对象详解上文说到DataTransfer对象可用于传递数据信息，而数据信息的数据类型被限定为字符串和文件类型 effectAllowed和dropEffect属性这个两个属性对于初次接触DnD的朋友来说，可谓最令人摸不着头脑的，网上和各书籍上对这两个属性的解释均不全面，下面我试图尽量把它们讲明白effectAllowed和dropEffect最主要的作用是，用于配置拖拽操作过程中鼠标指针的类型以便提示用户后续可执行怎样的操作；其次的作用是，控制 drop 事件的触发与否。 effectAllowed作用：用于设置被拖拽元素可执行的操作。取值范围：copy ，限定dropEffect的属性值为copy，否则会鼠标指针为禁止样式link ，限定dropEffect的属性值为link，否则会鼠标指针为禁止样式move ，限定dropEffect的属性值为move，否则会鼠标指针为禁止样式copyLink ，限定dropEffect的属性值为copy和link，否则会鼠标指针为禁止样式copyMove ，限定dropEffect的属性值为copy和move，否则会鼠标指针为禁止样式linkMove ，限定dropEffect的属性值为link和move，否则会鼠标指针为禁止样式all，允许dropEffect的属性值为任意值none，鼠标指针一直为禁止样式，不管dropEffect的属性值是什么uninitialized，没有限定dropEffect属性的值，效果和all一样。 注意：仅能在dragstart事件中设置该属性，其他事件中设置均无效。 dropEffect作用：用于设置目标元素将执行的操作，若属性值属于effectAllowed范围内，则鼠标指针将显示对应的指针样式，否则则显示禁止的指针样式。取值范围：copy：被拖拽元素将被复制到目标元素内，若属于effectAllowed范围内时，则鼠标指针显示复制的样式，否则则显示禁止的指针样式。link被拖拽元素将以超链接的形式打开资源（具体是否打开资源请参考七、2），若属于 effectAllowed范围内时，则鼠标指针显示超链接的样式，否则则显示禁止的指针样式。move：被拖拽元素将被移动到目标元素内，若属于effectAllowed范围内时，则鼠标指针显示移动的样式，否则则显示禁止的指针样式。none：被拖拽元素不能在目标元素上作任何操作，一直显示禁止的指针样式。除了文本框外其他元素的默认值均为none 注意： 仅能在dragover事件中设置该属性值，其他事件中设置均无效 当显示禁止的指针样式时，将无法触发目标元素的 drop 事件。 方法 DataTransfer.getData()获取DataTransfer对象中的一个数据 DataTransfer.setData()在DataTransfer对象中添加一个数据 DataTransfer.clearData()在DataTransfer对象中删除一个数据 拖拽过程在上述实例中，我们使用HTML5 drap和drop实现了一个拖拽一个元素到指定区域中进行删除。HTML5新增drag事件以方便解决拖拽问题。首先，在这个过程中我们要定义一个可拖拽元素，对拖拽添加属性draggable=&quot;true&quot;即可定义该元素为可拖拽对象。第二，在拖拽元素开始后，可以通过drag事件的dataTransfer对象进行数据的传递。可设置数据来传递文件等。在上述例子中event.dataTransfer.setData()传递被删除元素的ID。第三，放置拖拽元素，通常情况下页面元素为不可放置拖拽元素区域。放置拖拽元素是通过对目标元素的drop事件实现，但是只有目标元素dragenter和dragover的触发事件最后必须通过取消事件来防止默认处理，即为return false或阻止默认事件event.preventDefault()，则该目标元素才为可放置拖拽元素区域，drop事件才会被触发。否则不会触发drop事件。 JS实现裁剪预览操作实例参考文献 请教js实现拖拽上传图片的实现思路 使用 JavaScript 实现简单的拖拽 HTML Drag and Drop API -HTML5魔法堂：全面理解Drag &amp; Drop API]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>drag</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现水平垂直居中]]></title>
    <url>%2F2017%2F09%2F25%2Fcss-all-center%2F</url>
    <content type="text"><![CDATA[44年前我们把人送上月球，但在CSS中我们仍然不能很好实现垂直居中——@James Anderson 让一个元素水平居中对于CSS来说非常简单：如果是一个内联元素，我们可以在他的父元素上设置text-align:center;，如果是一个块元素，我们可以使用margin:auto;。然而，只要一想到让一个元素垂直居中，让人死的心都有了。 多年来，垂直居中已成为CSS的不朽神话，也是前端专业人士群体中的一个内部笑话。原因是： 经常需要使用 理论上看上去非常简单 过去实战中要实现是极其困难，特别是元素大小固定时 方法一：绝对定位实现过程123456&lt;div class="container"&gt; &lt;h2&gt;完全居中--1.绝对定位&lt;/h2&gt; &lt;div class="center"&gt; 内容盒子 &lt;/div&gt;&lt;/div&gt; 1234567891011121314.container&#123; position:relative; height:200px; width: 400px; background-color: rgba(0,0,255,0.2);&#125;.center&#123; height: 100px; width: 100px; position:absolute; margin:auto; top:0;left:0;bottom:0;right:0; background-color: rgba(255,255,0,1);&#125; 参见 DEMO:完全居中–1.绝对定位 方法二：绝对定位+负margin这或许是最常用的方法。如果知道了各个元素的大小，设置等于宽高一半大小的负margin值（如果没有使用box-sizing: border-box样式，还需要加上padding值），再配合top: 50%; left: 50%;样式就会使块元素居中。 给容器设置绝对定位（position:absolute）,并且定位高度（top:50%）和margin-top为高度的一半（margin-top:-height/2），宽度设置类似。 这就意味着使用这种方法来实现垂直居中的效果，那么元素必须要有一个固定的高度。这样一来，给元素设置了固定高度，如果又设置了overflow:auto，那么当元素内容超过容器后，这样元素的就会出现滚动，而不会自适应内容的高度。 实现过程123456&lt;div class="container"&gt; &lt;h2&gt;完全居中--2.绝对定位+负margin值&lt;/h2&gt; &lt;div class="center"&gt; 内容盒子 &lt;/div&gt;&lt;/div&gt; 12345678910111213141516.container&#123; position:relative; height:200px; width: 400px; background-color: rgba(0,0,255,0.2);&#125;.center&#123; height: 100px; width: 100px; position:absolute; top: 50%; margin-top:-50px; left: 50%; margin-left:-50px; background-color: rgba(255,255,0,1);&#125; 如果使用CSS3中的calc()可以减少两个样式：12345678.center&#123; height:100px; width:100px; position:absolute; top:calc(50% - 50px);/* calc中的`+` `-` 必须被空格包围，`*` `/` 则不需要*/ left:calc(50% - 50px); background-color: rgba(255,255,0,1);&#125; 参见DEMO:完全居中–2.绝对定位+负margin值 优点 浏览器兼容性非常好，甚至支持IE6-7 需要的编码量很少缺点 这是个非响应式的方法，不能使用百分比的大小，也不能设置min-/max-的最大值最小值。 内容可能会超出容器 需要为padding预留空间，或者需要使用box-sizing: border-box样式。 方法三：模拟表格这种可能是最好的方法，因为高度可以随内容改变，浏览器支持也不差。主要缺陷是会产生额外的标签，每一个需要居中的元素需要三个额外的HTML标签。 实现过程设置父元素display:table，子元素display:table-cell; vertical-align:middle12345&lt;div class="table"&gt; &lt;div class="table-cell"&gt; &lt;div class="content"&gt;完全居中--3.模拟表格&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516.table&#123; display:table; width:600px; height:300px;&#125;.table-cell&#123; display:table-cell; vertical-align: middle; background-color: rgba(255,0,0,0.3); &#125;.content&#123; width:50%; height:50%; margin:0 auto; background-color: rgba(0,255,0,0.5); &#125; 参见DEMO:完全居中–3.模拟表格 优点 内容高度可变 内容溢出则能自动撑开父元素高度 浏览器兼容性好 缺点 需要额外的HTML标签 方法四：inline-box基本方法是使用display: inline-block,vertical-align: middle样式和伪元素让内容块在容器中居中。 实现过程123456&lt;div class="container"&gt; &lt;h2&gt;完全居中--4.inline-block&lt;/h2&gt; &lt;div class="center"&gt; 内容盒子 &lt;/div&gt;&lt;/div&gt; 12345678910111213.container&#123; width:600px; height:200px; text-align:center; background-color: rgba(0,0,255,0.2);&#125;.center&#123; width:50%; height:50%; display:inline-block; vertical-align:middle; background-color: rgba(255,255,0,1);&#125; 参见完全居中–4.inline-block 优点 内容高度可变 内容溢出则能自动撑开父元素高度 浏览器兼容性好，甚至可以调整支持IE7缺点 需要额外容器 依赖于margin-left: -0.25em的样式，做到水平居中，需要为不同的字体大小作调整内容区声明的宽度不能大于容器的100% 减去0.25em的宽度 方法五：transform(CSS3)为内容指定带有厂商前缀的transform: translate(-50%,-50%)和top: 50%; left: 50%;样式就可以让内容块居中。 实现过程123456&lt;div class="container"&gt; &lt;h2&gt;完全居中--5.transform&lt;/h2&gt; &lt;div class="center"&gt; 内容盒子 &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.container&#123; width:600px; height:200px; position:relative; background-color: rgba(0,0,255,0.2);&#125;.center&#123; position:absolute; width:50%; height:50%; top:50%; left:50%; -webkit-transform: translate(-50%,-50%); -ms-transform: translate(-50%,-50%); transform: translate(-50%,-50%); background-color: rgba(255,255,0,1);&#125; 参见DEMO:完全居中–5.transform 优点 内容高度可变 代码量小缺点 不支持IE8 需要写厂商前缀 会和其他transform样式有冲突 某些情况下的边缘和字体渲染会有问题 方法六：flex(CSS3)CSS未来发展的方向就是采用Flexbox这种设计，解决像垂直居中这种共同的问题。请注意，Flexbox有不止一种办法居中，他也可以用来分栏，并解决奇奇怪怪的布局问题。 实现过程123456&lt;div class="container"&gt;&lt;!-- &lt;h2&gt;完全居中--5.flex&lt;/h2&gt; --&gt; &lt;div class="center"&gt; 内容盒子 &lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728.container&#123; width:600px; height:200px; display: -webkit-box; display: -moz-box; display: -ms-flexbox; display: -webkit-flex; display: flex; -webkit-box-align: center; -moz-box-align: center; -ms-flex-align: center; -webkit-align-items: center; align-items: center; -webkit-box-pack: center; -moz-box-pack: center; -ms-flex-pack: center; -webkit-justify-content: center; justify-content: center; background-color: rgba(0,0,255,0.2);&#125;.center&#123; width:50%; height:50%; background-color: rgba(255,255,0,1);&#125; 优点 内容可以是任意高宽，溢出也能表现良好 可以用于各种高级布局技巧缺点 不支持IE8-9 需要在body上写样式，或者需要额外容器 需要各种厂商前缀兼容现代浏览器 可能有潜在的性能问题 完全居中对照表 所用样式 支持的浏览器 是否响应式 内容溢出后的样式 resize:both 高度可变 主要缺陷 absolute 现代浏览器&amp;IE8+ 是 会导致容器溢出 是 是* ‘可变高度’的特性不能跨浏览器 负margin值 所有 否 带滚动条 大小改变后不再居中 否 不具有响应式特性，margin值必须经过手工计算 transform 现代浏览器&amp;IE9+ 是 会导致容器溢出 是 是 妨碍渲染 table-cell 现代浏览器&amp;IE8+ 是 撑开容器 否 是 会加上多余的标记 inline-block 现代浏览器&amp;IE8+&amp;IE7* 是 撑开容器 否 是 需要使用容器包裹和hack式的样式 flex 现代浏览器&amp;IE10+ 是 会导致容器溢出 是 是 需要使用容器包裹和厂商前缀（vendor prefix） 参考文献 如何只用CSS做到完全居中 CSS秘密花园： 垂直居中]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>水平居中</tag>
        <tag>垂直居中</tag>
        <tag>完全居中</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器总结]]></title>
    <url>%2F2017%2F09%2F25%2Fcss-selector%2F</url>
    <content type="text"><![CDATA[选择器是匹配元素的一种模式，不只是在CSS中，JavaScript对CSS的选择器也是支持的，比如document.querySelector( )和document.querySelectorAll( )。 选择器类型基本选择器 通配符选择器( * ) id选择器( \#ID ) 类选择器( .className ) 元素选择器( E ) 后代选择器( E F ) 子元素选择器( E&gt;F ) 相邻兄弟元素选择器( E + F ) 群组选择器( selector1,selector2,...,selectorN ) 属性选择器使用CSS3属性选择器，你可以只指定元素的某个属性，或者你还可以同时指定元素的某个属性和其对应的属性值。 E[attr]：只使用属性名，但没有确定任何属性值E[attr=&quot;value&quot;]：指定属性名，并指定了该属性的属性值E[attr~=&quot;value&quot;]：指定属性名，并且具有属性值，此属性值是一个词列表，并且以空格隔开，其中词列表中包含了一个value词，而且等号前面的~不能不写E[attr^=&quot;value&quot;]：指定了属性名，并且有属性值，属性值是以value开头的；E[attr$=&quot;value&quot;]：指定了属性名，并且有属性值，而且属性值是以value结束的；E[attr*=&quot;value&quot;]：指定了属性名，并且有属性值，而且属值中包含了value；E[attr|=&quot;value&quot;]：指定了属性名，并且属性值是value或者以“value-”开头的值( 比如说zh-cn ); 伪类选择器伪类选择器的形式就是:xxx， 比如:hover, :link, :nth。 动态伪类这些伪类并不存在于HTML中,而只有当用户和网站交互的时候才能体现出来.动态伪类包含两种，第一种是我们在链接中常看到的锚点伪类，如:link,:visited;另外一种被称作用户行为伪类，如:hover,:active和:focus。 锚点伪类锚点伪类爱恨原则（LoVe/HAte）为了可以正确地渲染链接元素的样式，:link伪类选择器应当放在其他伪类选择器的前面，并且遵循LVHA的先后顺序，即：:link — :visited — :hover — :active。 :link:link伪类选择器是用来选中元素当中的链接。它将会选中所有尚未访问的链接，包括那些已经给定了其他伪类选择器的链接（例如:hover选择器，:active选择器，:visited选择器）。 :visited:link伪类选择器是用来选中所有已访问过的链接 用户行为伪类:hover: 用于当用户把鼠标移动到元素上面时的效果:active: 用于用户点击元素那一下的效果( 正发生在点的那一下，松开鼠标左键此动作也就完成了 ):focus: 用于元素成为焦点，这个经常用在表单元素上 UI元素状态伪类我们把:enabled,:disabled,:checked伪类称为UI元素状态伪类，这些主要是针对于HTML中的Form元素操作。最常见的比如我们”type=”text”有enable和disabled两种状态，前者为可写状态后者为不可状态；另外”type=”radio”和”type=”checkbox”有checked和unchecked两种状态。IE6-8不支持:checked,:enabled,:disabled这三种选择器。 CSS3的:nth选择器需要注意的是CSS3添加的nth选择器在IE8下不支持。 :first-child选择某个元素的第一个子元素； :last-child选择某个元素的最后一个子元素； :nth-child()选择某个元素的一个或多个特定的子元素； :nth-last-child()选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； :nth-of-type()选择指定的元素； :nth-last-of-type()选择指定的元素，从元素的最后一个开始计算； :first-of-type选择一个上级元素下的第一个同类子元素； :last-of-type选择一个上级元素的最后一个同类子元素； :only-child选择的元素是它的父元素的唯一一个了元素； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素； :empty选择的元素里面没有任何内容。 选择器权重权重，也就是选择器的优先级，每条选择器的规则都有其权重，权重大的会覆盖掉权重小的，很多CSS出现问题的场景，都是某处定义了一个更高权重的规则，导致此处规则不生效。 权重的计算通过这篇文章你应该知道的一些事情——CSS权重。了解下权重的计算，主要的规则就是:id选择器 &gt; 类，属性选择器和伪类选择器 &gt; 元素和伪元素需要注意的是!improtant,凡是属性值后加上了!important，那么它的值不会被其他值替换。 根据样式所在位置，对元素的影响也有关系：内联样式( 标签内style形式 ) &gt; style标签 &gt; link标签。 CSS解析器HTML 经过解析生成 DOM Tree；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render tree，最终用来进行绘图。Render tree 中的元素( WebKit 中称为renderers，Firefox 下为frames )与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个renderer，如文本折行后，不同的行会成为 Render tree 中不同的renderer。也有的 DOM 元素被 Render tree 完全无视，比如display:none的元素。 在建立 Render tree 时( WebKit 中的Attachment过程 )，浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果( Style Rules )来确定生成怎样的renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的selector并将对应的规则进行合并。选择器的解析实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的selector。 解析顺序–从右到左原则浏览器读取你的选择器，遵循的原则是从选择器的右边到左边读取。换句话说，浏览器读取选择器的顺序是由右到左进行著作权归作者所有，即选择器从右到左的原则。 CSS匹配不是从左到右进行查找，而是从右到左进行查找。如果从左到右的顺序，那么每条选择器都需要遍历整个DOM树，性能很受影响。所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找。 选择器的最后一部分，也就是选择器的最右边部分被称为“关键选择器”，它将决定你的选择器的效率如何？是高还是低。 选择器优化选择器效率 id选择器（#myid） 类选择器（.myclassname） 标签选择器（div,h1,p） 相邻选择器（h1+p） 子选择器（ul &gt; li） 后代选择器（li a） 通配符选择器（*） 属性选择器（a[rel=&quot;external&quot;]） 伪类选择器（a:hover,li:nth-child） id和类名用于关键选择器上效率是最高的，而CSS3的仿伪类和属性选择器，虽然使用方便，但其效率却是最低的。 几种书写高效率的CSS选择器 避免普遍规则 不要在ID选择器前加标签名或类名 不要在类名选择器前加标签名 尽可能使用具体的类别 避免使用后代选择器 标签分类规则中不应该包含一个子选择器 子选择器的问题 借助相关继承关系 使用范围内的样式表 附CSS选择器图： 参考文献 CSS选择器 CSS选择器的优化 CSS3 选择器——伪类选择器 Writing efficient CSS selectors]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css解析器</tag>
        <tag>css选择器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS清除浮动/闭合浮动]]></title>
    <url>%2F2017%2F09%2F24%2Fcss-clearfix%2F</url>
    <content type="text"><![CDATA[参见那些年我们一起清除过的浮动 浮动文档流: 文档流是文档中可显示对象在排列时所占用的位置。浮动的定义: 使元素脱离文档流，按照指定方向发生移动，遇到父级边界或者相邻的浮动元素停了下来。 浮动的实际用途，可设置文字环绕或使元素宽度由内容填充（类似inline-block)。使用浮动需要注意的是如果浮动的元素高度比父级容器还高，那么需要设置父级容器的overflow属性为auto,使其自动撑满。 清除浮动还是闭合浮动（Enclosing float or Clearing float） 很多人都已经习惯称之为清除浮动，以前我也一直这么叫着，但是确切地来说是不准确的。我们应该用严谨的态度来对待代码，也能更好地帮助我们理解开头的三个问题。1）清除浮动: 清除对应的单词是clear，对应CSS中的属性是clear: left | right | both | none；2）闭合浮动: 更确切的含义是使浮动元素闭合，从而减少浮动带来的影响。通过以上实例发现，其实我们想要达到的效果更确切地说是闭合浮动，而不是单纯的清除浮动，在footer上设置clear: both清除浮动并不能解决wrap高度塌陷的问题。结论: 用闭合浮动比清除浮动更加严谨，所以后文中统一称之为: 闭合浮动。参见DEMO: 高度塌陷 为何要闭合浮动？要解答这个问题，我们得先说说CSS中的定位机制: 普通流，浮动，绝对定位 （其中position:fixed是position:absolute的一个子类）。1）普通流: 很多人或者文章称之为文档流或者普通文档流，其实标准里根本就没有这个词。如果把文档流直译为英文就是document flow，但标准里只有另一个词，叫做普通流（normal flow)，或者称之为常规流。但似乎大家更习惯文档流的称呼，因为很多中文翻译的书就是这么来的。比如《CSS Mastery》，英文原书中至始至终都只有普通流normal flow（普通流） 这一词，从来没出现过document flow （文档流）2）浮动: 浮动的框可以左右移动，直至它的外边缘遇到包含框或者另一个浮动框的边缘。浮动框不属于文档中的普通流，当一个元素浮动之后，不会影响到块级框的布局而只会影响内联框（通常是文本）的排列，文档中的普通流就会表现得和浮动框不存在一样。当浮动框高度超出包含框的时候，也就会出现包含框不会自动伸高来闭合浮动元素（“高度塌陷”现象）。顾名思义，就是漂浮于普通流之上，像浮云一样，但是只能左右浮动。正是因为浮动的这种特性，导致本属于普通流中的元素浮动之后，包含框内部由于不存在其他普通流元素了，也就表现出高度为0（高度塌陷）。在实际布局中，往往这并不是我们所希望的，所以需要闭合浮动元素，使其包含框表现出正常的高度。 闭合浮动的原理——了解hasLayout和Block formatting contexts清除浮动的方式1）添加额外标签这是在学校老师就告诉我们的 一种方法，通过在浮动元素末尾添加一个空的标签例如&lt;div style=”clear:both”&gt;&lt;/div&gt;，其他标签&lt;br&gt;等亦可。 1234567&lt;div class="wrap" id="float1"&gt; &lt;h2&gt;1）添加额外标签&lt;/h2&gt; &lt;div class="main left"&gt;.main&#123;float:left;&#125;&lt;/div&gt; &lt;div class="side right"&gt;.side&#123;float:right;&#125;&lt;/div&gt; &lt;div style="clear:both;"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="footer"&gt;.footer&lt;/div&gt; 参见DEMO: 清除浮动clear:both–空div优点: 通俗易懂，容易掌握缺点: 可以想象通过此方法，会添加多少无意义的空标签，有违结构与表现的分离，在后期维护中将是噩梦，这是坚决不能忍受的，所以你看了这篇文章之后还是建议不要用了吧。 2）使用br标签和其自身的html属性这个方法有些小众，br有clear=“all | left | right | none”属性 1234567&lt;div class="wrap" id="float2"&gt; &lt;h2&gt;2）使用 br标签和其自身的 html属性&lt;/h2&gt; &lt;div class="main left"&gt;.main&#123;float:left;&#125;&lt;/div&gt; &lt;div class="side right"&gt;.side&#123;float:right;&#125;&lt;/div&gt; &lt;br clear="all" /&gt;&lt;/div&gt;&lt;div class="footer"&gt;.footer&lt;/div&gt; 参见DEMO: 清除浮动clear:both–br优点: 比空标签方式语义稍强，代码量较少缺点: 同样有违结构与表现的分离，不推荐使用 3) 父元素设置overflow:hidden通过设置父元素overflow值设置为hidden；在IE6中还需要触发hasLayout，例如zoom: 1； 123456&lt;div class="wrap" id="float3" style="overflow:hidden; *zoom:1;"&gt; &lt;h2&gt;3)父元素设置 overflow &lt;/h2&gt; &lt;div class="main left"&gt;.main&#123;float:left;&#125;&lt;/div&gt; &lt;div class="side right"&gt;.side&#123;float:right;&#125;&lt;/div&gt;&lt;/div&gt;&lt;div class="footer"&gt;.footer&lt;/div&gt; 参见DEMO:清除浮动–父元素设置overflow:hidden优点: 不存在结构和语义化问题，代码量极少缺点: 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素；04年POPO就发现overflow:hidden会导致中键失效,所以还是不要使用了。 4) 父元素设置overflow:auto属性同样IE6需要触发hasLayout，演示和3差不多参见DEMO:清除浮动–父元素设置overflow:auto优点: 不存在结构和语义化问题，代码量极少缺点: 多个嵌套后，firefox某些情况会造成内容全选；IE中mouseover造成宽度改变时会出现最外层模块有滚动条等，firefox早期版本会无故产生focus等,不要使用 5）父元素也设置浮动优点: 不存在结构和语义化问题，代码量极少缺点: 使得与父元素相邻的元素的布局会受到影响，不可能一直浮动到body，不推荐使用 6）父元素设置display:table参见DEMO:清除浮动–父元素设置display:table优点: 结构语义化完全正确，代码量极少缺点: 盒模型属性已经改变，由此造成的一系列问题，得不偿失，不推荐使用 7）使用::after伪元素需要注意的是::after是伪元素（Pseudo-Element），不是伪类（某些CSS手册里面称之为“伪对象”），很多闭合浮动大全之类的文章都称之为伪类，不过csser要严谨一点，这是一种态度。由于IE6-7不支持::after，使用zoom:1触发hasLayout。 该方法源自于:How To Clear Floats Without Structural Markup原文全部代码如下: 12345678910111213141516171819202122&lt;style type="text/css"&gt; .clearfix::after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125;&lt;/style&gt;&lt;!-- main stylesheet ends, CC with new stylesheet below... --&gt;&lt;!--[if IE]&gt;&lt;style type="text/css"&gt; .clearfix &#123; zoom: 1; /* triggers hasLayout */ &#125; /* Only IE can see inside the conditional commentand read this CSS rule. Don't ever use a normal HTMLcomment inside the CC or it will close prematurely. */&lt;/style&gt;&lt;![endif]--&gt; 鉴于 IE/Mac的市场占有率极低,我们直接忽略掉,最后精简的代码如下: 1234567891011121314&lt;style type="text/css"&gt; .clearfix::after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123; *zoom:1; &#125;&lt;/style&gt; 参见DEMO:清除浮动–父元素设置::after伪元素 清除浮动方式总结通过对比，我们不难发现，其实以上列举的方法，无非有两类: 利用clear属性清除浮动其一，通过在浮动元素的末尾添加一个空元素，设置clear: both属性，::after伪元素其实也是通过content在元素的后面生成了内容为一个点的块级元素； 当clear应用于非浮动元素时，它将非浮动元素的边框边界移动到所有相关浮动元素外边界的下方。这个行为作用时会导致margin collapsing不起作用。当clear应用于浮动元素时，它将元素的外边界移动到所有相关的浮动元素外边界的下方。这会影响后面浮动元素的布局，后面的浮动元素的位置无法高于它之前的元素。要被清除的相关浮动元素指在相同BFC中的前置浮动。 使父容器形成BFC其二，通过设置父元素overflow或者display: table属性来闭合浮动 清除浮动/闭合浮动原理在CSS2.1里面有一个很重要的概念，但是国内的技术博客介绍到的比较少，那就是Block formatting contexts （块级格式化上下文），以下简称 BFC。CSS3里面对这个规范做了改动，称之为: flow root，并且对触发条件进行了进一步说明。 BFC特性1) BFC会阻止垂直外边距叠加当两个相邻的块框在同一个BFC中时，只要他们之间没有阻挡（边框，非空内容，padding等），它们之间垂直方向的外边距会发生叠加。换句话说，如果这两个相邻的块框不属于同一个BFC，那么它们的外边距就不会叠加。对于相邻两个元素意义不大，没有必要给他们加一个外壳。但是对于嵌套元素来说就很有必要了，只要把父元素设置为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了。 2) BFC不会重叠浮动元素根据规定，一个BFC的边框不能和它里面的元素的外边距重叠。这就意味着浏览器将会给块级格式化上下文创建隐式的外边距来阻止它和浮动元素的外边距叠加。由于这个原因，当给一个挨着浮动的块级格式化上下文添加负的外边距时将会不起作用（Webkit和IE6在这点上有一个问题——可以看这个测试用例）。 3) BFC可以包含浮动利用这三条特性我们可以用来闭合浮动，也就是说只要父元素形成BFC就可以。 如何触发BFC 根元素或其它包含它的元素 浮动元素 (元素的float不是none) 绝对定位元素 (元素具有position为absolute或fixed) 内联块 (元素具有display: inline-block) 表格单元格 (元素具有display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有display: table-caption, HTML表格标题默认属性) 具有overflow且值不是visible的块元素(hidden，auto，scroll) display: flow-root column-span: all应当总是会创建一个新的格式化上下文，即便具有column-span: all的元素并不被包裹在一个多列容器中。 fieldset元素 display:table本身并不会创建BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以创建新的BFC，换句话说，触发块级格式化上下文的是匿名框，而不是display:table。所以通过display:table和display:table-cell创建的BFC效果是不一样的。fieldset元素在www.w3.org里目前没有任何有关这个触发行为的信息，直到HTML5标准里才出现。有些浏览器bugs（Webkit，Mozilla）提到过这个触发行为，但是没有任何官方声明。实际上，即使`fieldset`在大多数的浏览器上都能创建新的块级格式化上下文，开发者也不应该把这当做是理所当然的。CSS 2.1没有定义哪种属性适用于表单控件，也没有定义如何使用CSS来给它们添加样式。用户代理可能会给这些属性应用CSS属性，建议开发者们把这种支持当做实验性质的，更高版本的CSS可能会进一步规范这个。 通俗地来说: 创建了BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC仍然属于文档中的普通流。至此，您或许明白了为什么overflow:hidden或者auto可以闭合浮动了，真是因为父元素创建了新的BFC。 hasLayout从表现上来说，hasLayout可以等同于 BFC。IE6-7的显示引擎使用的是一个称为布局（layout）的内部概念，由于这个显示引擎自身存在很多的缺陷，直接导致了IE6-7的很多显示bug。当我们说一个元素“得到 layout”，或者说一个元素“拥有 layout” 的时候，我们的意思是指它的微软专有属性[hasLayout]为此被设为了true。IE6-7使用布局的概念来控制元素的尺寸和定位，那些拥有布局（have layout）的元素负责本身及其子元素的尺寸设置和定位。如果一个元素的hasLayout为false，那么它的尺寸和位置由最近拥有布局的祖先元素控制。 触发hasLayout的条件 position: absolute float: left|right display: inline-block width: 除auto外的任意值 height: 除auto外的任意值(例如很多人闭合浮动会用到 height: 1% ) zoom: 除normal外的任意值 writing-mode: tb-rl 在 IE7 中，overflow也变成了一个 layout 触发器: overflow: hidden|scroll|auto （ 这个属性在IE之前版本中没有触发 layout 的功能。 ） overflow-x|-y: hidden|scroll|auto （CSS3 盒模型中的属性，尚未得到浏览器的广泛支持。他们在之前IE版本中同样没有触发 layout 的功能） 总结在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动；在不支持BFC的浏览器 （IE6-7），通过触发hasLayout闭合浮动。 闭合浮动改进方法上面已经列举了7种闭合浮动的方法，通过第三节分析的原理，我们发现其实更多的: display: table-cell，display: inline-block等只要触发了BFC的属性值都可以闭合浮动。从各个方面比较，::after伪元素闭合浮动无疑是相对比较好的解决方案了，下面详细说说该方法。 伪元素和伪类伪类的操作对象是文档树中已有的元素，而伪元素则创建了一个文档数外的元素。因此，伪类与伪元素的区别在于：有没有创建一个文档树之外的元素。伪元素使用::，伪类使用:。 实现过程12.clearfix::after &#123;content:"."; display:block; height:0; visibility:hidden; clear:both; &#125;.clearfix &#123; *zoom:1; &#125; 1) display:block使生成的元素以块级元素显示,占满剩余空间;2) height:0避免生成内容破坏原有布局的高度。3) visibility:hidden使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;4）通过content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的content:&quot;XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX&quot;,有些版本可能content里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0content:&quot;&quot;仍然会产生额外的空隙；5）zoom: 1触发IE hasLayout。通过分析发现，除了clear: both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size:0，line-height:0。 精益求精方案由Nicolas Gallagher 大湿提出来的,原文:A new micro clearfix hack，该方法也不存在firefox中空隙的问题。 1234567891011/* For modern browsers */.clearfix::before,.clearfix::after &#123; content:""; display:table;&#125;.clearfix::after &#123; clear:both;&#125;/* For IE 6/7 (trigger hasLayout) */.clearfix &#123; zoom:1;&#125; 参见清除浮动–父元素设置::after ::before伪元素 需要注意的是：上面的方法用到了::before伪元素，很多人对这个有些迷惑，到底我什么时候需要用before呢？为什么方案一没有呢？其实它是用来处理margin边距重叠的，由于内部元素float创建了BFC，导致内部元素的margin-top和上一个盒子的margin-bottom发生叠加。如果这不是你所希望的，那么就可以加上before，如果只是单纯的闭合浮动，after就够了！ 参考文献 那些年我们一起清除过的浮动 块格式化上下文 clear]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>浮动</tag>
        <tag>清除浮动</tag>
        <tag>闭合浮动</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP首部字段解析]]></title>
    <url>%2F2017%2F09%2F23%2Fhttp-head%2F</url>
    <content type="text"><![CDATA[HTTP 首部字段HTTP 首部字段作用起传递重要信息的作用。使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。 HTTP 首部字段结构HTTP首部字段是由首部字段名和字段值构成的，中间用冒号:分隔。 四种 HTTP 首部字段类型HTTP首部字段根据实际用途被分为以下四种类型。 通用首部字段（General Header Fields）请求报文和响应报文两方都会使用的首部。 请求首部字段（Request Header Fields）从客户端向服务器端发送请求报文时使用的首部。补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。 响应首部字段（Response Header Fields）从服务器端向客户端返回响应报文时使用的首部。补充了响应的附加内容，也会要求客户端附加额外的内容信息。 实体首部字段（Entity Header Fields）针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。 HTTP/1.1 首部字段一览Http/1.1规范定义了如下47种首部字段。 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 逐跳首部、连接的管理 Date 报文指令 Pragma 控制缓存的行为 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag) If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与If-Match相反） If-Range 资源未更新时发送实体Byte的范围请求 If-Unmodified-Since 比较资源的更新时间（与If-Modified-Since相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中URI的原始获取方 TE 传输编码的优先级 User-Agent HTTP客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的HTTP方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小（单位：字节） Content-Location 替代对应资源的URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 End-to-end 首部和 Hop-by-hop 首部端到端首部（End-to-end Header）分在此类别中的首部会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。 逐跳首部（Hop-by-hop Header）​分在此类别中的首部只对单次转发有效，会因通过缓存或代理而不再转发。HTTP/1.1和之后版本中，如果要使用hop-by-hop首部，需提供Connection首部字段下面列举了HTTP/1.1中的逐跳首部字段。除这8个首部字段之外，其他所有字段都属于端到端首部。12345678ConnectionKeep-AliveProxy-AuthenticateProxy-AuthorizationTrailerTETransfer-EncondingUpgrade 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部。 Cache-Control通过指定首部字段Cache-Control的指令，就能操作缓存的工作机制. ConnectionConnection首部字段具备两个作用。 控制不在转发给代理的首部字段 管理持久连接 控制不在转发给代理的首部字段在客户端发送请求和服务器返回响应内，使用Connection首部字段，可控制不再转发给代理的首部字段（即Hop-by-hop首部）。1connection: 不再转发的首部字段名 管理持久连接HTTP/1.1版本的默认连接都是持久连接。为此，客户端会在持久连接上连续发送请求。当服务器端想明确断开连接时，则指定Connection首部字段的值为Close。1connection: Keep-Alive HTTP/1.1之前的HTTP版本的默认连接都是非持久连接。为此，如果想在旧版本的HTTP协议上维持持续连接，则需要指定Connection首部字段的值为Keep-Alive。 Date首部字段Date表明创建HTTP报文的日期和时间。HTTP/1.1协议使用在RFC1123中规定的日期时间的格式，如下示例。1Date: Tue, 03 Dul 2012 04:40:59 GMT 之前的HTTP协议版本中使用在RFC850中定义的格式，如下所示。1Date: Tue, 03-Dul-12 04:40:59 GMT 除此之外，还有一种格式。它与C标准库内的asctime()函数的输出格式一致。1Date: Tug Dul 03 04:40:59 2012 PragmaPragma是HTTP/1.1之前版本的历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义。所有的中间服务器如果都能以HTTP/1.1为基准，那直接采用Cache-Control:no-cache指定缓存的处理方式是最理想的。但要整体掌握全部中间服务器使用的HTTP协议版本缺失不现实的。因此，发送的请求会同时含有下面两个首部字段。12Cache-Control: no-cachePragma: no-cache Trailer首部字段Trailer会事先说明在报文主体后记录了哪些首部字段。该首部字段可应用在HTTP/1.1版本分块传输编码时。12345678HTTP/1.1 200 OKDate: Tue, 03 Jul 2012 04:40:56 GMTContent-Type: text/htmlTransfer-Encoding: chunkedTrailer: Expires(报文主体）0Expires: Tue, 28 Sep 2004 23:59:59 GMT 以上用例中，指定首部字段Trailer的值为Expires，在报文主体之后(分块长度0之后）出现了首部字Expires。 Transfer-Encoding首部字段Transfer-Encoding规定了传输报文主体时采用的编码方式。HTTP/1.1的传输编码仅对分块传输编码有效。 Upgrade首部字段Upgrade用于检测HTTP协议以及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议。 Via使用首部字段Via是为了追踪客户端与服务器之间的请求和响应报文的传输路径。报文经过代理或网关时，会先在首部字段Via中附加该服务器的信息，然后再进行转发。 WarningHTTP/1.1的Warning首部是从HTTP/1.0的响应首部（Retry-After）演变过来的。该首部通常会告知用户一些与缓存相关的问题的警告。1Warning: 113 gw.hackr.jp:8080 &quot;Heuristic expiration&quot; Tue, 03 Warning首部的格式如下。最后的日期时间部分可省略1Warning:[警告码][警告的主机:端口号]“[警告内容]”（[日期时间]) 警告码 警告内容 说明 110 Response is stale (响应已过期） 代理返回己过期的资源 111 Revalidation failed (再验证失败）） 代理再验证资源有效性时失败（服务器无法到达等原因） 112 Disconnection operation (断开连接操作） 代理与互联网连接被故意切断 113 Heuristic expiration (试探性过期） 响应的使用期超过24小时（有效缓存的设定时间大于24小时的情况下） 199 Miscellaneous warning (杂项警告） 任意的警告内容 214 Transformation applied (使用 了转换） 代理对内容编码或媒体类型等执行了某些处理时 299 Miscellaneous persistent warning (持久杂项警告 任意的警告内容 请求首部字段请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。 AcceptAccept首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用type/subtype这种形式，一次指定多种媒体型。 文本文件12text/html, text/plain, text/css ...application/xhtml+xml, application/xml... 图片文件1image/jpeg, image/gif，image/png ... 视频文件1video/mpeg, video/quicktime ... 应用程序使用的二进制文件1application/octet-stream, application/zip ... 当服务器提供多种内容时，将会首先返回权重值（权重值用q表示，默认为1.0，取值0~1，如:q=1.0）最高的媒体类型。 Accept-Charset1Accept-Charset: iso-8859-5, Unicode-1-1;q=0.8 Accept-Charset首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段Accept相同的是可用权重q值来表示相对优先级。 Accept-Encoding1Accept-Encoding: gzip, deflate Accept-Encoding首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。 gzip compress deflate identity Accept-Language1Accept - Language: zh-cn., zh;q=0.7^en-us^en;q=0.3 首部字段Accept-Language用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。 Authorization1Authorization: Basic dWVub3NlbjpwYXNzd29yZA== 首部字段Authorization是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401状态码响应后，把首部字段Authorization加入请求中。共用缓存在接收到含有Authorization首部字段的请求时的操作处理会略有差异。 Expect1Expect: 100-continue 客户端使用首部字段Expect来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed。 From首部字段From用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含From首部字段（但可能会因代理不同，将电子邮件地址记录在User-Agent首部字段内）。 Host1Host: www.hackr.jp 首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯——个必须被包含在请求内的首部字段。 If-Match1If-Match: &quot;123456&quot; 形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。首部字段If-Match，属附带条件之一，它会告知服务器匹配资源所用的实体标记（ETag)值。这时的服务器无法使用弱ETag值。（请参照本章有关首部字段ETag的说明）。服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。反之，则返回状态码412 Precondition Failed的响应。 If-Modified-Since1If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。 If-None-Match首部字段If-None-Match属于附带条件之一。它和首部字段If-Match作用相反。用于指定If-None-Match字段值的实体标记（ETag)值与请求资源的ETag不一致时，它就告知服务器处理该请求。 If-Range首部字段If-Range属于附带条件之一。它告知服务器若指定的If-Range 字段值（ETag值或者时间）和请求资源的ETag值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。 If-Unmodified-Since1If-Unmodified-Since: Thu, 03 ]ul 2012 00:00:00 GMT 首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412 Precondition Failed作为响应返回。 Max-Forwards1Max-Forwards: 10 通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时， 该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应。 Proxy-Authorization1Proxy-Authorization: Basic dGlwOjkpNLAGfFY5 接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的柄息。 Range1Range: bytes=5001-10000 接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为206 Partial Content的响应。无法处理该范围请永时，则会返回状态码200 OK的响应及全部资源。 Referer1Referer: http://www.hackr.jp/index.htm 首部字段Referer会告知服务器请求的原始资源的URI TE1TE: gzip, deflate;q=0.5 首部字段TE会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段Accept-Encoding的功能很相像，但是用于传输编码。 User-Agent1User-Agent: Mozilla/5.0 (Windows NT 6.1; W0W64; nv:13.0) Gee 首部字段User-Agent会将创建请求的浏览器和用户代理名称等信息传达给服务器。由网络爬虫发起请求时，有可能会在字段内添加爬虫作者的电子邮件地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器的名称。 响应首部字段响应首部字段是由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。 Accept-Ranges1Accept-Ranges: bytes 首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。 Age1Age: 600 首部字段Age能告知客户端，源服务器在多久前创建了响应。字段值的单位为秒。若创建该响应的服务器是缓存服务器，Age值是指缓存后的响应再次发起认证到认证完成的时间值。代理创建响应时必须加上首部字段Age。 ETag1ETag: &quot;34e544327886546ce7676aff67678acd67&quot; 首部字段ETag能告知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的ETag。 强ETag值和弱Tag值强ETag值，不论实体发生多么细微的变化都会改变其值。1ETag: &quot;usagi-1234&quot; 弱ETag值只用于提示资源是否相同。只有资源发生了根本改变，产生差异时才会改变ETag值。这时，会在字段值最开始处附加W/。1ETag: W/&quot;usagi-1234n Location1Location: http://www.usagidesign.jp/sample.html 使用首部字段Location可以将响应接收方引导至某个与请求URI位置不同的资源。基本上，该字段会配合3xx: Redirection的响应，提供重定向的。 Proxy-Authenticate1Proxy-Authenticate: Basic realm = &quot;UsagidesignAuth&quot; 首部字段Proxy-Authenticate会把由代理服务器所要求的认证信息发送给客户端。 Retry-After1Retry-After: 120 首部字段Retry-After告知客户端应该在多久之后再次发送请求。主要配合状态码503 Service Unavailable响应，或3xx Redirect响应一起使用。 Server1Server: Apache/2.2.6 (Unix) PHP/5.2.5 首部字段Server告知客户端当前服务器上安装的HTTP服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项。 Vary1Vary: Accept-Language 首部字段Vary可对缓存进行控制。源服务器会向代理服务器传达关于本地缓存使用方法的命令。 WWW-Authenticate1WWW-Authentic ate: Basic realm= &quot;Usagidesign Auth&quot; 首部字段WWW-Authenticate用于HTTP访问认证。它会告知客户端适用于访问请求URI所指定资源的认证方案（Basic或是Digest)和带参数提示的质询（challenge)。状态码401 Unauthorized响应中，肯定带有首部字段WWW-Authenticate。 实体首部字段实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。 Allow1Allow: GET, HEAD 首部字段Allow用于通知客户端能够支持Request-URI指定资源的所有HTTP方法。当服务器接收到不支持的HTTP方法时，会以状态码405 Method Not Allowed作为响应返回。与此同时，还会把所有能支持的HTTP方法写入首部字段Allow后返回。 Content-Encoding1Content-Encoding: gzip 首部字段Content-Encoding会告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩。 主要采用以下4种内容编码的方式。 gzip compress deflate identity Content-Language1Content-Language: zh-CN 首部字段Content-Language会告知客户端，实体主体使用的自然语言(指中文或英文等语言）。 Content-Length1Content- Length: 15000 首部字段Content-Length表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用Content-Length首部字段。由于实体主体大小的计算方法略微复杂，所以在此不再展开,可参考RFC2616的4.4。 Content-Location1Content-Location: http://www.hackr.jp/index-ja.html 首部字段Content-Location给出与报文主体部分相对应的URI和首部字段Location不同，Content-Location表示的是报文主体返回资源对应的URI。 Content-MD51Content-MD5: 0GFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY== 首部字段Content-MD5是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。 Content-Range1Content-Range: bytes 5001-10000/10000 针对范围请求，返回响应时使用的首部字段Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小。 Content-Type1Content-Type: text/html; charset=UTF-8 首部字段Content-Type说明了实体主体内对象的媒体类型。和首部字段Accept一样，只能使用type/subtype形式赋值。 Expires1Expires: Wed, 04 Dul 2012 08:26:05 GMT 首部字段Expires会将资源失效的日期告知客户端。缓存服务器在接收到含有首部字段Expires的响应后，会以缓存来应答请求，在Expires字段值指定的时间之前，响应的副本会一直被保卷。当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。 Last-Modified1Last-Modified: Wed, 23 May 2012 09:59:55 GMT 首部字段Last-Modified指明资源最终修改的时间。一般来说，这个值就是Request-URI指定资源被修改的时间。但类似使用CGI脚本进行动态数据处理时，该值有可能会变成数据最终修改时的时间。 Cookie 服务的首部字段至2013年5月，Cookie的规格标准文档有以下4种。 网景公司颁布的规格标准 RFC2109 RFC2965 RFC6265 Cookie服务的首部字段 首部字段名 说明 首部类型 Set-Cookie 开始状态管理所使用的Cookie信息 响应首部字段 Cookie 服务器接收到的Cookie信息 请求首部字段 Set-Cookie1Set-Cookie: status=enable; expires=Tue, 05 Dul 2011 07:26:31 当服务器准备开始管理客户端的状态时，会事先告知各种信息。 expires属性Cookie的expires属性指定浏览器可发送Cookie的有效期。 path属性Cookie的path属性可用于限制指定Cookie的发送范围的文件目录。不过另有办法可避开这项限制，看来对其作为安全机制的效果不能抱有期待。 domain属性通过Cookie的domain属性指定的域名可做到与结尾匹配一致。比如，当指定example.com后，除example.com以外，www.example.com或www2.example.com等都可以发送Cookie。 secure属性Cookie的secure属性用于限制Web页面仅在HTTPS安全连接时，才可以发送Cookie。 1Set-Cookie: name=value; secure HttpOnly属性Cookie的HttpOnly属性是Cookie的扩展功會泛，它使JavaScript脚本无法获得Cookie。其主要目的为防止跨站脚本攻击（Cross-site scripting，XSS)对Cookie的信息窃取。 Cookie1Cookie: status=enable 首部字段Cookie会告知服务器，当客户端想获得HTTP状态管理支持时，就会在请求中包含从服务器接收到的Cookie。接收到多个Cookie时，同样可以以多个Cookie形式发送。 非标准首部字段HTTP首部字段是可以自行扩展的。所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段。 X-Frame-Options X-XSS-Protection DNT P3P X-Frame-Options1X-Frame-Options: DENY 首部字段X-Frame-Options属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持（click jacking)攻击。 X-XSS-Protection1X-XSS-Protection: 1 首部字段X-XSS-Protection属于HTTP响应首部，它是针对跨站脚本攻击（XSS)的一种对策，用于控制浏览器XSS防护机制的开关。 DNT1DNT: 1 首部字段DNT属于HTTP请求首部，其中DNT是”Do Not Track”的简称，意为拒绝个人信息被收集，是表不拒绝被精准广告追踪的一种方法。 P3P1P3P: CP=&quot;CAO DSP LAW CURa ADMa DEVa TAIa PSAa PSDa IVAa IVDe 首部字段P3P属于HTTP响应首部，通过利用P3P (“The Platform for Privacy Preferences”，在线隐私偏好平台）技术，可以让Web网站上的个人隐私变成一种仅供程序可理解的形式，以达到保护用户隐私的目的。 参考文献 《图解HTTP》第6章HTTP首部]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>首部</tag>
        <tag>首部字段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素与块级元素及元素嵌套问题总结]]></title>
    <url>%2F2017%2F09%2F22%2Fblock-and-inline%2F</url>
    <content type="text"><![CDATA[区别块级元素CSS格式：display:block;总是独占一行，表现为另起一行开始，而且其后的元素也必须另起一行显示;宽度(width)、高度(height)、内边距(padding)和外边距(margin)都可控制;块级元素表： 块级元素标签 说明 &lt;address&gt; 定义地址 &lt;caption&gt; 定义表格标题 &lt;dd&gt; 定义列表中定义条目 &lt;div&gt; 定义文档中的分区或节 &lt;dl&gt; 定义列表 &lt;dt&gt; 定义列表中的项目 &lt;fieldset&gt; 定义一个框架集 &lt;form&gt; 创建 HTML 表单 &lt;h1&gt; 定义最大的标题 &lt;h2&gt; 定义副标题 &lt;h3&gt; 定义标题 &lt;h4&gt; 定义标题 &lt;h5&gt; 定义标题 &lt;h6&gt; 定义最小的标题 &lt;hr&gt; 创建一条水平线 &lt;legend&gt; 元素为fieldset元素定义标题 &lt;li&gt; 标签定义列表项目 &lt;noframes&gt; 为那些不支持框架的浏览器显示文本，于frameset元素内部 &lt;noscript&gt; 定义在脚本未被执行时的替代内容 &lt;ol&gt; 定义有序列表 &lt;ul&gt; 定义无序列表 &lt;p&gt; 标签定义段落 &lt;pre&gt; 定义预格式化的文本 &lt;table&gt; 标签定义HTML表格 &lt;tbody&gt; 标签表格主体（正文） &lt;td&gt; 表格中的标准单元格 &lt;tfoot&gt; 定义表格的页脚（脚注或表注） &lt;th&gt; 定义表头单元格 &lt;thead&gt; 标签定义表格的表头 &lt;tr&gt; 定义表格中的行 行内元素和相邻的内联元素在同一行;水平方向的left/right（padding-left, padding-right, margin-left, margin-right）都产生边距效果;宽度(width)、高度(height)、内边距的top/bottom(padding-top/padding-bottom)和外边距的top/bottom(margin-top/margin-bottom)都不可改变，就是里面文字或图片的大小; 行内元素列表： 行内元素标签 说明 &lt;a&gt; 标签可定义锚 &lt;abbr&gt; 表示一个缩写形式 &lt;acronym&gt; 定义只取首字母缩写 &lt;b&gt; 字体加粗 &lt;bdo&gt; 可覆盖默认的文本方向 &lt;big&gt; 大号字体加粗 &lt;br&gt; 换行 &lt;cite&gt; 引用进行定义 &lt;code&gt; 定义计算机代码文本 &lt;dfn&gt; 定义一个定义项目 &lt;em&gt; 定义为强调的内容 &lt;i&gt; 斜体文本效果 &lt;img&gt; 向网页中嵌入一幅图像 &lt;input&gt; 输入框 &lt;kbd&gt; 定义键盘文本 &lt;label&gt; 标签为input元素定义标注（标记） &lt;q&gt; 定义短的引用 &lt;samp&gt; 定义样本文本 &lt;select&gt; 创建单选或多选菜单 &lt;small&gt; 呈现小号字体效果 &lt;span&gt; 组合文档中的行内元素 &lt;strong&gt; 语气更强的强调的内容 &lt;sub&gt; 定义下标文本 &lt;sup&gt; 定义上标文本 &lt;textarea&gt; 多行的文本输入控件 &lt;tt&gt; 打字机或者等宽的文本效果 &lt;var&gt; 定义变量 行内块级元素将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内。使其同时具有block的宽高特性和inline的同行特性 嵌套规则引用自:HTML 标签的嵌套规则 块元素可以包含内联元素或某些块元素，但内联元素却不能包含块元素，它只能包含其它的内联元素 123&lt;div&gt;&lt;h1&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; ------ 对 &lt;a href=”#”&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; ------ 对 &lt;span&gt;&lt;div&gt;&lt;/div&gt;&lt;/span&gt; ------ 错 块级元素不能放在&lt;p&gt;里面 12&lt;p&gt;&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt; ------ 错&lt;p&gt;&lt;div&gt;&lt;/div&gt;&lt;/p&gt; ------ 错 有几个特殊的块级元素只能包含内嵌元素，不能再包含块级元素，这几个特殊的标签是：h1、h2、h3、h4、h5、h6、p、dt li内可以包含div标签—-这一条其实不必单独列出来的，但是网上许多人对此有些疑惑，就在这里略加说明：li和div标签都是装载内容的容器，地位平等，没有级别之分（例如：h1、h2这样森严的等级制度^_^），要知道，li标签连它的父级ul或者是ol都 可以容纳的，为什么有人会觉得li偏偏容纳不下一个div呢？ 块级元素与块级元素并列、内嵌元素与内嵌元素并列123&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; ------ 对&lt;div&gt;&lt;a href=”#”&gt;&lt;/a&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; ------ 对&lt;div&gt;&lt;h2&gt;&lt;/h2&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt; ------ 错 HTML5元素分类引用自：元素分类与内容模型在HTML5中，标准制定者重新定义了HTML元素的分类，并根据这一新的分类定义了元素的内容模型(Content Model) – 对于一个元素而言，哪些子元素是合法的，而哪些子元素是非法的。HTML5中，元素主要分为7类： Metadata Flow Sectioning Heading Phrasing Embedded Interactive Metadata（元数据元素）顾名思义，Metadata元素意指那些定义文档元数据信息的元素 — 其作用包括：影响文档中其它节点的展现与行为、定义文档与其它外部资源之间的关系等。以下元素属于Metadata：base, link, meta, noscript, script, style, template, title。 Flow（流式元素）所有可以放在body标签内，构成文档内容的元素均属于Flow元素。因此，除了base, link, meta, style, title等只能放在head标签内的元素外，剩下的所有元素均属于Flow元素。具体包含：12345678a， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b，bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form，h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， object， ol， output， p， pre， progress， q， ruby， s， samp， script， section，select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup，svg， table，textarea， time， u， ul， var， video， wbr， text Sectioning（章节元素）Sectioning意指定义页面结构的元素，具体包含以下四个：article, aside, nav, section。 Heading（标题元素）所有标题元素属于Heading，也即以下6个元素：h1, h2, h3, h4, h5, h6。 Phrasing（段落元素）所有可以放在p标签内，构成段落内容的元素均属于Phrasing元素。因此，所有Phrasing元素均属于Flow元素。在HTML5标准文档中，关于Phrasing元素的原始定义为： Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs. 对于这一定义，个人认为不应当使用“text”这一容易引起误解的词，事实上，一个元素即使不是文本，只要能包含在p标签中成为段落内容的一部分，就可以称之为Phrasing元素。比如：audio、video、img、select、input等元素(经测试，这些元素都可以放置在p标签中)。具体包含如下：1234567a（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b，bdi， bdo， br， button， canvas， cite， code， command， datalist， del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素），mark， math， meter， noscript， object， output， progress， q， ruby， s，samp， script，select， small， span， strong， sub， sup， svg， textarea，time， u， var， video， wbr， text Phrasing元素内部一般只能包含别的Phrasing元素。关于Phrasing元素，Stackoverflow上有一个比较精彩的问答，可供参考。 Embedded（嵌入元素）所有用于在网页中嵌入外部资源的元素均属于Embedded元素，具体包含以下9个：audio, video, img, canvas, svg, iframe, embed, object, math。 Interactive（交互元素）所有与用户交互有关的元素均属于Interactive元素，包括a, input, textarea, select等。具体包含如下：1234a， audio（如果设置了controls属性）， button， details， embed， iframe，img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label，menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性） HTML5内容模型(Content Model)根据以上元素分类，HTML5标准文档定义了任何元素的内容模型 — 对于该元素而言，何种子元素才是合法的。比如，对于p元素而言，其内容模型为Phrasing, 这意味着p元素只接受Phrasing元素为子元素，而对于像div这样的非Phrasing元素则并不接受。类似的，li元素的内容模型为Flow，因此任何可以放置在body中的元素都可以作为li元素的子元素。 透明内容模型(Transparent content models)值得注意的是，HTML5标准文档在定义元素的内容模型时，会使用一类特殊的分类：透明内容模型(transparent) — 对于内容模型为透明(transparent)的元素而言，其子元素的合法性由其父元素所决定；如果其父元素的内容模型仍为透明，则查看其祖父元素的情况，并依此类推；如果向上推演至body标签仍未找到任何内容模型非透明的父级元素，则该透明元素内部可包含任何Flow元素。透明元素目前W3C中也没有给出明确的包含哪些元素，从段落元素中推断透明内容模型元素有：1a, ins, del, map 典型的具有透明内容模型的元素为a元素。因此，当a出现在p标签中时，a不能接受div作为子元素；而当a出现在div标签中时，a可以接受div作为子元素。对此，知乎上有一个问答解释了这种现象。 参考文献 a 标签为什么能够包含块级元素？ W3C HTML5标准阅读笔记 – 元素分类与内容模型(Content Model) content-models]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>inline</tag>
        <tag>block</tag>
        <tag>inline-block</tag>
        <tag>嵌套</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域总结]]></title>
    <url>%2F2017%2F09%2F22%2Fcross-origin%2F</url>
    <content type="text"><![CDATA[同源策略同源定义：协议+域名+端口号。同源表示三者均相等。 同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的重要安全机制。 浏览器是从两个方面去做这个同源策略的，一是针对接口的请求，二是针对Dom的查询。 无同源策略的危害 接口请求：从其他网站发起请求从而导致的CSRF攻击。 DOM查询：由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom。从而更能轻易获取用户密码等隐私数据。 同源策略可以预防某些恶意行为，但实现合理的跨域请求对开发某些浏览器应用程序也是至关重要的。 跨域请求JSONPJSONP是JSON with padding（填充式 JSON 或参数式 JSON）的简写，JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数。回调函数的名字一般是在请求中指定的。而数据就是传入回调函数中的 JSON 数据。 1234567891011121314151617181920212223// 1. 客户端部分// JSONP跨域function checkJsonp() &#123; const script = document.createElement('script'); script.setAttribute('src', 'http://127.0.0.1:8081/jsonp?name=zxlg&amp;age=26&amp;callback=handleRes') document.body.appendChild(script);&#125;// 客户端响应处理function handleRes(res) &#123; const &#123; name, age &#125; = res; alert(name + ' is ' + age + ' years old');&#125;// 2.服务端部分(express)app.get('/jsonp', (req, res) =&gt; &#123; const &#123; query &#125; = req const &#123; name, age, callback &#125; = query const response = &#123; name, age &#125; res.end(callback + '(' + JSON.stringify(response) + ')')&#125;) 其实JSONP也是需要服务端支持，服务端必须返回执行的代码，即Fn(param)，所以一般后端使用cors机制处理跨域机制比较好。 空iframe+fromjsonp只能发送get请求，使用iframe+from可以发起post请求 12345678910111213141516171819202122232425262728293031323334353637383940const iframePost = (&#123;url, data&#125;) =&gt; &#123; // 首先创建一个用来发送数据的iframe. const iframe = document.createElement('iframe') iframe.name = 'iframePost' iframe.style.display = 'none' document.body.appendChild(iframe) const form = document.createElement('form') const node = document.createElement('input') // 注册iframe的load事件处理程序,如果你需要在响应返回时执行一些操作的话. iframe.addEventListener('load', function () &#123; console.log('iframe post success'); &#125;) form.action = url // 在指定的iframe中执行form form.target = iframe.name form.method = 'post' for (let name in data) &#123; node.name = name node.value = data[name].toString() form.appendChild(node.cloneNode()) &#125; // 表单元素需要添加到主文档中. form.style.display = 'none' document.body.appendChild(form) form.submit() // 表单提交后,就可以删除这个表单,不影响下次的数据发送. document.body.removeChild(form)&#125;// 使用方式const checkIframe = () =&gt; &#123; iframePost(&#123; url: 'http://127.0.0.1:8081/iframePost', data: &#123; msg: 'iframe + from' &#125; &#125;)&#125; 缺点是获取请求返回的数据会遇到跨域DOM查询的问题 CORS 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 简单请求与复杂请求简单请求 请求方法是以下三种方法之一：HEAD, GET POST HTTP的头信息不超出以下几种字段：Accept, Accept-Language, Content-Language, Last-Event-ID, Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 非简单请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 实现一个CORS跨域请求客户端发起ajax请求默认情况下，跨源请求不提供凭据（cookie、HTTP认证及客户端SSL证明等）。通过将withCredentials属性设置为true，可以指定某个请求应该发送凭据。如果服务器接受带凭据的请求，会用下面的HTTP头部来响应。Access-Control-Allow-Credentials:true。如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 客户端使用axios发起请求： 123456789axios(&#123; baseURL: 'http://127.0.0.1:8081', url: '/cors', method: 'post', withCredentials: false, // 要发送Cookie，服务端必须指定明确的、与请求网页一致的域名 data: &#123; name: 'zxlg' &#125;&#125;) 服务器配置CORS需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。 12345//服务器端设置响应头，各个服务器实现方法略有不同'Access-Control-Allow-Origin': 'http://127.0.0.1:8080' // 允许访问的源'Access-Control-Allow-Methods':'GET,PUT,POST,DELETE' // 允许使用的请求方法'Access-Control-Allow-Headers':'Content-Type' // 允许的头部'Access-Control-Allow-Credentials':'true'/'flase' 以express为例: 12345678910111213141516171819// allow custom header and CORSapp.all('*', function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*') res.header('Access-Control-Allow-Headers', 'Content-Type') res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS') if (req.method === 'OPTIONS') &#123; res.sendStatus(200) // 让options请求快速返回 &#125; else &#123; next() &#125;&#125;)app.post('/cors', function (req, res) &#123; const &#123; name &#125; = req.body res.json(&#123; resMsg: `hello $&#123;name&#125;!` &#125;)&#125;) 跨域DOM查询postMessage12345window.postMessage() // 是HTML5的一个接口，专注实现不同窗口不同页面的跨域通讯。window.addEventListener('message', (e)=&gt; &#123; // 接收请求&#125;) 参考文献 Javascript高级程序编程第三版 跨域资源共享CORS详解–阮一峰 不要再问我跨域的问题了]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>跨域</tag>
        <tag>cors</tag>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas和svg总结比较]]></title>
    <url>%2F2017%2F09%2F21%2Fcanvas-and-svg%2F</url>
    <content type="text"><![CDATA[Canvas基本用法getContext() 描边和填充strokeStyle：设置描边样式fillStyle：设置填充样式stroke()：描边fill()：填充 绘制矩形fillRect()：填充矩形strokeRect()：描边矩形clearRect()：清除画布矩形区域 绘制路径beginPath()：开始绘制路径arc(x, y, radius, startAngle, endAngle, counterclockwise)：以(x,y)为圆心绘制一条弧线，弧线半径为radius，起始和结束角度（用弧度表示）分别为startAngle和endAngle。最后一个参数表示startAngle和endAngle是否按逆时针方向计算，值为false表示按顺时针方向计算。arcTo(x1, y1, x2, y2, radius)：从上一点开始绘制一条弧线，到(x2,y2)为止，并且以给定的半径radius穿过(x1,y1)。bezierCurveTo(c1x, c1y, c2x, c2y, x, y)：从上一点开始绘制一条曲线，到(x,y)为止，并且以(c1x,c1y)和(c2x,c2y)为控制点。lineTo(x, y)：从上一点开始绘制一条直线，到(x,y)为止。moveTo(x, y)：将绘图游标移动到(x,y)，不画线。如果路径已经完成，你想用fillStyle填充它，可以调用fill()方法。另外，还可以调用stroke()方法对路径描边，描边使用的是strokeStyle。最后还可以调用clip()，这个方法可以在路径上创建一个剪切区域。 绘制文本绘制文本主要有两个方法：fillText()和strokeText()。这两个方法都可以接收 4 个参数：要绘制的文本字符串、 x 坐标、 y 坐标和可选的最大像素宽度。这两个方法都以下列 3 个属性为基础:font：表示文本样式、大小及字体，用 CSS 中指定字体的格式来指定，例如”10px Arial”。textAlign：表示文本对齐方式。可能的值有”start”、”end”、”left”、”right”和”center”。建议使用”start”和”end”，不要使用”left”和”right”，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示（阅读）的语言。textBaseline：表示文本的基线。可能的值有”top”、”hanging”、”middle”、”alphabetic”、“ideographic”和”bottom”。 变换rotate(angle)：围绕原点旋转图像angle弧度。scale(scaleX, scaleY)：缩放图像，在x方向乘以scaleX，在y方向乘以scaleY。scaleX和scaleY的默认值都是1.0。translate(x, y)：将坐标原点移动到(x,y)。执行这个变换之后， 坐标(0,0)会变成之前由(x,y)表示的点。transform(m1_1, m1_2, m2_1, m2_2, dx, dy)：直接修改变换矩阵，方式是乘以如下矩阵。123m1_1 m1_2 dxm2_1 m2_2 dy0 0 1 setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy)：将变换矩阵重置为默认状态，然后再调用 transform()。 无论是刚才执行的变换，还是fillStyle、strokeStyle等属性，都会在当前上下文中一直有效，除非再对上下文进行什么修改。虽然没有什么办法把上下文中的一切都重置回默认值，但有两个方法可以跟踪上下文的状态变化。如果你知道将来还要返回某组属性与变换的组合，可以调用save()方法。调用这个方法后，当时的所有设置都会进入一个栈结构，得以妥善保管。然后可以对上下文进行其他修改。等想要回到之前保存的设置时，可以调用restore()方法，在保存设置的栈结构中向前返回一级，恢复之前的状态。连续调用save()可以把更多设置保存到栈结构中，之后再连续调用restore()则可以一级一级返回。 WebGL参考文献 Canvas Javascript高级程序编程第三版–使用Canvas绘图p445]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的闭包]]></title>
    <url>%2F2017%2F09%2F18%2Fjs-closure%2F</url>
    <content type="text"><![CDATA[匿名函数通过函数表达式生成的函数为匿名函数，因为function关键字后面没有标识符。匿名函数的name属性是空字符串。通过函数表达式生成的函数不会变量提升，但是通过函数声明的函数会变量提升，即可以在使用后声明。 arguments.callee是一个指向正在执行的函数的指针。可以在递归中使用 闭包闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的方式就是在一个函数内部创建另外一个函数。12345678function testClosure()&#123; var a = 1; return function()&#123; return a; &#125;&#125;var func = testClosure();var a = func(); 即使这个内部函数被返回了,而且在其他地方被调用了，但他仍然可以访问变量a，因为内部函数的作用域链中包含了testClosure()的作用域。当某个函数被调用时，会创建一个执行环境(excution text)及相应的作用域链。但在作用域链中，使用arguments和其他命名参数的值来初始化函数的活动对象(activation object)。在作用域链中，外部函数的活动对象始终处于第二位，外部函数的外部函数处于第三位，……直至作用域链的终点全局执行环境。 普通函数执行后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在，而局部环境的变量对象，则只在函数执行的过程中存在。12345678910function compare(value1, value2)&#123; if (value1 &lt; value2)&#123; return -1; &#125; else if (value1 &gt; value2)&#123; return 1; &#125; else &#123; return 0; &#125;&#125;var result = compare(5, 10); 创建函数在创建compare()函数时，会创建一个预先包含全局变量对象的作用域链，这个作用域链被保存在内部的[[Scope]]属性中。 调用函数当调用compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象（在此作为变量对象使用）被创建并被推入执行环境作用域链的前端。对于这个例子中compare()函数的执行环境而言，其作用域链中包含两个变量对象：本地活动对象和全局变量对象。 作用域链作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。无论什么时候在函数中访问一个变量时，就会从作用域链中搜索具有相应名字的变量。一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域（全局执行环境的变量对象）。但是闭包情况有所区别。 闭包执行在另一个函数内部定义的函数会将包含函数（即外部函数）的活动对象添加到它的作用域链中。1234567891011function testClosure()&#123; var a = 1; return function()&#123; return a; &#125;&#125;var func = testClosure();var a = func();//解除对匿名函数的引用，以便释放内存func = null; 在匿名函数从testClosure()中被返回后，它的作用域链被初始化包含testClosure()函数的活动对象和全局变量对象。这样匿名函数就可以访问在testClosure()中定义的所有变量。更为重要的是，testClosure()函数执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。换句话说，当testClosure()函数返回后，其执行环境的作用域链会被销毁，但是它的活动对象仍然留在内存中。直到匿名函数被销毁后，testClosure()函数的活动对象才会被销毁。 通过设置func = null;解除对匿名函数的引用，以便释放内存，等于通知垃圾回收例程将其清除。 闭包与变量作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象，而不是某个特殊的变量。123456789function count() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push(function () &#123; return i * i;//返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 &#125;); &#125; return arr;&#125; 这个函数会返回一个函数数组。表面上看，似乎每个函数都应该返自己的索引值的平方，即位置0的函数返回0^2，位置1的函数返回1^2，以此类推。但实际上，每个函数都返回 10^2。因为每个函数的作用域链中都保存着count()函数的活动对象，所以它们引用的都是同一个变量i。 当count()函数返回后，变量i的值是10，此时每个函数都引用着保存变量i的同一个变量对象，所以在每个函数内部i的值都是 10。 可以建立另一个匿名函数并立即执行，将i传入其中。12345678910111213function count1() &#123; var arr = []; for (var i = 1; i &lt;= 3; i++) &#123; arr.push( (function (n) &#123; return function () &#123; return n * n; &#125; &#125;)(i) ); &#125; return arr;&#125; “创建一个匿名函数并立刻执行” 理论上讲，创建一个匿名函数并立刻执行可以这么写：function (x) { return x * x } (3);，但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：(function (x) { return x * x }) (3);这种方法理论上可以模仿块级作用域。 闭包中的this对象参见我的博客this对象12345678910var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; return function()&#123; return this.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //"The Window"（在非严格模式下） 每个函数在被调用时都会自动取得两个特殊变量：this和arguments。内部函数在搜索这两个变量时，只会搜索到其活动变量为止，因此永远不可能直接访问外部函数的这两个变量。 1234567891011var name = "The Window";var object = &#123; name : "My Object", getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()()); //"My Object" 在匿名函数中我们把this对象赋值给了一个名叫that的变量。而在定义了闭包之后，闭包也可以访问这个变量。即使函数返回之后，that也仍然引用着object，所以调用之后返回了My Object。 参考文献 Javascript高级程序编程第三版p178]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>closure</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web安全总结(前端)]]></title>
    <url>%2F2017%2F09%2F14%2Fweb-security%2F</url>
    <content type="text"><![CDATA[HTTPS参见我的博客HTTPS XSSCSRFCSRF(Cross Site Request Forgery, 跨站请求伪造) A(黑客网站) –&gt; 发起用户不知情的请求(附带浏览器中的token信息) –&gt; B(银行网站) 防御策略 Referrer token(url, 请求体) 自定义请求头部]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>XSS</tag>
        <tag>CSRF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web应用客户端存储]]></title>
    <url>%2F2017%2F09%2F05%2Fclient-storage%2F</url>
    <content type="text"><![CDATA[2017-09-06更新： 简要叙述客户端存储，indexdDB未完成 Cookie客户端用于存储会话信息， cookie 是一小块可以客户端设置也可以在服务器端设置的信息，每次发起请求时都会传送它。 在 JavaScript 中通过document.cookie可以访问 cookie。cookie 的限制使其可以存储少量数据，然而对于大量数据效率很低。 HTTP请求头：Cookie: name=valueHTTP响应头：Set-Cookie: name=value cookie构成name=value;expires=expiration_time;path=domain.path;domain=domain.name;secure 限制浏览器中对于 cookie 的尺寸也有限制。大多数浏览器都有大约 4096B（加减 1）的长度限制。为了最佳的浏览器兼容性，最好将整个 cookie 长度限制在 4095B（含 4095）以内。尺寸限制影响到一个域下所有的 cookie，而并非每个 cookie 单独限制。 由于所有的 cookie 都会由浏览器作为请求头发送，所以在 cookie 中存储大量信息会影响到特定域的请求性能。cookie 信息越大，完成对服务器请求的时间也就越长。尽管浏览器对 cookie 进行了大小限制，不过最好还是尽可能在 cookie 中少存储信息，以避免影响性能。 一定不要在 cookie 中存储重要和敏感的数据。 cookie 数据并非存储在一个安全环境中，其中包含的任何数据都可以被他人访问。 Web Storage提供一种在cookie之外存储会话数据的途径提供一种存储大量可以跨会话存在的数据的机制 Storage类型Storage对象方法:clear()getItem(name)key(index)removeItem(name)setItem(name,value) sessionStorage浏览器关闭删除跨页面刷新而存在用于在一个浏览器会话中存储数据，因为数据在浏览器关闭后会立即删除 localStorage数据保留到Javascript删除或者用户清除浏览器缓存要访问同一个localStorage对象，页面必须同源(协议+域名+端口)(子域名无效)跨会话持久化数据并遵循跨域安全策略 限制对于 localStorage 而言，大多数桌面浏览器会设置每个来源 5MB 的限制。 Chrome 和 Safari 对每个来源的限制是 2.5MB。而 iOS 版 Safari 和 Android 版 WebKit 的限制也是 2.5MB。 对 sessionStorage 的限制也是因浏览器而异。有的浏览器对 sessionStorage 的大小没有限制，但 Chrome、Safari、 iOS 版 Safari 和 Android 版 WebKit 都有限制，也都是 2.5MB。 IE8+和 Opera 对sessionStorage 的限制是 5MB。 IndexdDB用对象保存数据而不是表保存数据异步操作：onerror(),onsuccess() 创建对象创建对象存储空间时，需要定义一个键，然后就可以添加数据。var store = db.createObjectStore(&quot;users&quot;, { keyPath: &quot;username&quot; });keyPath即为键，而且必须全局唯一。 添加数据add( obj ),添加已有键，报错；插入新值put( obj ),添加已有键，重写原来对象；更新对象 事物跨过创建对象存储空间这一步之后，接下来的所有操作都是通过事务来完成的。在数据库对象上调用transaction()方法可以创建事务。任何时候，只要想读取或修改数据，都要通过事务来组织所有操作。 1var transaction = db.transaction(arr,IDBTransaction); arr表示存储空间的数组或对象。用 IDBTransaction 接口定义的如下常量表示： READ_ONLY(0)表示只读， READ_WRITE(1)表示读写，VERSION_CHANGE(2)表示改变。然后可以使用add()和put()方法，使用get()可以取得值，使用delete()可以删除对象， 而使用clear()则可以删除所有对象。get()和delete()方法都接收一个对象键作为参数，而所有这 5 个方法都会返回一个新的请求对象。 12var transaction = db.transaction("users", IDBTransaction.READ_WRITE);var request = db.transaction("users").objectStore("users").get("007"); 游标查询可以使用游标在对象存储空间中查询特定的对象。游标就是一指向结果集的指针。与传统数据库查询不同，游标并不提前收集结果。游标指针会先指向结果中的第一项，在接到查找下一项的指令时，才会指向下一项。在对象存储空间上调用openCursor()方法可以创建游标。与 IndexedDB 中的其他操作一样，openCursor()方法返回的是一个请求对象，因此必须为该对象指定onsuccess和onerror事件处理程序。在 onsuccess 事件处理程序执行时，可以通过event.target.result取得存储空间中的下一个对象。在结果集中有下一项时，这个属性中保存一个 IDBCursor 的实例，在没有下一项时，这个属性的值为null。IDBCursor 的实例有以下几个属性。direction：数值，表示游标移动的方向。 默认值为IDBCursor.NEXT(0)，表示下一项; IDBCursor.NEXT_NO_DUPLICATE(1)表示下一个不重复的项; DBCursor.PREV(2)表示前一项; IDBCursor.PREV_NO_DUPLICATE(4)表示前一个不重复的项。 key：对象的键。value：实际的对象。primaryKey：游标使用的键。可能是对象键，也可能是索引键（稍后讨论索引键）。 检索： 1234567request.onsuccess = function(event)&#123; var cursor = event.target.result; if (cursor)&#123; //必须要检查 console.log("Key: " + cursor.key + ", Value: " + JSON.stringify(cursor.value)); &#125;&#125;; 请记住，这个例子中的cursor.value是一个对象，这也是为什么在显示它之前先将它转换成 JSON字符串的原因 键范围键范围（key range）为使用游标增添了一些灵活性。键范围由 IDBKeyRange 的实例表示。 索引索引是为了提高查询速度而基于特定的属性创建的。 设定游标方向并发问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>数据存储</tag>
        <tag>客户端存储</tag>
        <tag>Cookie</tag>
        <tag>localStorage</tag>
        <tag>sessionStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web缓存总结]]></title>
    <url>%2F2017%2F09%2F04%2Fhttp-cache%2F</url>
    <content type="text"><![CDATA[为什么使用Web缓存 减少网络带宽消耗 降低服务器压力 减少网络延迟，加快页面打开速度 Web缓存类型数据库数据缓存Web应用，特别是SNS类型的应用，往往关系比较复杂，数据库表繁多，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，会将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。 服务器端缓存代理服务器缓存代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起Web请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。可以把它理解为一个共享缓存，不只为一个用户服务，一般为大量用户提供服务，因此在减少相应时间和带宽使用方面很有效，同一个副本会被重用多次。 CDN缓存CDN（Content delivery networks）缓存，也叫网关缓存、反向代理缓存。CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。浏览器先向CDN网关发起Web请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。虽然这种架构负载均衡源服务器之间的缓存没法共享，但却拥有更好的处扩展性。从浏览器角度来看，整个CDN就是一个源服务器，从这个层面来说，本文讨论浏览器和服务器之间的缓存机制，在这种架构下同样适用。 浏览器端缓存浏览器缓存根据一套与服务器约定的规则进行工作，在同一个会话过程中会检查一次并确定缓存的副本足够新。如果你浏览过程中，比如前进或后退，访问到同一个图片，这些图片可以从浏览器缓存中调出而即时显现。 Web应用层缓存应用层缓存指的是从代码层面上，通过代码逻辑和缓存策略，实现对数据，页面，图片等资源的缓存，可以根据实际情况选择将数据存在文件系统或者内存中，减少数据库查询或者读写瓶颈，提高响应效率。 浏览器缓存规则对于浏览器端的缓存来讲，这些规则是在HTTP协议头和HTML页面的Meta标签中定义的。 不能使用缓存定义任何时候都不使用缓存，返回的响应码为200。 http头部： 1Cache-Control: no-store 强制缓存定义使用缓存，在缓存未过期之前，或未定义强制进行服务器校验，使用浏览器中的保存的缓存，返回的响应码为200。 HTTP头部： 1234Cache-Control: max-age: XXX // 缓存可以使用XXX秒Expires: XXX // 缓存可以使用到XXX(日期)Cache-Control: no-cache // 定义强制进行服务器校验Pragma: no-cache // 定义强制进行服务器校验(HTTP/1.0 中规定的通用首部) 协商缓存进行服务器校验时，发现缓存文件未发生改变，使用浏览器中的缓存，返回的响应码为304。 HTTP头部： 12Last-Modified: XXX // 文件最后修改时间Etag: XXX // 文件对应的唯一标识符（md5标志） 从服务器获取资源进行服务器校验时，发现缓存文件已发生改变，使用服务器返回数据，返回的响应码为200。 http首部字段分类通用首部字段通用首部字段：请求报文和响应报文均能使用 字段名称 说明 Cache-Control 控制缓存行为 Pragma HTTP1.0遗留，值为“no-cache”禁止缓存 请求首部字段 字段名称 说明 if-Match 比较ETag是否一致 if-None-Match 比较ETag是否不一致 if-Modified-Since 比较最后资源更新的时间是否一致 if-Unmodified-Since 比较最后资源更新的时间是否不一致 响应首部字段 字段名称 说明 ETag 资源的匹配信息 实体首部字段 字段名称 说明 Expires HTTP1.0遗留，实体主体开始时间 Last-Modified 资源最后一次修改时间 Cache-Control“Expires时间是相对服务器而言，无法保证和客户端时间统一”的问题，http1.1新增了Cache-Control来定义缓存过期时间，若报文中同时出现了Pragma、Expires 和Cache-Control，会以Cache-Control为准。 Cache-Control请求指令表 参数 说明 Cache-Control: max-age=seconds 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。 Cache-Control: max-stale[=seconds] 表明客户端愿意接收一个已经过期的资源。 可选的设置一个时间 (单位秒)，表示响应不能超过的过时时间。 Cache-Control: min-fresh=seconds 表示客户端希望在指定的时间内获取最新的响应。 Cache-control: no-cache 强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器 Cache-control: no-store 缓存不应存储有关客户端请求或服务器响应的任何内容。 Cache-control: no-transform 不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改。 Cache-control: only-if-cached 表明如果缓存存在，只使用缓存，无论原始服务器数据是否有更新。 Cache-Control响应指令表 参数 意义 Cache-control: must-revalidate 缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源 Cache-control: no-cache 强制所有缓存了该响应的缓存用户，在使用已存储的缓存数据前，发送带验证器的请求到原始服务器 Cache-control: no-store 缓存不应存储有关客户端请求或服务器响应的任何内容 Cache-control: no-transform 不得对资源进行转换或转变。Content-Encoding, Content-Range, Content-Type等HTTP头不能由代理修改 Cache-control: public 表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存 Cache-control: private 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它） Cache-control: proxy-revalidate 与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略 Cache-Control: max-age=seconds 设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间 Cache-control: s-maxage=seconds 覆盖max-age 或者 Expires 头，但是仅适用于共享缓存(比如各个代理)，并且私有缓存中它被忽略 示例12Cache-Control: no-storeCache-Control: no-cache, no-store, must-revalidate 缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。 1Cache-Control: no-cache 每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。 1Cache-Control: max-age=3600, must-revalidate 它意味着该资源是从原服务器上取得的，且其缓存（新鲜度）的有效时间为一小时，在后续一小时内，用户重新访问该资源则无须发送请求。 Last-Modified服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码即可。传递标记起来的最终修改时间的请求报文首部字段有：If-Modified-Since和If-Unmodified-Since。 If-Modified-Since: Last-Modified-value示例为If-Modified-Since: Thu, 31 Mar 2016 07:07:52 GMT该请求首部告诉服务器如果客户端传来的最后修改时间与服务器上的一致，则直接回送304 和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的 Last-Modified 值。 If-Unmodified-Since: Last-Modified-value告诉服务器，若Last-Modified没有匹配上（资源在服务端的最后更新时间改变了），则应当返回412(Precondition Failed)状态码给客户端。当遇到下面情况时，If-Unmodified-Since字段会被忽略： Last-Modified值对上了（资源在服务端没有新的修改）； 服务端需返回2XX和412之外的状态码； 传来的指定日期不合法 ETag为了解决上述Last-Modified可能存在的不准确的问题，Http1.1还推出了ETag实体首部字段。服务器会通过某种算法，给资源计算得出一个唯一标识符（比如md5标志），在把资源响应给客户端的时候，会在实体首部加上ETag: 唯一标识符一起返回给客户端。客户端会保留该ETag字段，并在下一次请求时将其一并带过去给服务器。服务器只需要比较客户端传来的ETag跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。请求报文中有两个首部字段If-None-Match和If-Match可以带上ETag值。 If-None-Match: ETag-value示例为If-None-Match: &quot;56fcccc8-1699&quot;告诉服务端如果ETag没匹配上需要重发资源数据，否则直接回送304和响应报头即可。当前各浏览器均是使用的该请求首部来向服务器传递保存的ETag值。 If-Match: ETag-value告诉服务器如果没有匹配到ETag，或者收到了“*”值而当前并没有该资源实体，则应当返回412(Precondition Failed)状态码给客户端。否则服务器直接忽略该字段。If-Match的一个应用场景是，客户端走PUT方法向服务端请求上传/更替资源，这时候可以通过If-Match传递资源的ETag。 如果Last-Modified和ETag同时被使用，则要求它们的验证都必须通过才会返回304，若其中某个验证没通过，则服务器会按常规返回资源实体及200状态码。 HTTP1.0缓存PramaPragma是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头不支持这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端。当该字段值为no-cache的时候（事实上现在RFC中也仅标明该可选值），会知会客户端不要对该资源读缓存，即每次都得向服务器发一次请求才行。 Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上这段meta元标签（而且可能还得做些hack放到body后面去）： 1&lt;meta http-equiv="Pragma" content="no-cache"&gt; 它告诉浏览器每次请求页面时都不要读缓存，都得往服务器发一次请求才行。 事实上这种禁用缓存的形式用处很有限： 仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别Cache-Control: no-store的meta标签（见出处）。 在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求（仅限页面，页面上的资源则不受影响）。 Expires有了Pragma来禁用缓存，自然也需要有个东西来启用缓存和定义缓存时间，对http1.0而言，Expires就是做这件事的首部字段。Expires的值对应一个GMT（格林尼治时间），比如“Mon, 22 Jul 2017 11:12:01 GMT”来告诉浏览器资源缓存过期时间，如果还没过该时间点则不发请求。在客户端我们同样可以使用meta标签来知会IE（也仅有IE能识别）页面（同样也只对页面有效，对页面上的资源无效）缓存时间： 1&lt;meta http-equiv="expires" content="mon, 18 apr 2016 14:30:00 GMT"&gt; 如果希望在IE下页面不走缓存，希望每次刷新页面都能发新请求，那么可以把content里的值写为“-1”或“0”。注意的是该方式仅仅作为知会IE缓存时间的标记，你并不能在请求或响应报文中找到Expires字段。如果是在服务端报头返回Expires字段，则在任何浏览器中都能正确设置资源缓存的时间。 通过Pragma禁用缓存，又给Expires定义一个还未到期的时间，刷新页面时发现均发起了新请求，Pragma字段的优先级会更高。 离线应用离线应用之AppCache已废弃，使用Service Workers代替HTML5 提供一种应用程序缓存机制，使得基于web的应用程序可以离线运行。开发者可以使用 Application Cache (AppCache) 接口设定浏览器应该缓存的资源并使得离线用户可用。 在处于离线状态时，即使用户点击刷新按钮，应用也能正常加载与工作。 启用应用缓存服务端：在服务器上添加MIME TYPE支，让服务器能够识别manifest后缀的文件,AddType text/cache-manifest manifest 前端页面： 123&lt;html manifest="example.appcache"&gt; ...&lt;/html&gt; manifest 特性与 缓存清单(cache manifest) 文件关联，这个文件包含了浏览器需要为你的应用程序缓存的资源(文件)列表。你应当在每一个意图缓存的页面上添加 manifest 特性。浏览器不会缓存不带有manifest 特性的页面，除非这个页面已经被写在清单文件内的列表里了。你没有必要添加所有你意图缓存的页面的清单文件，浏览器会暗中将用户访问过的并带有 manifest 特性的所有页面添加进应用缓存中。 缓存清单缓存清单文件中的段落： CACHE， NETWORK，与 FALLBACK CACHE:这是缓存文件中记录所属的默认段落。在 CACHE: 段落标题后(或直接跟在 CACHE MANIFEST 行后)列出的文件会在它们第一次下载完毕后缓存起来。 NETWORK:在 NETWORK: 段落标题下列出的文件是需要与服务器连接的白名单资源。所有类似资源的请求都会绕过缓存，即使用户处于离线状态。可以使用通配符。 FALLBACK:FALLBACK: 段指定了一个后备页面，当资源无法访问时，浏览器会使用该页面。该段落的每条记录都列出两个 URI—第一个表示资源，第二个表示后备页面。两个 URI 都必须使用相对路径并且与清单文件同源。可以使用通配符。 CACHE， NETWORK， 和 FALLBACK 段落可以以任意顺序出现在缓存清单文件中，并且每个段落可以在同一清单文件中出现多次。 123456789101112131415CACHE MANIFEST# v1 2011-08-14# This is another commentindex.htmlcache.htmlstyle.cssimage1.png# Use from network if availableNETWORK:network.html# Fallback contentFALLBACK:/ fallback.html 加载文档使用AppCache文档加载流程： 如果应用缓存存在，浏览器直接从缓存中加载文档与相关资源，不会访问网络。这会提升文档加载速度。 浏览器检查清单文件列出的资源是否在服务器上被修改。 如果清单文件被更新了, 浏览器会下载新的清单文件和相关的资源。 这都是在后台执行的，基本不会影响到webapp的性能。 存在问题缓存文件更新控制不灵活:就目前HTML5提供的manifest机制来讲，一个页面只能引用一个manifest页面，而且一旦发现这个manifest改变了，就会把里面所有定义的缓存文件全部重新拉取一遍，不管实际上有没有更新，控制比较不灵活。针对这个问题，也有的同学提出了一些建议，比如把需要缓存的文件分模块切分到不同manifest中，并分开用HTML引用，再使用强大的iframe嵌入到入口页面，这样就当某一个模式需要有更新，不会导致其他模块的文件也重新拉取一遍。 离线应用之Service WorkersAppCache — 看起来是个不错的方法，因为它可以很容易地指定需要离线缓存的资源。但是它假定你使用时会遵循诸多规则，如果你不严格遵循这些规则，会出现很大的问题。客户端和服务器之间加入一个Service Workers，主要是为了实现离线处理和消息推送等，让web app可以和native app开始真正意义上的竞争。 使用限制1、非主线程平常浏览器窗口中跑的页面运行的是主JavaScript线程，DOM和window全局变量都是可以访问的。而Service Worker是走的另外的线程，可以理解为在浏览器背后默默运行的一个线程，脱离浏览器窗体，因此，window以及DOM都是不能访问的，此时我们可以使用self访问全局上下文 2、异步Service Worker设计为完全异步，同步API（如XHR和localStorage）不能在Service Worker中使用。Service workers大量使用Promise，因为通常它们会等待响应后继续，并根据响应返回一个成功或者失败的操作，这些场景非常适合Promise 3、https协议Service Worker对协议也有要求，必须是https协议的 Service Worker生命周期 Download – 下载注册的JS文件 Install – 安装 Activate – 激活 12345self.addEventListener('install', function(event) &#123; /* 安装后... */ &#125;);self.addEventListener('activate', function(event) &#123; /* 激活后... */ &#125;);//响应和拦截各种请求self.addEventListener('fetch', function(event) &#123; /* 请求后... */ &#125;); 目前Service Worker的所有应用都是基于上面3个事件的，例如离线开发中，install用来缓存文件，activate用来缓存更新，fetch用来拦截请求直接返回缓存数据。三者构成了完整的缓存控制结构。 Cache和CacheStorageCache直接和请求打交道，CacheStorage和Cache对象打交道，可以直接使用全局的caches属性访问CacheStorage。Cache和CacheStorage的出现让浏览器的缓存类型又多了一个：之前有memoryCache和diskCache，现在又多了个ServiceWorker cache。参见具体API 借助Service Worker和cacheStorage离线开发1.在页面上注册一个Service Worker，例如： 123if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('./cache.js');&#125; 2.将cache.js这个JS中复制如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445var VERSION = 'v1';// 缓存self.addEventListener('install', function(event) &#123; event.waitUntil( caches.open(VERSION).then(function(cache) &#123; //把cache.addAll()方法中缓存文件数组换成你希望缓存的文件数组。 return cache.addAll([ './start.html', './static/jquery.min.js', './static/mm.jpg' ]); &#125;) );&#125;);// 缓存更新self.addEventListener('activate', function(event) &#123; event.waitUntil( caches.keys().then(function(cacheNames) &#123; return Promise.all( cacheNames.map(function(cacheName) &#123; // 如果当前版本和缓存版本不一致 if (cacheName !== VERSION) &#123; return caches.delete(cacheName); &#125; &#125;) ); &#125;) );&#125;);// 捕获请求并返回缓存数据self.addEventListener('fetch', function(event) &#123; event.respondWith(caches.match(event.request).catch(function() &#123; return fetch(event.request); &#125;).then(function(response) &#123; caches.open(VERSION).then(function(cache) &#123; cache.put(event.request, response); &#125;); return response.clone(); &#125;).catch(function() &#123; return caches.match('./static/mm.jpg'); &#125;));&#125;); 参考文献 【Web缓存机制系列】1 – Web缓存的作用与类型 【Web缓存机制系列】2 – Web缓存的作用与类型 浅谈浏览器http的缓存机制 Cache-Control HTTP缓存 【Web缓存机制系列】4 – Web缓存的作用与类型 使用应用缓存 借助Service Worker和cacheStorage缓存及离线开发 Javascript高级程序编程 第三版 浏览器缓存知识小结及应用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>缓存</tag>
        <tag>离线应用</tag>
        <tag>前端优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器渲染原理总结]]></title>
    <url>%2F2017%2F09%2F04%2Fhow-browers-work%2F</url>
    <content type="text"><![CDATA[浏览器主要部件浏览器主要部件图：User Interface用户接口。浏览器中的地址栏、前进后退、书签菜单等。除了网页显示区域以外的都是。Brower engine浏览器引擎。查询与操作渲染引擎的接口。Rendering engine渲染引擎。负责显示请求的内容Data Persistence持久层。HTML5规定了完整的浏览器中的数据库：web databaseNetworking网络。用于网络请求，例如HTTP请求。JavaScript Interpreter用于解析执行JavaScript代码UI Backend绘制基础原件，比如组合框、窗口。 渲染引擎渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。 渲染主流程图：解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 Webkit内核渲染图： Gecko内核渲染图： 尽管webkit和Gecko使用的术语稍有不同，他们的主要流程基本相同。Gecko称可见的格式化元素组成的树为frame树，每个元素都是一个frame，webkit则使用render树这个名词来命名由渲染对象组成的树。Webkit中元素的定位称为布局，而Gecko中称为回流。Webkit称利用dom节点及样式信息去构建render树的过程为attachment，Gecko在html和dom树之间附加了一层，这层称为内容接收器，相当制造dom元素的工厂。 分析上图可知浏览器的渲染页面分为以下几个步骤：(1) 解析 HTML/SVG/XHTML，事实上Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree。 CSS，解析CSS会产生CSS Rule Tree。 Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree。 (2) 渲染解析完成后，浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于DOM树，因为一些像head元素或display:none的东西就没必要放在渲染树中了。CSS 的 Rule Tree主要是为了完成匹配并把CSS Rule附加上Rendering Tree上的每个Element，也就是DOM结点，即所谓的Frame。然后计算每个Frame（也就是每个Element）的位置，这又叫layout和reflow过程。 (3) 绘制最后通过调用操作系统Native GUI的API绘制。 解析HTML解析流程图：解析由两部分组成：分词+构建树。分词是词法分析，把输入解析成符号序列。构建树的过程就是在不断处理分词器完成的节点。除了把元素添加到DOM树上，还会将其添加到一个开放元素堆栈，用于纠正嵌套错误和标签未关闭错误。但其实浏览器比我们想象的更强大更包容。浏览器的错误处理相当统一，虽然这不是当前HTML规范的一部分。当很多格式不良的HTML文档出现在很多网站，浏览器会尝试用和其他浏览器一样的方式修复错误。 DOM树构建图：输出的树，也就是解析树，是由DOM元素及属性节点组成的。DOM和标签基本是一一对应的关系。 CSS树构建图： 渲染渲染基本流程： 计算CSS样式 构建Render Tree Layout – 定位坐标和大小，是否换行，各种position, overflow, z-index属性 …… 正式开画 注意：上图流程中有很多连接线，这表示了Javascript动态修改了DOM属性或是CSS属会导致重新Layout，有些改变不会，就是那些指到天上的箭头，比如，修改后的CSS rule没有被匹配到，等。这里重要要说两个概念，一个是reflow，另一个是repaint。 渲染树与DOM树的关系渲染树与对应DOM树图：渲染对象和Dom元素相对应，但这种对应关系不是一对一的，不可见的Dom元素不会被插入渲染树，例如head元素。另外，display属性为none的元素也不会在渲染树中出现（visibility属性为hidden的元素将出现在渲染树中）。 还有一些Dom元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。例如，select元素有三个渲染对象——一个显示区域、一个下拉列表及一个按钮。同样，当文本因为宽度不够而折行时，新行将作为额外的渲染元素被添加。另一个多个渲染对象的例子是不规范的html，根据css规范，一个行内元素只能仅包含行内元素或仅包含块状元素，在存在混合内容时，将会创建匿名的块状渲染对象包裹住行内元素。 一些渲染对象和所对应的Dom节点不在树上相同的位置，例如，浮动和绝对定位的元素在文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。 重绘和重排当用户与网页交互，或者脚本程序改动修改网页时，前文提到的一些操作将会重复执行，因为网页的内在结构已经发生了改变，即发生重排或重绘。 重绘(repaint)屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变。当改变那些不会影响元素在网页中的位置的元素样式时，譬如background-color(背景色)， border-color(边框色)， visibility(可见性)，浏览器只会用新的样式将元素repaint一次(这就是repaint，或者说重新构造样式)。 重排(reflow/relayout)当改变影响到文本内容或结构，或者元素位置时，reflow或者说重新布局就会发生。reflow意味着元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。这就是reflow，或是Layout。（HTML使用的是flow based layout，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫reflow）reflow 会从&lt;html&gt;这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置，在reflow过程中，可能会增加一些frame，比如一个文本字符串必需被包装起来。 这些改变通常由以下事件触发： DOM操作(元素添加，删除，修改，或者元素顺序的改变); 内容变化，包括表单域内的文本改变; CSS属性的计算或改变(改变元素尺寸、位置); 添加或删除样式表(改变元素尺寸、位置); 更改&#39;class&#39;的属性(改变元素尺寸、位置); 动画效果进行计算和改变 CSS 属性值(改变元素尺寸、位置); 浏览器窗口的操作(缩放，滚动); 当你修改网页的默认字体时。 伪类激活(:hover)。 reflow的成本比repaint的成本高得多的多。DOM Tree里的每个结点都会有reflow方法，一个结点的reflow很有可能导致子结点，甚至父点以及同级结点的reflow。在一些高性能的电脑上也许还没什么，但是如果reflow发生在手机上，那么这个过程是非常痛苦和耗电的。 当然，浏览器不会像上面那样，每改一次样式就 reflow 或 repaint 一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次 reflow ，这又叫异步 reflow 或增量异步 reflow 。但是有些情况浏览器是不会这么做的，比如：resize窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。 浏览器渲染优化 创建有效的 HTML 和 CSS ，不要忘记指定文档编码，比如&lt;meta charset=&quot;utf-8&quot;&gt;。 CSS 样式应该包含在&lt;head&gt;中， Javascript 脚本出现在&lt;body&gt;末尾。 减少 CSS 嵌套层级和选择适当的选择器，可参考 如何提升 CSS 选择器性能。 不要通过 Javascript 逐条修改 DOM 的样式，提前定义好 CSS 的class进行操作。 尽量减少将 DOM 节点属性值放在循环当中，会导致大量读写此属性值。 尽可能的为产生动画的 HTML 元素使用fixed或absolute的position，那么修改他们的 CSS 是不会 reflow 的。注：display:none会触发reflow，而visibility:hidden只会触发repaint，因为没有发现位置变化。 参考文献 How browsers work How browsers work 译文 浏览器的渲染原理简介]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>渲染</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中this与对象原型]]></title>
    <url>%2F2017%2F09%2F03%2Fjs-this-and-proto%2F</url>
    <content type="text"><![CDATA[this参见我的博客this对象 javascript对象参见你不懂JS: this 与对象原型–第三章：对象 JS 中的对象拥有字面形式（比如 var a = { .. }）和构造形式（比如 var a = new Array(..)）。字面形式几乎总是首选，但在某些情况下，构造形式提供更多的构建选项。 许多人声称“Javascript 中的一切都是对象”，这是不对的。对象是六种（或七中，看你从哪个方面说）基本类型之一。对象有子类型，包括 function，还可以被行为特化，比如 [object Array] 作为内部的标签表示子类型数组。对象是键/值对的集合。通过 .propName 或 [&quot;propName&quot;] 语法，值可以作为属性访问。不管属性什么时候被访问，引擎实际上会调用内部默认的 [[Get]] 操作（在设置值时调用 [[Put]] 操作），它不仅直接在对象上查找属性，在没有找到时还会遍历 [[Prototype]] 链（见第五章）。 属性有一些可以通过属性描述符控制的特定性质，比如 writable 和 configurable。另外，对象拥有它的不可变性（它们的属性也有），可以通过使用 Object.preventExtensions(..)、Object.seal(..)、和 Object.freeze(..) 来控制几种不同等级的不可变性。 属性不必非要包含值 —— 它们也可以是带有getter/setter的“访问器属性”。它们也可以是可枚举或不可枚举的，这控制它们是否会在 for..in 这样的循环迭代中出现。 你也可以使用 ES6 的 for..of 语法，在数据结构（数组，对象等）中迭代 值，它寻找一个内建或自定义的 @@iterator 对象，这个对象由一个 next() 方法组成，通过这个 next() 方法每次迭代一个数据。 类类是一种设计模式。许多语言提供语法来启用自然而然的面向类的软件设计。JS 也有相似的语法，但是它的行为和你在其他语言中熟悉的工作原理 有很大的不同。 类意味着拷贝。当一个传统的类被实例化时，就发生了类的行为向实例中拷贝。当类被继承时，也发生父类的行为向子类的拷贝。 多态（在继承链的不同层级上拥有同名的不同函数）也许看起来意味着一个从子类回到父类的相对引用链接，但是它仍然只是拷贝行为的结果。 JavaScript 不会自动地 （像类那样）在对象间创建拷贝。 mixin 模式常用于在 某种程度上 模拟类的拷贝行为，但是这通常导致像显式假想多态那样（OtherObj.methodName.call(this, ...)）难看而且脆弱的语法，这样的语法又常导致更难懂和更难维护的代码。 明确的 mixin 和类 拷贝 又不完全相同，因为对象（和函数！）仅仅是共享的引用被复制，不是对象/函数自身被复制。不注意这样的微小之处通常是各种陷阱的根源。 原型参考文献 你不懂JS: this 与对象原型–第三章：对象 你不懂JS: this 与对象原型–第四章: 混合（淆）“类”的对象]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
        <tag>prototype</tag>
        <tag>this</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中并发编程与事件循环]]></title>
    <url>%2F2017%2F09%2F02%2Fjs-eventLoop%2F</url>
    <content type="text"><![CDATA[Javascript单线程原因JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。 事件循环原理事件循环可视化描述：栈：执行栈堆：存储对象队列：消息队列或任务队列所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。异步任务执行顺序： 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。 主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三步。 只要主线程空了，就会去读取”任务队列”，这就是JavaScript的运行机制。 任务队列特点“任务队列”是一个事件的队列（也可以理解成消息的队列）。只要指定过回调函数，这些事件发生时就会进入”任务队列”，等待主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列”上第一位的事件就自动进入主线程。但是，由于存在后文提到的”定时器”功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间，才能返回主线程。 永不阻塞每一个消息执行完成后，其它消息才会被执行。一个很有趣的事件循环 (event loop) 模型特性在于，Javascript 跟许多其它语言不同，它永不阻塞。通常由事件或者回调函数进行 I/O (input/output)处理 。所以当一个应用正等待IndexedDB 的查询的返回或者一个 XHR 的请求返回时，它仍然可以处理其它事情例如用户输入。 setTimeout和setIntervalsetTimeout调用 setTimeout 函数会在一个时间段过去后在队列中添加一个消息。这个时间段作为函数的第二个参数被传入。如果队列中没有其它消息，消息会被马上处理。但是，如果有其它消息，setTimeout消息必须等待其它消息处理完。因此第二个参数仅仅表示最少的时间而非确切的时间。setTimeout(fn,time)表示经过time时间插入到消息队列中，也就是任务队列中。零延迟 (Zero delay) 并不是意味着回调会立即执行。在零延迟调用setTimeout时，其并不是过了给定的时间间隔后就马上执行回调函数。其等待的时间基于队列里正在等待的消息数量执行完成的时间。 setInterval创建的定时器确保了定时器代码规则的插入到任务队列中。问题是定时器代码可能在代码再次被添加到队列之前还没能完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿。js引擎能避免这个问题，当使用setInteval()时，仅当没有该定时器的任何其他实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中最小时间间隔为指定间隔。这个重复的定时器的规则有两个问题： 某些间隔会被跳过 多个定时器的代码执行之间的间隔比预期要小。 setInterval会产生回调堆积，特别是时间很短的时候。 这个例子中的第 1 个定时器是在 205ms 处添加到队列中的，但是直到过了 300ms 处才能够执行。当执行这个定时器代码时，在 405ms 处又给队列添加了另外一个副本。在下一个间隔，即 605ms 处，第一个定时器代码仍在运行，同时在队列中已经有了一个定时器代码的实例。结果是，在这个时间点上的定时器代码不会被添加到队列中。结果在 5ms 处添加的定时器代码结束之后， 405ms 处添加的定时器代码就立刻执行。 避免这个两个缺点，可使用setTimeout链式调用1234setTimeout(function()&#123;//处理中 setTimeout(arguments.callee, interval);&#125;, interval); 这个模式链式调用了setTimeout()，每次函数执行的时候都会创建一个新的定时器。第二个setTimeout()调用使用了arguments.callee来获取对当前执行的函数的引用，并为其设置另外一个定时器。这样做的好处是，在前一个定时器代码执行完之前，不会向队列插入新的定时器代码，确保不会有任何缺失的间隔。而且，它可以保证在下一次定时器代码执行之前，至少要等待指定的间隔，避免了连续的运行。这个模式主要用于重复定时器。 参考文献 JavaScript 运行机制详解：再谈Event Loop Concurrency model and Event Loop Javascript高级程序设计(第3版)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>eventLoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求幂的高效算法]]></title>
    <url>%2F2017%2F08%2F30%2Fquick-power%2F</url>
    <content type="text"><![CDATA[求解a^n次方，正常求解需要O(n)时间，若n很大，则需要更快速的算法 快速幂基础：任何一个数都可以用二进制表示若需求3^11，可将指数进行一个logN的变换，11 = 2^3 + 2^1 + 2^0，只需算3^8,3^2,3^1，再将其相乘。 123456789101112131415161718192021222324252627282930313233/** * @author zxlg * */import java.math.*;public class Quick_power &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub BigInteger res = quick_power(2,12); System.out.println(res); &#125; // 快速幂 public static BigInteger quick_power(int num, int power) &#123; BigInteger ans = BigInteger.valueOf(1); BigInteger base = BigInteger.valueOf(num); while (power != 0) &#123; // power转为2进制，若该位为1 if ((power &amp; 1) == 1) &#123; ans = ans.multiply(base); &#125; // 转换为基础值，没轮循环为原值的平方 base = base.multiply(base); // power取下一位 power = power &gt;&gt; 1; &#125; return ans; &#125;&#125; 快速幂取模利用了快速幂的思想，但取模时有公式：12a ^ b % c = (a % c)^b % c(a * b) % c=(a % c)*(b % c) % c 123456789101112131415161718192021222324252627public class Quick_power_mod &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub long res = quick_power_mod(2, 15, 100000); System.out.println(res); &#125; // 公式：a^b mod c = (a mod c)^c mod c // b可以转为2进制计算，降低复杂度 public static long quick_power_mod(long num, long base, long mod) &#123; long ans = 1; num = num % mod; while (base != 0) &#123; if ((base &amp; 1) == 1) &#123; ans = ans * num % mod; &#125; num = num * num % mod; base &gt;&gt;= 1; &#125; return ans; &#125;&#125; 二分快速幂矩阵快速幂快速乘参考文献 二分幂，快速幂，矩阵快速幂，快速乘 快速幂取模算法 快速幂取模算法详解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>快速幂</tag>
        <tag>二分快速幂</tag>
        <tag>矩阵快速幂</tag>
        <tag>快速乘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找出100万以内的质数]]></title>
    <url>%2F2017%2F08%2F30%2Fprime-numbers%2F</url>
    <content type="text"><![CDATA[暴力测试最简单的算法，从2枚举到sqrt(n)就可以知道是不是素数了。 费马小定理对于质数n和任意整数a，有a^n ≡ a(mod n)(同余)。反之，若满足a^n≡a(mod n)，n也有很大概率为质数，称n是一个基于a的伪素数。将两边同时约去一个n，则有a^(n−1)≡1(mod n)。 这个定理是来判断一个数字是不是合数的，而不是素数。如果不符费马小定理，一定是合数， 如果符合费马小定理不一定是素数（但是是素数的可能性比较高）。 如果判定n为合数，那么结果一定正确。如果判定n为质数，那么只有当n是基于2的伪素数时才会出错 Miller-Rabin素数检验(米勒-拉宾素数检验)在费马小定理基础上增加了二次判定：如果n是奇素数，则x^2 ≡ 1(mod n)的解为x≡1或x ≡ n−1(mod n) 这个x是：a^(p−1)=a^(2u∗r)，所以p−1=2u∗r，那么x自然也知道了：这个x是一系列的数字，让在指数2^u里拿出一个2就编程2^(u-1) * 2，这样不就有平方了么，剩下的底数就是x了，并且在还可以继续不停的这样操作，到u = 0为止。 Miller-Rabin素数检验仍会出错：如果是素数，不出错，如果为合数，也会小概率出错2^(-s)，所以多次检测，会让错误率变低，这里s是检测次数。 举例说明 举个Matrix67 Blog上的例子，假设n=341，我们选取的a=2。则第一次测试时，2^340 mod 341=1。由于340是偶数，因此我们检查2^170，得到2^170 mod 341=1，满足二次探测定理。同时由于170还是偶数，因此我们进一步检查2^85 mod 341=32。此时不满足二次探测定理，因此可以判定341不为质数。 代码实现参考算法基础 - 素数判定(Miller-Rabin算法)1234567891011121314151617181920212223242526272829303132333435363738394041伪代码：Miller-Rabin(n): If (n &lt;= 2) Then If (n == 2) Then Return True End If Return False End If If (n mod 2 == 0) Then // n为非2的偶数，直接返回合数 Return False End If // 我们先找到的最小的a^u，再逐步扩大到a^(n-1) u = n - 1; // u表示指数 while (u % 2 == 0) u = u / 2 End While // 提取因子2 For i = 1 .. S // S为设定的测试次数 a = rand_Number(2, n - 1) // 随机获取一个2~n-1的数a x = a^u % n tu = u While (tu &lt; n) // 依次次检查每一个相邻的 a^u, a^2u, a^4u, ... a^(2^k*u)是否满足二次探测定理 y = x^2 % n If (y == 1 and x != 1 and x != n - 1) // 二次探测定理 // 若y = x^2 ≡ 1(mod n) // 但是 x != 1 且 x != n-1 Return False End If x = y tu = tu * 2 End While If (x != 1) Then // Fermat测试 Return False End If End For Return True Java代码编写：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import java.math.*;import java.util.*;/** * @author zxlg * */public class All_primes_in_million &#123; /** * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub print_all_prime_in_million(10000); &#125; public static void print_all_prime_in_million(int n) &#123; ArrayList&lt;Integer&gt; arr = new ArrayList&lt;Integer&gt;(); for (int i = 0; i &lt; n; i++) &#123; if (Miller_Rabin(i)) &#123; arr.add(i); &#125; &#125; System.out.println(arr.toString()); System.out.println(n + "以内共有" + arr.size() + "个素数"); &#125; public static boolean Miller_Rabin(int n) &#123; // 小于2的情况 if (n &lt;= 2) &#123; if (n == 2) &#123; return true; &#125; return false; &#125; // 偶数 if (n % 2 == 0) &#123; return false; &#125; // 先找到的最小的a^u，再逐步扩大到a^(n-1) int u = n - 1;// u表示指数 int S = 20;// 检测次数 // 提取公因子2 while (u % 2 == 0) &#123; u /= 2; &#125; for (int i = 0; i &lt; S; i++) &#123; // 随机选取2~n-1之间的数a int a = (int) (Math.random() * 2 + (n - 3)); // x = a^u % n int x = quick_power(a, u).mod(BigInteger.valueOf(n)).intValue(); int tu = u; // 依次次检查每一个相邻的 a^u, a^2u, a^4u, ... a^(2^k*u)是否满足二次探测定理 while (tu &lt; n) &#123; int y = x * x % n; if (y == 1 &amp;&amp; x != 1 &amp;&amp; x != n - 1) &#123;// 二次探测定理 // 若y = x^2 ≡ 1(mod n) // 但是 x != 1 且 x != n-1 return false; &#125; x = y; tu = tu * 2; &#125; if (x != 1) &#123; // 费马测试 return false; &#125; &#125; return true; &#125; // 快速幂 public static BigInteger quick_power(int num, int power) &#123; BigInteger ans = BigInteger.valueOf(1); BigInteger base = BigInteger.valueOf(num); while (power != 0) &#123; // power转为2进制，若该位为1 if ((power &amp; 1) == 1) &#123; ans = ans.multiply(base); &#125; // 转换为基础值，没轮循环为原值的平方 base = base.multiply(base); // power取下一位 power = power &gt;&gt; 1; &#125; return ans; &#125;&#125; 参考文献 算法基础 - 素数判定(Miller-Rabin算法)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>素数</tag>
        <tag>数论</tag>
        <tag>Miller-Rabin算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序算法总结]]></title>
    <url>%2F2017%2F08%2F28%2Fsort-algorithm%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6常用性质总结]]></title>
    <url>%2F2017%2F08%2F23%2FES6%2F</url>
    <content type="text"><![CDATA[class箭头函数异步]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows下node版本管理]]></title>
    <url>%2F2017%2F08%2F23%2Fwindows-node-version-control%2F</url>
    <content type="text"><![CDATA[原因因为ES6的兴起，很多新特性在浏览器中实现不了，甚至低版本的node也不能实现，所以需要一个node版本管理工具，nvm不支持windows，但nvm-windows支持，也持续在更新。 安装nvm-windows nvm-windows发行版nvm_noinstall.zip下载 把nvm_noinstall.zip解压到比如c:/dev/nvm中 右键以管理员的身份运行install.cmd,直接按回车,在C盘根目录下会生成一个setting.txt,并拷贝到C:/dev/nvm，并修改内容如下: 123456root: C:\dev\nvmpath: C:\dev\nodejsarch: 64proxy: nonenode_mirror: http://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/ 配置环境变量打开‘控制面板主页-&gt;高级系统设置-&gt;高级-&gt;环境变量’后会有‘用户变量’和‘系统变量’两个选项，建议在‘用户变量’里面设置： 12NVM_HOME:C:\dev\nvmNVM_SYMLINK:C:\dev\nodejs 在PATH的最后添加%NVM_HOME%;%NVM_SYMLINK%; npm全局安装 123npm config set prefix &quot;c:\dev\nvm\npm&quot; # 配置用npm下载包时全局安装的包路径npm install npm -g --registry=https://registry.npm.taobao.orgnpm set registry https://registry.npm.taobao.org # 注册模块镜像 配置npm环境变量变量名: NPM_HOME,变量值: c:\dev\nvm\npm在PATH的最后添加%NPM_HOME%;,要放在NVM_SYMLINK之前 参考文献 windows安装nvm的两种方式 npm淘宝镜像配置]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>node</tag>
        <tag>nvm</tag>
        <tag>nvm-windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS定宽+自适应布局]]></title>
    <url>%2F2017%2F08%2F22%2Fcss-double-columns-and-three-columns%2F</url>
    <content type="text"><![CDATA[定宽+自适应两列布局absolute + margin12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;main&quot;&gt;主列&lt;/div&gt; &lt;div class=&quot;sidebar&quot;&gt;边栏&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;footer&quot;&gt;&lt;/div&gt; 1234567891011121314151617181920212223.container&#123; position: relative; /* overflow: hidden; */&#125;.main&#123; margin-left:350px; height: 500px; background-color: rgba(0,255,0,.5);&#125;.sidebar&#123; position: absolute; top: 0; left:0; width: 300px; height:650px; background-color: rgba(255,0,0,.5);&#125;.footer&#123; width : 100%; height : 300px; margin-top : 50px; background-color: rgba(0,0,255,.5);&#125; 优点： 支持主列和边栏顺序互换 支持主列优先显示，即优先加载渲染 缺点：因为sidebar列脱离了文档流，当sidebar列比main列高时会覆盖后面的布局：点击查看在线demo。如果在container容器上添加overflow:hidden就会使sidebar溢出部分被裁减。在这种布局方式下，这个问题确实没有有效的解决办法。 float + margin12&lt;div class=&quot;sidebar&quot;&gt;边栏&lt;/div&gt;&lt;div class=&quot;main&quot;&gt;主列&lt;/div&gt; 1234567891011.main&#123; margin-left:210px; height: 200px; background-color: rgba(0,255,0,.5); &#125;.sidebar&#123; float: left; width: 200px; height:250px; background-color: rgba(255,0,0,.5);&#125; 点击查看在线demo优点：左右两列顺序可互换缺点：不支持主列优先显示 float + 负margin(双飞翼布局)1234&lt;div class=&quot;main-wrapper&quot;&gt; &lt;div class=&quot;main&quot;&gt;主列&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;sidebar&quot;&gt;边栏&lt;/div&gt; 1234567891011121314151617.main-wrapper&#123; float:left; width:100%;&#125;.main&#123; margin-left:350px; height: 300px; background-color: rgba(0,255,0,.5);&#125;.sidebar&#123; float: left; width: 300px; height:400px; margin-left: -100%; background-color: rgba(255,0,0,.5);&#125; 点击查看在线demo这个布局即为双飞翼布局，双飞翼布局源自淘宝UED，现在查看下淘宝店铺的DOM结构，就能找到双飞翼布局的身影。实现过程： 首先浮动main列和sidebar列，然后通过负margin正确定位sidebar列。 把main列嵌套在一个div里，该div的宽度值设为100%。 最后通过设置main列的margin-left消除被sidebar覆盖的部分即可。 双飞翼布局优点： DOM按照主、子、附加列的顺序加载，实现了重要内容先加载。 main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。 在浏览器上的兼容性非常好，IE5.5以上都支持。 实现了内容与布局的分离，即Eric提到的Any-Order Columns. 任何一栏都可以是最高栏，不会出问题。 需要的hack非常少。 两列定宽+自适应三列布局圣杯布局圣杯布局源自 Matthew Levine 在06年的一篇文章，其DOM结构如下：12345&lt;div class=&quot;container&quot;&gt; &lt;div class=&apos;main&apos;&gt;主体&lt;/div&gt; &lt;div class=&apos;sub&apos;&gt;边栏&lt;/div&gt; &lt;div class=&quot;extra&quot;&gt;另一边栏&lt;/div&gt;&lt;/div&gt; 实现圣杯布局的步骤 首先要使得main,sub,extra三列浮动，然后利用负margin将sub和extra定位到main两边 1234567891011121314151617181920.main&#123; float:left; height:100px; width:100%; background-color:rgba(255,0,0,.5);&#125;.sub&#123; float:left; height:100px; width:200px; margin-left:-100%; background-color:rgba(0,255,0,.5);&#125;.extra&#123; float:left; height:100px; width:100px; margin-left:-100px; background-color:rgba(0,0,255,.5);&#125; sub和extra定位到main两边，但是覆盖了main列，圣杯布局对container容器添加边距，使得main列出现在正确的位置 12345678.container&#123; height:100px; /*第二步添加*/ padding-left:210px; padding-right:110px;&#125; 对container容器添加内边距虽然让main列出现在正确的位置，但是也使得sub和extra列因为内边距影响偏离了原来的位置。圣杯布局使用相对定位让sub和extra列出现在正确的位置。 12345678910111213141516171819202122.sub&#123; float:left; height:100px; width:200px; margin-left:-100%; background-color:rgba(0,255,0,.5); /*第三步添加*/ position:relative; left:-210px;&#125;.extra&#123; float:left; height:100px; width:100px; margin-left:-100px; background-color:rgba(0,0,255,.5); /*第三步添加*/ position:relative; right:-110px;&#125; 当浏览器缩小到一定程度时，这个布局可能会被破坏，可以在body上添加min-width属性解决。最终的圣杯布局CSS代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940body&#123; /*第四步添加*/ min-width:520px; /* 2*sub + extra */&#125;.container&#123; height:100px; /*第二步添加*/ padding-left:210px; padding-right:110px;&#125;.main&#123; float:left; width:100%; height:100px; background-color:rgba(255,0,0,.5);&#125;.sub&#123; float:left; height:100px; width:200px; margin-left:-100%; background-color:rgba(0,255,0,.5); /*第三步添加*/ position:relative; left:-210px;&#125;.extra&#123; float:left; height:100px; width:100px; margin-left:-100px; background-color:rgba(0,0,255,.5); /*第三步添加*/ position:relative; right:-110px;&#125; 点击查看在线demo 优点： 使主要内容列先加载。 允许任何列是最高的。 没有额外的div。 需要的hack很少。 和双飞翼布局比较和圣杯布局一样，分别浮动main、sub和extra列，然后利用负外边距正确定位sub和extra列。这时依旧面临和圣杯布局同样的问题：main列没有正确定位且被sub、extra列覆盖。双飞翼布局的解决办法是在main列外面包裹了一个宽度100%的div，然后通过设置main列的左、右外边距正确定位main列。 异同点： 俩种布局方式都是把主列放在文档流最前面，使主列优先加载。 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。 两种布局方式的不同之处在于如何处理中间主列的位置：圣杯布局是利用父容器的左、右内边距定位；双飞翼布局是把主列嵌套在div后利用主列的左、右外边距定位。 参考文献 浅析圣杯布局和双飞翼布局]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>双飞翼布局</tag>
        <tag>圣杯布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精通CSS笔记与心得]]></title>
    <url>%2F2017%2F08%2F22%2Fcss-note%2F</url>
    <content type="text"><![CDATA[2017-08-24更新 基础知识文档类型DOCTYP切换浏览器模式 CSS选择器常用选择器类型选择器后代选择器ID选择器类选择器伪类(伪类连接) 通用选择器高级选择器子选择器和通报选择器属性选择器层叠和特殊性层叠次序： 标有important的用户样式。 标有important的作者样式。 作者样式 用户样式 浏览器/用户代理的样式然后根据选择器的特殊性决定规则的次序，具有更特殊选择器的规则优于具有一般选择器的规则。如果两个规则的特殊性相同，那么后定义的规则优先。特殊性的四个等级： 行内样式 ID选择器的总数 类，伪类，属性选择器的总数 类型选择器和伪类选择器的数量 HTML中引入CSS有 4 种方式可以在 HTML 中引入 CSS。其中有 2 种方式是在 HTML 文件中直接添加 CSS 代码，另外两种是引入外部 CSS 文件。 内联方式内联方式指的是直接在 HTML 标签中的style属性中添加 CSS。示例：` 这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个拥有相同的样式，你不得不重复地为每个添加相同的样式，如果想要修改一种样式，又不得不修改所有的style中的代码。很显然，内联方式引入CSS`代码会导致 HTML 代码变得冗长，且使得网页难以维护。 嵌入方式嵌入方式指的是在 HTML 头部&lt;head&gt;中的&lt;style&gt;标签下书写 CSS 代码。示例：123456789&lt;head&gt; &lt;style&gt; .content &#123; background: red; &#125; &lt;/style&gt;&lt;/head&gt; 嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。 链接方式链接方式指的是使用 HTML 头部的&lt;head&gt;标签中通过&lt;link&gt;标签引入外部的 CSS 文件。示例：123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;&lt;/head&gt; 这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。 导入方式导入方式指的是使用 CSS 规则引入外部 CSS 文件。示例：123&lt;style&gt; @import url(style.css);&lt;/style&gt; 比较链接方式和导入方式链接方式（下面用 link 代替）和导入方式（下面用 @import 代替）都是引入外部的 CSS 文件的方式link 属于 HTML，通过&lt;link&gt;标签中的href属性来引入外部文件，而 @import 属于 CSS，所以导入语句应写在 CSS 中，要注意的是导入语句应写在样式表的开头，否则无法正确导入外部文件；@import 是 CSS2.1 才出现的概念，所以如果浏览器版本较低，无法正确导入外部样式文件；当 HTML 文件被加载时，link 引用的文件会同时被加载，而 @import 引用的文件则会等页面全部下载完毕再被加载；综上不推荐使用 @import。 删除注释和优化样式表脚本删除注释CSS压缩 CSS盒子模型W3C盒模型和IE盒子模型W3C盒子 = 内容 + 内边距 + 边框 + 外边距IE盒子 = 内容 + 外边距（IE的内容包含了内边距和边框）CSS中box-sizing定义使用何种盒子模型 2017-08-25更新 外边距叠加CSS定位普通流相对定位，相对于元素在文档流中的初始位置定位，元素仍然占据原来的空间。 绝对定位相对于距离最近的已定位的祖先元素，若不存在，那么相对于初始包含块。不占据空间，和文档普通流无关。可以覆盖页面上的其他元素，可以通过z-index属性控制这些框的叠放顺序。 固定定位：相对于视口的绝对定位。 浮动和清除浮动浮动可以左右移动，直到它的外边缘碰到包含框或另一个浮动框的边缘。浮动框不在文档的普通流中。 使用clear清除浮动，对元素进行清除浮动实际上是为前面的浮动元素留出了垂直空间。 背景图像效果圆角css3: border-radius 阴影css3 ；box-shadow 不透明度和RGBa对链接应用样式 2017-08-28更新 CSS精灵对列表应用样式和导航条对表单和数据表格应用样式布局参考文献 HTML 中引入 CSS 的方式]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript继承总结]]></title>
    <url>%2F2017%2F08%2F22%2Fjs-inherit%2F</url>
    <content type="text"><![CDATA[面向对象的语言一般都支持接口继承和实现继承，而Javascript的函数没有签名，所以只支持实现继承。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git原理和常用命令总结]]></title>
    <url>%2F2017%2F08%2F21%2Fgit-understand-and-common-commands%2F</url>
    <content type="text"><![CDATA[git存储原理内容寻址文件系统 git常用命令1234567git addgit commitgit pushgit pullgit resetgit reflog # 查看全部操作纪录，可回退到由于重置而导致的纪录丢失git cherry-pick git http免密登录 新建git-credentials文件touch ~/git-credentials, window中为用户文件夹下新建git-credentials文件 编辑git-credentials文件vim gitgit-credentials, 添加https://{用户名}:{密码}@github.com 使得git-credentials生效执行git config --global credential.helper store 查看~/.gitconfig文件变化多了如下代码: 12[credential] helper = store]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git push error解决方案]]></title>
    <url>%2F2017%2F08%2F20%2Fgit-push-error%2F</url>
    <content type="text"><![CDATA[操作过程校园网git push推送时出现1234567891011ssh_dispatch_run_fatal: Connection to 192.30.255.112: Software caused connection abortfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&apos;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: ssh_dispatch_run_fatal: Connection to 192.30.255.112: Software caused connection abortfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 更改公钥再进行push依旧出错，测试SSH连接123$ ssh -T git@github.comssh: connect to host github.com port 22: Connection timed outHi gongzhibin! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 连接成功 git提供了https、git、ssh三种协议来读写。运行git config --local -e打开配置信息。修改其中的1url = git@github.com:username/repo.git 为https协议1url = https://username@github.com/username/repo.git git push需要填写用户名和密码回去使用宿舍网可以SSH上传，可能是学校网络出问题了，禁用了SSH的22端口导致的。 参考文献 提交代码到GitHub SSH错误解决方案]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML笔记]]></title>
    <url>%2F2017%2F08%2F20%2Fhtml-note%2F</url>
    <content type="text"><![CDATA[2017.08.20更新 锚点链接HTML链接 - name 属性 name 属性规定锚（anchor）的名称。使用 name 属性创建 HTML 页面中的书签。书签不会以任何特殊方式显示，它对读者是不可见的。当使用命名锚（named anchors）时，我们可以创建直接跳至该命名锚（比如页面中某个小节）的链接，这样使用者就无需不停地滚动页面来寻找他们需要的信息了。 语法1&lt;a name=&quot;label&quot;&gt;锚（显示在页面上的文本）&lt;/a&gt; 可以使用 id 属性来替代 name 属性，命名锚同样有效。 创建:1&lt;a name=&quot;tips&quot;&gt;基本的注意事项 - 有用的提示&lt;/a&gt; 使用：1&lt;a href=&quot;#tips&quot;&gt;有用的提示&lt;/a&gt; 在其他页面中创建指向该锚的链接：1&lt;a href=&quot;http://www.w3school.com.cn/html/html_links.asp#tips&quot;&gt;有用的提示&lt;/a&gt; 将#符号和锚名称添加到URL的末端，就可以链接到tips这个锚。 参考文献 HTML 链接]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的设计模式总结]]></title>
    <url>%2F2017%2F08%2F20%2Fjs-design-pattern%2F</url>
    <content type="text"><![CDATA[————————————————————————2017-08-21 更新———————————————————————— 工厂模式123456789101112function createPerson(name,age)&#123; var obj = new Object(); obj.name = name; obj.age = age; obj.sayName = function()&#123; console.log(obj.name) &#125; return obj;&#125;var person1 = createPerson(&apos;Tom&apos;,20);var person2 = createPerson(&apos;zxlg&apos;,24); 工厂模式解决创建多个相似对象的问题，但是没有解决对象识别的问题，即怎样知道一个变量的类型 构造函数模式12345678910function Person(name,age)&#123; obj.name = name; obj.age = age; obj.sayName = function()&#123; console.log(obj.name) &#125; &#125;var person1 = new Person(&apos;Tom&apos;,20);var person2 = new Person(&apos;zxlg&apos;,24); Person()与createPerson()不同之处： 没有显式地创建对象； 直接将属性和方法赋给了 this 对象； 没有return语句 要创建实例，必须使用new操作符，经历4个步骤 创建一个新对象 将构造函数的作用域赋给新对象 执行构造函数的代码 返回新对象 123456person1.constructor == Person; //trueperson2.constructor == Person; //trueperson1 instanceof Object; //trueperson1 instanceof Person; //trueperson2 instanceof Object; //trueperson2 instanceof Person; //true 所有实例对象都有相同的constructor(构造函数属性)，指向构造函数。对象的constructor属性最初是用来标识对象类型的，可以用instanceof操作符检测对象类型。创造自定义的构造函数意味着将来可以将它的实例标识为一种特定的类型,而这正是构造函数模式胜过工厂模式的地方。 构造函数当作函数12345678910// 当作构造函数使用var person = new Person(&quot;liuli&quot;, 23);person.sayName(); //&quot;liuli&quot;// 作为普通函数调用Person(&quot;zhangfan&quot;, 26); // 添加到 windowwindow.sayName(); //&quot;zhangfan&quot;// 在另一个对象的作用域中调用var o = new Object();Person.call(o, &quot;chenming&quot;, 24);o.sayName(); //&quot;chenming&quot; 不使用new操作符调用Person()会出现什么结果：属性和方法都被添加给window对象了。也可以使用call()（或者 apply()）在某个特殊对象的作用域中调用Person()函数。 构造函数缺点使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。创建两个完成同样任务的Function实例的确没有必要。 原型模式我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。123456789101112function Person()&#123;&#125;Person.prototype.name = &quot;zxlg&quot;;Person.prototype.age = 24;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //&quot;zxlg&quot;var person2 = new Person();person2.sayName(); //&quot;zxlg&quot;person1.sayName == person2.sayName; //true 原型的动态性由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。12345var friend = new Person();Person.prototype.sayHi = function()&#123; alert(&quot;hi&quot;);&#125;;friend.sayHi(); //&quot;hi&quot;（没有问题！） 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。实例中的指针仅指向原型，而不指向构造函数。123456789101112function Person() &#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name: &quot;zxlg&quot;, age: 24, sayName: function () &#123; alert(this.name); &#125;&#125;;friend.sayName(); //error 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型 原型模式的问题它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便，但还不是原型的最大问题。原型模式的最大问题是由其共享的本性所导致的。原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。对于包含引用类型值的属性来说，问题就比较突出了。1234567891011121314151617function Person() &#123;&#125;Person.prototype = &#123; constructor: Person, name: &quot;zxlg&quot;, age: 24, friends: [&quot;whb&quot;, &quot;zf&quot;], sayName: function () &#123; alert(this.name); &#125;&#125;;var person1 = new Person();var person2 = new Person();person1.friends.push(&quot;cm&quot;);person1.friends; //&quot;whb&quot;, &quot;zf&quot;, &quot;cm&quot;person2.friends; //&quot;whb&quot;, &quot;zf&quot;, &quot;cm&quot;person1.friends === person2.friends; //true 在此，Person.prototype对象有一个名为friends的属性，该属性包含一个字符串数组。然后，创建了Person的两个实例。接着，修改了person1.friends引用的数组，向数组中添加了一个字符串。由于friends数组存在于Person.prototype而非person1中，所以刚刚提到的修改也会通过person2.friends（与person1.friends指向同一个数组）反映出来。假如我们的初衷就是像这样在所有实例中共享一个数组，那么对这个结果我没有话可说。可是，实例一般都是要有属于自己的全部属性的。而这正是单独使用原型模式的问题所在。 组合模式创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。` 动态原型模式寄生构造函数模式稳妥构造函数模式参考文献 Javascript高级程序设计(第三版)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript原型对象和原型链]]></title>
    <url>%2F2017%2F08%2F20%2Fjs-prototype-and-proto%2F</url>
    <content type="text"><![CDATA[函数原型对象和原型123456789101112function Person()&#123;&#125;Person.prototype.name = &quot;zxlg&quot;;Person.prototype.age = 24;Person.prototype.sayName = function()&#123; console.log(this.name);&#125;;var person1 = new Person();person1.sayName(); //&quot;zxlg&quot;var person2 = new Person();person2.sayName(); //&quot;zxlg&quot;person1.sayName == person2.sayName; //true 无论什么时候，只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向 prototype属性所在函数的指针。上述代码中Person.prototype.constructor指向Person。 创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型对象。 ECMA-262 第 5 版中管这个指针叫[[Prototype]]。虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、 Safari 和 Chrome 在每个对象上都支持一个属性__proto__；而在其他实现中，这个属性对脚本则是完全不可见的。这个连接存在于实例与构造函数的原型对象之间，而不是存在于实例与构造函数之间。上述代码中person1和person2的[[Prototype]]指向构造函数的原型对象Person.prototype 获取[[Prototype]]可以通过isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回true。12Person.prototype.isPrototypeOf(person1); //truePerson.prototype.isPrototypeOf(person2); //true 可以通过Object.getPrototypeOf()方法返回[[Prototype]]的值。12Object.getPrototypeOf(person1) == Person.prototype; //trueObject.getPrototypeOf(person1).name; //&quot;zxlg&quot; 原型链每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。直到最顶端，也就是原型链的实现过程。 重写原型的值虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。添加这个属性只会阻止我们访问原型中的那个属性，但不会修改那个属性。即使将这个属性设置为null，也只会在实例中设置这个属性，而不会恢复其指向原型的连接。但使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性。1234person1.name = &quot;Tom&quot;person1.sayName(); //&quot;Tom&quot;delete person1.name;person1.sayName(); //&quot;zxlg&quot; 属性访问 in in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。 hasOwnProperty() 使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法 （不要忘了它是从 Object继承来的）只在给定属性存在于对象实例中时，才会返回true。 Object.keys() 要取得对象上所有可枚举的实例属性，可以使用 ECMAScript 5 的Object.keys()方法 原型语法前面例子中每添加一个属性和方法就要敲一遍Person.prototype。为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象123456789function Person()&#123;&#125;Person.prototype = &#123; name : &quot;zxlg&quot;, age : 24, sayName : function () &#123; console.log(this.name); &#125;&#125;; 在上面的代码中，将Person.prototype设置为等于一个以对象字面量形式创建的新对象。最终结果相同，但有一个例外： constructor属性不再指向Person。每创建一个函数，就会同时创建它的prototype对象，这个对象也会自动获得 constructor属性。而我们在这里使用的语法，本质上完全重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性 （指向Object构造函数），不再指向Person函数。此时尽管instanceof操作符还能返回正确的结果，但通过constructor已经无法确定对象的类型了，如下所示。12345var friend = new Person();friend instanceof Object; //truefriend instanceof Person; //truefriend.constructor == Person; //falsefriend.constructor == Object; //true 如果constructor的值真的很重要，可以将其加入prototype中,并使用Object.defineProperty()将其[[Enumerable]]特性被设置为false 原型的动态性由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。12345var friend = new Person();Person.prototype.sayHi = function()&#123; alert(&quot;hi&quot;);&#125;;friend.sayHi(); //&quot;hi&quot;（没有问题！） 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。实例中的指针仅指向原型，而不指向构造函数。123456789101112function Person() &#123;&#125;var friend = new Person();Person.prototype = &#123; constructor: Person, name: &quot;zxlg&quot;, age: 24, sayName: function () &#123; alert(this.name); &#125;&#125;;friend.sayName(); //error 重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型 原生对象的原型所有原生的引用类型都是采用这种模式创建的。所有原生引用类型（Object、Array、 String，等等）都在其构造函数的原型上定义了方法。 参考文献 一个例子让你彻底明白原型对象和原型链 Javascript高级程序编程(第三版)]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
        <tag>原型对象</tag>
        <tag>prototype</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题升级]]></title>
    <url>%2F2017%2F08%2F19%2Fnext-theme-upgrade%2F</url>
    <content type="text"><![CDATA[版本升级目前升级 NexT 主题的时候并不是非常的流畅。若使用git pull的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的_config.yml文件。在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点： 配置分离成了两个部分 用户可能会疑惑一些选项该放置在哪里比较合适 为了解决这个问题， NexT 将会使用 Hexo 的Data Files。然而由于Data Files是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。 特性通过这个特性，你可以将所有的主题配置放置在站点的source/_data/next.yml文件中。原先放置在站点配置文件中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在next.yml中做相应调整即可。 使用请先确保你所使用的 Hexo 版本在 3 以上在站点的source/_data目录下新建next.yml文件（_data目录可能需要新建）迁移站点配置文件和主题配置文件中的配置到next.yml中 vendors文件夹404本地预览没问题，但是deploy到github之后，主页只显示个空白背景。原因：github page在November 3, 2016更新内容中https://github.com/blog/2277-what-s-new-in-github-pages-with-jekyll-3-3Jekyll now ignores the vendor and node_modules directories by default. 解决方案一： 手动将source/vendors目录修改成source/lib；同时，修改下主题配置文件_config.yml，将_internal: vendors修改为_internal: lib 解决方案二： 更新作者的最新程序(不建议自己有较大改动的进行此操作)。 其他 修改搜索菜单 添加canvas 添加文章更新时间 2017.08.20更新 hexo server无法访问可能是4000端口被占用hexo sever -p 4001更换其他端口 在node_modules\hexo-server\index.js文件，可以修改默认的port值 参考文献 NexT主题升级 vendors文件夹处理 使用localhost:4000访问本地blog一直无响应]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴在线笔试]]></title>
    <url>%2F2017%2F08%2F17%2Falibaba-interview%2F</url>
    <content type="text"><![CDATA[前端题目利用面向对象思想完成买家信息删除功能，每一条买家信息包含 姓名 (name) 性别 (sex) 电话号码 (number) 省份 (province) 要求 不能借助任何三方库，需使用原生代码实现 结合给出的基本代码结构，在下方2处code here处补充代码，完成买家信息的删除功能，注意此页面需要在手机上清晰显示。 js代码可任意调整，例如可使用es6语法完成 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--code here--&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .head, li div &#123; display: inline-block; width: 70px; text-align: center; &#125; li .id, li .sex, .id, .sex &#123; width: 15px; &#125; li .name, .name &#123; width: 40px; &#125; li .tel, .tel &#123; width: 90px; &#125; li .del, .del &#123; width: 15px; &#125; ul &#123; list-style: none; &#125; .user-delete &#123; cursor: pointer; &#125; @media screen and (max-width: 768px) &#123; //宽度小于768px时 .head, li div &#123; display: inline-block; width: 23.3%; text-align: center; &#125; li .id, li .sex, .id, .sex &#123; width: 5%; &#125; li .name, .name &#123; width: 13.3%; &#125; li .tel, .tel &#123; width: 30%; &#125; li .del, .del &#123; width: 5%; &#125; ul &#123; list-style: none; &#125; .user-delete &#123; cursor: pointer; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;J_container&quot;&gt; &lt;div class=&quot;record-head&quot;&gt; &lt;div class=&quot;head id&quot;&gt;序号&lt;/div&gt; &lt;div class=&quot;head name&quot;&gt;姓名&lt;/div&gt; &lt;div class=&quot;head sex&quot;&gt;性别&lt;/div&gt; &lt;div class=&quot;head tel&quot;&gt;电话号码&lt;/div&gt; &lt;div class=&quot;head province&quot;&gt;省份&lt;/div&gt; &lt;div class=&quot;head&quot;&gt;操作&lt;/div&gt; &lt;/div&gt; &lt;ul id=&quot;J_List&quot;&gt; &lt;li&gt; &lt;div class=&quot;id&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;张三&lt;/div&gt; &lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt; &lt;div class=&quot;tel&quot;&gt;13788888888&lt;/div&gt; &lt;div class=&quot;province&quot;&gt;浙江&lt;/div&gt; &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;id&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;李四&lt;/div&gt; &lt;div class=&quot;sex&quot;&gt;女&lt;/div&gt; &lt;div class=&quot;tel&quot;&gt;13788887777&lt;/div&gt; &lt;div class=&quot;province&quot;&gt;四川&lt;/div&gt; &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;id&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;王二&lt;/div&gt; &lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt; &lt;div class=&quot;tel&quot;&gt;13788889999&lt;/div&gt; &lt;div class=&quot;province&quot;&gt;广东&lt;/div&gt; &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var ul = document.getElementById(&quot;J_List&quot;); var del = document.getElementsByClassName(&apos;user-delete&apos;); for (let i = 0; i &lt; del.length; i++) &#123; del[i].onclick = function(event) &#123; ul.removeChild(event.target.parentNode); &#125;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试题目菜鸟网络仓库有一排小货架，共有N个，货架的底部是空的，现在智能机器人在某个货架下，小明写了一个非常简单的智能机器人移动程序,逻辑如下：每过1分钟，智能机器人必须随机的从一个货架下移动到相邻的一个货架下。比如刚开始智能机器人在第4个货架下，过1分钟后，智能机器人可能会在第3个货架下或者在第5个货架下。如果刚开始时智能机器人在第1个货架下，过1分钟以后，智能机器人一定会在第2个货架下。现在告诉你货架的数目N，已经智能机器人开始所在的位置P，小明很想知道，在M分钟后，智能机器人到达第T货架，一共有多少种行走方案。请帮小明算一算。输入：NPMT输出：一共有多少种行走方案 代码12345678910111213141516171819202122232425262728// javaimport java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; int N = sc.nextInt();// 货架数量 int P = sc.nextInt();// 起始位置 int M = sc.nextInt();// 时间 int T = sc.nextInt();// 结束位置 int res = solution(N, P, M, T); System.out.println(res); &#125; &#125; public static int solution(int n, int p, int m, int t) &#123; int[][] dp = new int[m + 1][n + 2];// 起始末尾添加两列，防止越界 dp[0][p] = 1; for (int i = 1; i &lt; dp.length; i++) &#123; // 时间从1开始，dp[0][p]为1，其他均为0 for (int j = 1; j &lt; dp[0].length - 1; j++) &#123;// 位置从1开始到length-2是为了防止数组越界 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; &#125; &#125; return dp[m][t]; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// jsvar readline = require(&apos;readline&apos;);const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;);var length = 4;var flag = 0;var arr = [];rl.on(&apos;line&apos;, function (input) &#123; flag++; input = parseInt(input); arr.push(input); if (flag == length) &#123; var res = soulution(arr); console.log(res); flag = 0; arr = []; &#125;&#125;).on(&apos;close&apos;, function () &#123;&#125;);function soulution(arr) &#123; var n = arr[0];//货架数量 var p = arr[1];//初始位置 var m = arr[2];//经过时间 var t = arr[3];//结束位置 var dp = []; for (var i = 0; i &lt; m + 1; i++) &#123; dp[i] = new Array; for (var j = 0; j &lt; n + 2; j++) &#123; dp[i][j] = 0; &#125; &#125; dp[0][p] = 1; for (var i = 1; i &lt; dp.length; i++) &#123; for (var j = 1; j &lt; dp[0].length - 1; j++) &#123; //1-n防止数组越界 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; &#125; &#125; return dp[m][t];&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《上帝掷骰子吗？——量子力学史话》读书笔记]]></title>
    <url>%2F2017%2F08%2F14%2Fdoes-god-throw-dice%2F</url>
    <content type="text"><![CDATA[2017.8.5开始读，2017.8.12日读完这是一本关于量子力学的历史的科普性著作 2017.8.14更新 经典物理的黄金时代光的本质波动说和粒子说 波动粒子之争第一次波粒战争主要参与人物： 粒子说：牛顿 《光学》，色散，牛顿环(明暗条纹)，衍射 质疑如果光是波，为什么无法像声音那样绕开障碍物前进？ 波动说：胡克(光是一种纵波)，惠更斯第一次交锋以牛顿为首的微粒说战胜了波动说 第二次波粒战争 波的干涉 托马斯.杨: 波的双缝干涉实验(1807年) 波的叠加与抵消 决定性事件(1819年) 菲涅尔: 采用光是一种波动的观点，用严密的数学推理解释了光的衍射 该理论用于圆盘衍射为一个亮斑，泊松质疑，阿拉果坚持实验检测，完美证明，后被误称为“泊松亮斑” 光的偏振 菲涅尔提出光是一种横波，而不是纵波，成功解析了偏振现象(1821年) 光速 傅科：“傅科摆”(1850年) 测量光在真空和水中的速度，后者为前者的3/4 电磁理论 麦克斯韦发表电磁理论的论文，预言光是电磁波的一种(1861年) 赫兹实验证明了麦克斯韦电磁理论(1887年) 麦氏方程在数学上完美得难以置信，科学美的典范至此，波动的光辉达到顶点 乌云开尔文《在热和光动力理论上空的十九世纪乌云》两朵乌云分别指：经典物理在光以太和麦克斯韦-玻尔兹曼能量均分学说遇到的难题，具体而言为迈克尔逊-莫雷实验和黑体辐射研究中的困难 第一朵乌云第一朵乌云为迈克尔逊-莫雷实验：探测光以太对于地球的漂移速度经典的失败实验最终导致了相对论革命的爆发 第二朵乌云第二朵乌云为黑体辐射实验和理论的不一致最终导致了量子革命的爆发 黑体辐射研究黑体辐射研究：物体的辐射能量和温度具有怎样的函数关系？从粒子角度去推导，维恩提出辐射能量分布定律公式(1894年)，即著名的维恩分布公式实验证明：黑体加热到1000K以上的高温时，测到短波范围内的曲线和维恩公式符合的很好，但在长波方面，实验出现了偏差从经典的电磁波的角度去推导，瑞利和金斯提出如瑞利-金斯公式，长波符合，短波出现偏差两套公式均无法给出正确的黑体辐射分布 普朗克黑体辐射研究普朗克利用数学上的内插法，凑出一个公式。在长波的时候，它表现得就像正比关系一样。而在短波的时候，它则退化为维恩公式的原始形式。这就是著名的普朗克黑体公式。普朗克寻找该公式的物理意义。如果要使得新的方程成立，就必须做一个假定：假设能量在发射和吸收的时候不是连续不断而是分成一份一份的正是这个假定，推翻了自牛顿200多年来曾经被认为是坚固不可摧毁的经典世界。以前一切自然个过程被当做连续不断的，但现在能量不是连续不断的了。能量必须只有有限个可能态，必须有个最小单位。在两个最小单位之间，是能量的禁区，我们永远不会发现，能量的计量会出现小数点以后的数字。1900年普朗克宣读《黑体光谱中的能量分布》，称这个基本单位为“能量子”,后改为“量子”。E=hv(E为单个量子的能量，V是频率，h为普朗克常数)，普朗克常数h、引力常数g和光速c构成我们宇宙最为重要的三个基本物理常数。量子论告诉我们，“无限分割”的概念是一种数学上的理想，而不可能在现实中实现。一切都是不连续的，连续性的美好蓝图也行不过时我们的一种想象。 量子力学光电效应赫兹证明电磁波的实验引出了“光电效应”光电效应和电磁理论的不协调之处：电磁理论认为，光作为一种波动，它的强度代表了它的能量，而实验证明：光的频率，而不是强度决定它能否从金属表面打出电子来；光的强度而不是频率，则决定打出电子的数目。1905年，爱因斯坦从普朗克的量子假设出发。E=hv，提高频率不正是提高了单个量子的能量吗？而更高能量的量子，不正好打击出更高能量的电子吗？另一方面，提高光的强度，只是增加量子的数量罢了。组成光的能量的这种最小基本单位，称之为光量子。光以量子的形式吸收能量，没有连续性，不能累积。一个光量子发出一个对应的电子。于是实验揭示出的瞬时作用也解决，量子作用本来就是瞬时作用，没有积累的说法。微粒说的一种翻版。 康普顿效应康普顿X射线被自由电子散射实验：散射出来的X射线分成两个部分，一部分和原来的入射射线波长相同，另一部分却比原来的射线波长要长，具体的大小和散射角存在函数关系。运用通常的波动理论，散射应该不会改变入射光的波长。于是其引入光量子的假设，光子像普通小球那样，不仅带有能量还具有冲量，当其与电子发生碰撞时，自己的一部分能量交换给电子，有E=hv可知，E下降导致v下降，导致波长变长。实验完全吻合。 原子模型卢瑟福实验α粒子轰击极薄的金箔(1910年)1911年修改汤姆逊的原子模型为“行星模型”，负电的电子围绕带正电的原子核。物理学家指出其不稳定，经典的电磁理论预言，这样的体系将会无可避免的释放出辐射能量，电子必将坠毁，导致体系崩溃 玻尔模型玻尔面临选择：放弃经典电磁理论，或者放弃卢瑟福原子模型。玻尔选择了前者。(1913年)原子内部只能释放特定量的能量，说明电子只能再特定的“势能位置”之间转换。也就是说，电子必须按照某些“确定的”轨道运行，这些轨道必须符合一定的势能条件，从而使得电子在这些轨道之间跃迁时，只能释放出符合巴尔末公式的能量来。电子只能释放或者吸收特定的能量而不是连续不断的。电子从E1跃迁到E2并不表示电子经过了E1和E2之间的任意状态。玻尔的这些思想，以三篇论文发表，量子物理划时代的文献，即伟大的“三部曲”。玻尔模型是卢瑟福模型的延续，一系列量子化条件被引入。1900年普朗克宣告了量子的诞生，1913年玻尔将一个完整的关于原子的理论体系建立起来，宣告了量子进入青年时代。 1918年玻尔发布“对应原理”，试图与麦氏理论调和，力图证明两种理论都正确，但是有不同的适用范围。导致了其最终的衰败。 玻尔假设，电子只能具有量子化的能级和轨道，但没有说明理由。而且无法解释“反常塞曼效应”，这种现象要求引进值为1/2的量子数。泡利在访问玻尔家时就曾经对玻尔夫人的问好回以暴躁的抱怨：“我当然不好！我不理解‘反常塞曼效应’”。 1925年泡利提出“不相容原理”。他发现没有两个电子能享有相同的状态，同一轨道包容的不同状态，其数目也是有限的，也就是说一个轨道有一定的容量。当电子填满一个轨道后其他电子无法加入到这个轨道中来。解决了电子长期占据外层电子轨道而不会失去能量落到低层轨道上的问题。解决了“反常塞曼效应”的问题 德布罗意波在玻尔模型中自然引进一个周期的概念，以符合观测到的现实。原本这个条件是强加在电子上的量子化模式：电子轨道是不连续的。德布罗意准备解释原因。E=mc^2,E=hv。hv=mc^2 电子具有一个内禀的频率，v=mc^2/h。电子以速度v0前进必定伴随一个速度为c^2/v0的波，德布罗意将其称为“相波”，后人称之为德布罗意波。电子也是一种波。这个波的速度比光速还快，但是这种波不能携带能量和信息，因此并不违反相对论。德布罗意是有史以来第一个凭借博士论文就获得诺贝尔奖的人。 海森堡矩阵力学对绝对“能级”或者“频率”表示怀疑。单独的能级无法观测，只有“能级差”可以频率表示为两个能级X，Y的函数。使用矩阵推导出量子化的原子能级和辐射频率。不需要像玻尔的旧模型那样，强行加一个不自然的量子条件。1924年，玻恩，海森堡，约尔当发表“三人论文”，《论量子力学I》《论量子力学II》 薛定谔波动力学薛定谔情人众多，世界观迥异。薛定谔从经典力学的哈密顿-雅可比方程触发，利用变分法和德布罗意公式，最后求出了一个非相对论的波动方程(1926年)。原子的神秘光谱不再为矩阵力学所专美，它同样可以从波动方程中被自然的推导出来。后薛定谔、泡利、约尔当均证明矩阵力学和波动力学在数学上说是完全等价的，均是从经典的哈密顿函数而来。但是薛定谔定义的Ψ波函数，说这是空间中定义的某种分布，他自己也没见过，不知道其物理意义。 2017.8.15更新 玻恩的概率解释玻恩说这个波函数Ψ里面装的是“骰子”。它代表的是一种随机，一种概率，而决不是薛定谔本人理解的，是电子电荷在空间中的实际分布。玻恩争辩道，Ψ或者更准确的说，Ψ^2代表了电子在某个地点出现的“概率”。电子本身不会像波那样扩展开去，但是它出现的概率则像一个波，严格按照Ψ的分布所展开。 单个电子打到感光屏。激发出一个小点。我们不能预言它组成类波的干涉条纹，因为一个电子只会留下一个点而已，而且出现的位置也不确定。但是只有当成群的电子穿过双缝后才会逐渐组成干涉条纹。规律：电子在某些地方出现的可能性要大一些，在另一些地方则小一些。出现频率高的地方，恰恰是波动所预言的干涉条纹的亮处，出现频率低的地方则对应于暗处。虽然每一个电子的行为是随机的，但是这个随机分布的总的模式是确定的，它就是一个干涉条纹的图案。这就像我们掷骰子，虽然每一个骰子掷下去，它的结果是完全随机的，但是如果大量的骰子到地上，你会发现1-6的结果差不多是平均的。物理不能预测电子的行为，它只能找到电子出现的概率而已。理论上，只要我们了解每一个分子的状态，我们完全可以严格地推断出整个系统的行为，分毫不爽。可是玻恩的意思是，就算我们把电子的初始状态测量的精确无误，就算我们拥有最强大的计算机可以计算一切环境对电子的影响，即便如此，我们也不能预言电子最后的准确位置。这种不确定不是因为我们的计算能力不足，它是深藏在物理定律本身内部的一种属性。即使从理论上来说，我们也不能准确地预测大自然。这已经不是推翻某个理论的问题，这是对整个决定论系统的挑战，而决定论是那时整个科学的基础。量子论要改造整个科学。 海森堡的不确定性原理1927年，海森堡由矩阵力学提出不确定性原理又称测不准原理。p×q ≠ q×p,p是动量，q是位置，这不是说先观测动量p，再观测位置q，这和先观测q再观测p，其结果是不一样的吗？除非测量动量p这个动作本身，影响到了q的数值。反之亦如此。这个方程告诉我们同时观测p和q是不可能的吗？理论不但决定了我们能够观察到的东西，它还决定哪些是我们观察不到的东西。关键在测量上，在电子层面上，由于观测时不能忽略光子对它的撞击，为了测量位置，我们剧烈改变了它的动量。我们没法同时即准确地知道一个电子的位置同时又准确的了解它的动量。最后得出：∆p×∆q&gt;h/4π,∆p、∆p分别表示测量误差。∆p非常小，∆q相应地必定变得非常大。后又发现能量E和时间t也满足类似的不确定性规则：∆E×∆t&gt;h。在非常断点一刹那，也就是t非常确定的一瞬间，即使真空也会出现巨大的能量起伏，这种能量完全是靠着不确定性而凭空出现的，它的确违反了能量守恒定律，但是一刹那很短，在人们还没来得及发现以前，它又神秘消失，使得能量守恒在整体上得以维持。在玻尔指导下，其声明不确定性其实同时建筑在连续性和不连续性两者之上。 玻尔的互补原理福尔摩斯说：“我的方法，就建立在这样一种假设上面：当你把一切不可能的结论都排除之后，那剩下的，不管多么离奇，也必然是事实。”电子不可能不是个粒子，它也不可能不是波，那剩下的唯一可能性就是：它既是个粒子也是个波。我们每次观察电子，它只展现出其中的一面，这里面关键是我们“如何”观察它，而不是它“究竟”是什么。讨论哪个是“真实”毫无意义。我们唯一能说的是在某种观察方式确定的前提下，它能呈现出什么样子来。但一旦观察方式确定了，电子就要选择一种表现形式，它得作为一个波或者粒子出现，而不能再暧昧的混杂在一起。波和粒子在同一时刻是互斥的，但它们却又在一个更高的层次上统一在一起，作为电子的两面被纳入一个整体概念中，这就是玻尔的“互补原理”。 量子论与测量只有观测手段明确之后，答案才有意义。而脱离了观测手段去讨论这个图案“本质上”到底是什么是无意义的。在量子论中观测者和外部宇宙是结合在一起的，它们之间现在已经没有明确的界限，是一个整体。换言之，不存在一个客观的，绝对的世界。唯一存在的，就是我们能够观测到的世界。物理学的全部一样，不在于它能够揭示出自然“是什么”，而在于它能够明确，关于自然我们能“说什么”。没有一个脱离于观测而存在的“绝对自然”，只有我们和那些复杂的测量关系，熙熙攘攘纵横交错，构成了这个令人心醉的宇宙的全部。测量是新物理学的核心，测量行为创造了整个世界。 “存在，但绝对观测不到”之类的论断都是毫无意义的，因为这和“不存在”根本就是一码事，无法区分开来。 量子论“哥本哈根解释”总结玻恩的的概率解释、海森堡的不确定性和玻尔的互补原理共同构成量子论“哥本哈根解释”的核心，前两者捣毁了经典世界的(严格)因果性，互补原理和不确定性原理有合力摧毁了世界的(绝对)客观性。它们至今仍然影响我们对宇宙的终极认识。首先，不确定性原理限制了我们对微观事物认识的极限，而这个极限也就是具有物理意义的一切。其次，因为存在着观测者对于被观测物的不可避免的扰动，现在主体和客观世界必须被理解成一个不可分割的整体。没有一个孤立地存在于客观世界的“事物”，事实上一个纯粹的客观世界是没有的，任何事物都只有结合一个特定的观测手段，才谈得上具有具体意义。对象所表现出的形态，很大程度上取决于我们的观测方法。对于同一个现象来说，这些表现形态可能是相互排斥的，但必须被同时作用域对这个对象的描述中，也就是互补原理。最后，因为我们的观测给事物带来各种原则上不可预测的扰动，量子世界本质是“随机的”。传统世界严格发因果关系在量子世界是不存在的，必须以一种统计性的解释来取而代之，波函数Ψ就是一种统计，它的平方代表了粒子出现在某处的概率。当我们说“电子出现在x处”时，我们并不知道这个事件的“原因”是什么，它是一个完全随机的过程，没有因果关系。 量子幽灵在电子通过双缝前，如果我们不去测量它的位置，那么它的波函数就按照方程发散开去，同时通过两个缝而自我相互干涉。但要是我们试图在两条缝上装个仪器以探测它究竟通过了哪条缝，在那一刹那，电子的波函数便塌缩了，电子随机地选择一个缝通过。而塌缩过的波函数自然就无法再进行干涉，于是乎，干涉条纹一去不复返。 第三次波粒战争微粒说：光电效应，康普顿效应，玻色-爱因斯坦统计,矩阵力学波动说：麦克斯韦理论，德布罗意波(电子也是一种波)，波动力学在互补原理、玻恩的的概率解释和海森堡的不确定性提出后，第三次波粒战争以戏剧化结尾收场，两者是不可分割的一个整体，即“波粒二象性”。 玻尔、爱因斯坦之争爱因斯坦光箱实验ERP佯谬 薛定谔的猫薛定谔想象了一种结构巧妙的精密装置，每当原子衰变而放出一个中子，它就激发一连串的连锁反应，最终结果是打破箱子里的一个毒气瓶，而同时箱子里还有一只猫。若原子衰变，猫就被毒死，反之，猫活着。当它们都被锁在箱子里时，因为我们没有观察，所以原子处在衰变/不衰变的叠加态。因为原子的状态不确定，所以猫的状态也不确定，只有打开箱子才能最终定论。问题是，当我们没有打开箱子之前，这只猫处于什么状态？似乎唯一的可能就是，它和我们的原子一样处在叠加态，这只猫当时陷于死/活的混合。 量子力学延伸意识为什么机器来测量就得叠加，而人来就得到确定结果呢？难道说，人类意识的参与才是波函数塌缩的原因？只有当电子的随机结果被“意识到”，它才真正地变为现实，从波函数中脱胎而出来到这个世界上。 量子通信不可复制原理：传输量子态的同时一定会毁掉原来的那个原本。 延迟实验我们何时选择“光子”的模式，对于实验结果无影响。 这说明，宇宙的历史，可以在它已经发生后才决定究竟是怎样发生的！在薛定谔的猫实验里，如果我们设计某种延迟实验，我们就能在实验结束后决定猫是死是活！比如说，原子在一点钟要么衰变毒死猫，要么断开装置使猫存活。但如果有某个延迟装置能够让我们在2点钟来“延迟决定”原子衰变与否，我么就可以在两点钟这个“未来”去实际决定猫在一点钟的死活。 宇宙本身由一个有意识的观测者创造出来也不是什么不可能的事情。虽然宇宙的行为在道理上讲已经演化了一百多亿年，但某种“延迟”使得它直到被一个高级生物所观察才成为确定。我们的观测行为本身参予了宇宙的创造过程！这就是所谓的“参与性宇宙”模型（The Participatory Universe）。宇宙本身没有一个确定的答案，而其中的生物参与了这个谜题答案的构建本身！ 这实际上是某种增强版的“人择原理”（anthropic principle）。人择原理是说，我们存在这个事实本身，决定了宇宙的某些性质为什么是这样的而不是那样的。也就是说，我们讨论所有问题的前提是：事实上已经存在了一些像我们这样的智能生物来讨论这些问题。我们回忆一下笛卡儿的“第一原理”：不管我怀疑什么也好，有一点我是不能怀疑的，那就是“我在怀疑”本身，也就是著名的“我思故我在”！类似的原则也适用于人择原理：不管这个宇宙有什么样的性质也好，它必须要使得智能生物可能存在于其中，不然就没有人来问“宇宙为什么是这样的？”这个问题了。随便什么问题也好，你首先得保证有一个“人”来问问题，不然就没有意义了。 缺点：对于观测者无法定义，对于意识无法定义 多世界解释(Many Worlds Interpretation,MWI)电子即使在观测后仍然处于左/右叠加的,只不过，我们的世界本身也是叠加的一部分！当电子穿过双缝后，处于叠加态的不仅仅是电子，还包括我们整个世界！也就是说，当电子经过双缝后，出现了两个叠加在一起的世界，在其中的一个世界里电子穿过了左边的双缝，而在另一个世界里，电子穿过了右边的双缝！波函数无须“塌缩”，去随机选择左还是右，事实上两种可能都发生了！只不过它表现为整个世界的叠加：生活在一个世界的人在他们那里电子通过左边的狭缝，而在另一个世界中，人们观测到的电子则在右边！我们的宇宙可能是高维空间，真实世界的投影，可能有很多类似的空间。缺点：多世界，我看不到 量子自杀这就是从量子自杀思想实验推出的怪论，美其名曰“量子永生”（quantumimmortality）。只要从主观视角来看，不但一个人永远无法完成自杀，事实上他一旦开始存在，就永远不会消失！总存在着一些量子效应，使得一个人不会衰老，而按照MWI，这些非常低的概率总是对应于某个实际的世界！如果多宇宙理论是正确的，那么我们得到的推论是：一旦一个“意识”开始存在，从它自身的角度来看，它就必定永生！（天哪，我们怎么又扯到了“意识”！）。这是最强版本的人择原理，也称为“终极人择原理”。 应用量子计算机一个bit表示0,1的叠加，处理10位bit,处理的是2^10个这样的数。做的不能比图灵计算机多，但是速度更快。基于大数分解的加密算法会失效。 量子加密隐变量理论如果你试图去测量一个电子的具体位置的话，你的测量仪器将首先与它的量子势发生作用，这将使电子本身发生微妙的变化，这些变化是不可预测的，因为主宰它们的是一些“隐变量”，你无法直接探测到它们。恢复了实在性却放弃了定域性。 贝尔不等式如果世界的本质是经典的，具体的说，如果我们的世界同时满足： 定域的，也就是没有超光速的信号传播 实在的，也就是说，存在一个独立于我们观察的外部世界 那么我们任意去三个方向观察A、B的自旋，他们所表现的协作程度必定要受限于贝尔不等式之内但在量子论中，贝尔不等式可以被突破(1964年)，实验证明该不等式被突破，世界不是经典的，爱因斯坦输了(1982)。 阿斯派克特实验之后，我们必须说服自己相信这样一件事情： 定域的隐变量理论是不存在的！ 换句话说，我们的世界不可能如同爱因斯坦所梦想的那样，既是定域的（没有超光速信号的传播），又是实在的（存在一个客观确定的世界，可以为隐变量所描述）。定域实在性（local realism）从我们的宇宙中被实验排除了出去，现在我们必须作出艰难的选择：要么放弃定域性，要么放弃实在性。 如果我们放弃实在性，那就回到量子论的老路上来，承认在我们观测之前，两个粒子不存在于“客观实在”之内。它们不具有通常意义上的物理属性（如自旋），只有当观测了以后，这种属性才变得有意义。这样一来牢固可靠的世界就崩塌了。 这样一来就必须放弃定域性。我们仍然有可能建立一个隐变量理论，如果容忍某种超光速的信号在其体系中来回，则它还是可以很好地说明我们观测到的一切。比如在EPR中，天际两头的两个电子仍然可以通过一种超光速的瞬时通信来确保它们之间进行成功的合作。事实上，玻姆的体系就很好地在阿斯派克特实验之后仍然存活着，因为他的“量子势”的确暗含着这样的超距作用。 可是要是这样的话，我们也许并不会觉得日子好过多少！超光速的信号？老大，那意味着什么？想一想爱因斯坦对此会怎么说吧，超光速意味着获得了回到过去的能力！ 其实我们的史话一早已经讨论过，德布罗意那“相波”的速度c2/v就比光速要快，但只要不携带能量和信息，它就不违背相对论。 超弦理论，M理论时空变成11维其他维度的扰动造成全部的量子不确定性 对待科学的态度事实上，我们对待科学的态度是，只要一个理论能够被证明为“错”但还未被证明“错”，我们就暂时接受它为可靠正确的。不过它必须随时积极地面对证伪，这也就是为什么科学总是在自我否定中不断完善。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2017%2F08%2F13%2Fdynamic-programming%2F</url>
    <content type="text"><![CDATA[2017.08.17更新 背包问题01背包状态dp[i][j]表示前i个物品装到剩余容量为j时的最大价值 状态转移方程dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])第i个物品装或者不装入背包，不装价值为dp[i-1][j],装表示剩下i-1个物品装入j-weight[i-1]重的最大价值，加上value[i-1]注意讨论前i个物品装入背包的时候， 其实是在考查第i-1个物品装不装入背包（因为物品是从0开始编号的） 代码123456789101112131415161718192021222324252627282930313233public class Pack_01 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub// int n = 5;// 物品个数// int[] value = &#123; 48, 40, 12, 8, 7 &#125;;// 物品价值// int[] weight = &#123; 6, 5, 2, 1, 1 &#125;;// 物品重量// int capacity = 8;// 背包容量 int n = 4; int[] value = &#123; 10, 40, 30, 50 &#125;; int[] weight = &#123; 5, 4, 6, 3 &#125;; int capacity = 12; int res = pack_01(n, capacity, weight, value); System.out.println(res); &#125; public static int pack_01(int n, int capacity, int[] weight, int[] value) &#123; int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i &lt; dp.length; i++) &#123;// for (int j = 1; j &lt; dp[0].length; j++) &#123; if (j &gt;= weight[i - 1]) &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); &#125; else &#123; dp[i][j] = dp[i - 1][j];// i只与i-1有关 &#125; &#125; &#125; return dp[n][capacity]; &#125;&#125; 完全背包状态dp[i][j]表示前i个物品装到剩余容量为j时的最大价值 状态转移方程dp[i][j] = max(dp[i - 1][j - num * weight[i - 1]] + num * value[i - 1]) (0&lt;=num * weight[i - 1]&lt;=j) 代码1234567891011121314151617181920212223242526272829public class Pack_full &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int n = 5;// 物品个数 int[] value = &#123; 48, 40, 12, 8, 7 &#125;;// 物品价值 int[] weight = &#123; 6, 5, 2, 1, 1 &#125;;// 物品重量 int capacity = 8;// 背包容量 // int n = 4; // int[] value = &#123; 10, 5, 30, 40 &#125;; // int[] weight = &#123; 5, 4, 6, 3 &#125;; // int capacity = 12; int res = pack_full(n, capacity, weight, value); System.out.println(res); &#125; public static int pack_full(int n, int capacity, int[] weight, int[] value) &#123; int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i &lt; dp.length; i++) &#123; for (int j = 1; j &lt; dp[0].length; j++) &#123; for (int num = 0; j &gt;= num * weight[i - 1]; num++) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - num * weight[i - 1]] + num * value[i - 1]); &#125; &#125; &#125; return dp[n][capacity]; &#125;&#125; 2017.08.18更新 硬币找零(方案数)状态dp[i][j]表示使用changes[0-i]硬币兑换j元的方法总数 分析使用i=0的钱币兑换，只有changes[0]的整数倍的金额才能有1种方法dp[0][j * changes[0]] = 1 状态转移方程不装入第i种钱币，即使用0~i-1种钱币组成j的方法数；装入i钱币，使用0~i的钱币组成j-changes[i]金额的方法数dp[i][j] = dp[i - 1][j] + dp[i][j - changes[i]] 代码12345678910111213141516171819202122232425262728293031323334353637383940//链接：https://www.nowcoder.com/questionTerminal/185dc37412de446bbfff6bd21e4356ec//来源：牛客网////有一个数组changes，changes中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，对于一个给定值x，请设计一个高效算法，计算组成这个值的方案数。//给定一个int数组changes，代表所以零钱，同时给定它的大小n，另外给定一个正整数x，请返回组成x的方案数，保证n小于等于100且x小于等于10000。//测试样例：//[5,10,25,1],4,15//返回：//6public class ChangeMoney &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] changes = &#123; 5, 10, 25, 1 &#125;; int n = 4; int money = 15; int res = change(changes, n, money); System.out.println(res); &#125; public static int change(int[] changes, int n, int money) &#123; int[][] dp = new int[n][money + 1];// dp[i][j]表示使用changes[0-i]硬币兑换j元的方法总数。 for (int i = 0; i &lt; n; i++) &#123; // j=0表示钱为0，组成0元的方法数为1 dp[i][0] = 1; &#125; for (int j = 0; j * changes[0] &lt; money + 1; j++) &#123;// 使用i=0的钱币兑换，只有changes[0]的整数倍的金额才能有1种方法 dp[0][j * changes[0]] = 1; &#125; // 填表 for (int i = 1; i &lt; dp.length; i++) &#123;// 数组长度1~n-1在changes数组中有效 for (int j = 1; j &lt; dp[0].length; j++) &#123; // 不装入第i种钱币，即使用0~i-1种钱币组成j的方法数；装入i钱币，使用0~i的钱币组成j-changes[i]金额的方法数 dp[i][j] = dp[i - 1][j] + (j - changes[i] &gt;= 0 ? dp[i][j - changes[i]] : 0); &#125; &#125; return dp[n - 1][money]; &#125;&#125; 硬币找零(最少硬币数)多重背包 2017-08-28更新 最长公共子序列最长递增子序列动态规划法123456789101112131415161718//普通dp算法，复杂度为n^2function longest_increasing_subsequence_1(arr) &#123; //时间复杂度为n^2 let dp = []; for (let i = 0; i &lt; arr.length; i++) &#123; dp[i] = 1; &#125; let max = 0; for (let i = 0; i &lt; arr.length; i++) &#123; for (let j = 0; j &lt; i; j++) &#123; if (arr[j] &lt; arr[i]) &#123; dp[i] = Math.max(dp[j] + 1, dp[i]); &#125; &#125; max = Math.max(max, dp[i]); &#125; return max;&#125; 改进的二分查找法1234567891011121314151617181920212223242526272829303132333435363738394041424344//二分查找，复杂度为nlognfunction longest_increasing_subsequence_2(arr) &#123; //时间复杂度为nlogn //minNum存储的是长度为 index+1 的最小末尾值 //当arr[i]比minNum数组的最后一个数还大时 //minNum数组长度加1,其最小末尾为arr[i] //这样保证minNum数组的值是有序排列的 //当arr[i]比比minNum数组的最后一个数小时, //对minNum有序数组进行二分查找 //并将最终找到的右边界返回，将其值改为arr[i] //保证了minNum数组存储的一直为最小末尾 //即相同长度的子序列，选择末尾较小的填入 //以保证minNum数组一直有序 let minNum = []; for (let i = 0; i &lt; arr.length; i++) &#123; length = minNum.length; if (arr[i] &gt; minNum[length - 1] || minNum[length - 1] == undefined) &#123; minNum[length] = arr[i]; &#125; else &#123; //二分查找 let change_index = binary_search(minNum,arr[i]); minNum[change_index] = arr[i]; &#125; &#125; return minNum.length;&#125;function binary_search(arr,search_num)&#123; let seek_left = 0; let seek_right = arr.length - 1; let half_length = Math.floor((seek_left + seek_right) / 2); while ((seek_right - seek_left) &gt; 1) &#123; if (arr[half_length] &lt; search_num) &#123; seek_left = Math.floor((seek_left + seek_right) / 2); &#125; else if (arr[half_length] &gt; search_num) &#123; seek_right = Math.floor((seek_left + seek_right) / 2); &#125; else &#123; seek_right = half_length; break; &#125; half_length = Math.floor((seek_left + seek_right) / 2); &#125; return seek_right;&#125; 地牢游戏12345678910111213141516171819202122232425262728293031323334353637function count(arr) &#123; //dp[i][j]表示可以从点(i,j)到终点所需的最小能量 var dp = []; //初始化数组中的每个值均为0 for (var i = 0; i &lt; arr.length; i++) &#123; dp[i] = []; for (var j = 0; j &lt; arr[0].length; j++) &#123; dp[i][j] = 0; &#125; &#125; //从后往前 for (var i = arr.length - 1; i &gt;= 0; i--) &#123; for (var j = arr[0].length - 1; j &gt;= 0; j--) &#123; //1.边缘情况和初始值 if (i == arr.length - 1 &amp;&amp; j == arr[0].length - 1) &#123; dp[i][j] = Math.max(1, 1 - arr[i][j]); &#125; else if (i == arr.length - 1 &amp;&amp; j != arr[0].length - 1) &#123; dp[i][j] = Math.max(1, dp[i][j + 1] - arr[i][j]); &#125; else if (i != arr.length - 1 &amp;&amp; j == arr[0].length - 1) &#123; dp[i][j] = Math.max(1, dp[i + 1][j] - arr[i][j]); &#125; else &#123; //2.正常情况 //这个能量永远大于等于1，小于等于表示人已死 //从后往前表示往后的路径已知，那么到达该点的最小能量值也可确定 //从前往后因为无法确定之后的情况和路径所以不能判定该点的状态 //表示从右下两个的位置所需的最小能量减去该点获得的能量的最小值 //但需要比0大，有小于等于0的表示人已死 //状态转移方程如下 dp[i][j] = Math.max(1, Math.min(dp[i + 1][j], dp[i][j + 1]) - arr[i][j]); &#125; &#125; &#125; return dp[0][0];&#125; 参考文献 背包问题九讲 动态规划之背包问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Puzzlers解析]]></title>
    <url>%2F2017%2F08%2F12%2Fjs-puzzlers%2F</url>
    <content type="text"><![CDATA[JavaScript Puzzlers!，题目基于ECMA 262 (5.1)的浏览器环境 1.What is the result of this expression? (or multiple ones)123456["1", "2", "3"].map(parseInt)A.["1", "2", "3"]B.[1, 2, 3]C.[0, 1, 2]D.other 考察map和parseIntArray.prototype.map()接收三个参数(element,index,Array)parseInt()接收两个参数(val,radix),radix为基数，parseInt(&#39;17&#39;,8) //15,radix为0或无表示以10为基数。每个位上的数字不能比基数大，否则返回NaN,radix不能为1,范围为2-36。 123parseInt('1',0)//1parseInt('2',1)//每个位上的数字不能比基数大，且基数不能为1,返回NaNparseInt('3',2)//每个位上的数字不能比基数大,返回NaN 所以选D 2.What is the result of this expression? (or multiple ones)123456[typeof null, null instanceof Object]A.["object", false]B.[null, false]C.["object", true]D.other 考察typeof和instanceof。 typeof null返回object, typeof对本地不可调用对象均返回object(包括array, null), 其他的可能返回的数据是number, string, boolean, object, function, undefined; instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置。null为基本类型，所以null instanceof Object // false。选A 3.What is the result of this expression? (or multiple ones)123456[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]A.an errorB.[9, 0]C.[9, NaN]D.[9, undefined] 考察reduce函数的用法Array.prototype.reduce()接收两个参数(function(accumulator, currentValue, currentIndex, array), initialValue)空数组调用reduce时没有设置初始值将会报错。所以选A 4.What is the result of this expression? (or multiple ones)1234567var val = 'smtg';console.log('Value is ' + (val === 'smtg') ? 'Something' : 'Nothing');A.Value is SomethingB.Value is NothingC.NaND.other 考察运算符优先级，MDN运算符优先级表+(13级)优先级大于？(3级),所以&#39;Value is &#39; + (val === &#39;smtg&#39;)条件判断为true，答案为&#39;Something&#39;,选D 5.What is the result of this expression? (or multiple ones)1234567891011121314var name = 'World!';(function () &#123; if (typeof name === 'undefined') &#123; var name = 'Jack'; console.log('Goodbye ' + name); &#125; else &#123; console.log('Hello ' + name); &#125;&#125;)();A.Goodbye JackB.Hello JackC.Hello undefinedD.Hello World 考察变量声明提升（var hoisting）由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。所以选A 6.What is the result of this expression? (or multiple ones)123456789101112var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count);A.0B.100C.101D.other 考察JavaScript中的安全整数范围Number.MIN_SAFE_INTEGER代表在JavaScript中最小的安全的integer型数字-(2^53 - 1)。Number.MAX_SAFE_INTEGER代表在JavaScript中最大的安全整数(2^53 - 1)。这个数字形成的原因是，Javascript 使用 IEEE 754 中规定的double-precision floating-point format numbers，在这个规定中能安全的表示数字的范围在-(2^53 - 1)到2^53 - 1之间，包含-(2^53 - 1)和2^53 - 1。2^53+1 与 2^53超过安全整数范围，2^53+1 === 2^53 //true，所以为无限循环，选D 7.What is the result of this expression? (or multiple ones)12345678var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;);A.[undefined × 7]B.[0, 1, 2, 10]C.[]D.[undefined] 考察filter函数filter函数中callback只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。所以选C 8.What is the result of this expression? (or multiple ones)12345678910var two = 0.2var one = 0.1var eight = 0.8var six = 0.6[two - one == one, eight - six == two]A.[true, true]B.[false, false]C.[true, false]D.other 考察js大数和浮点数精度丢失的问题计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。解决方案：对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）选择C，没有道理，时而准确时而不准，忧伤 9.What is the result of this expression? (or multiple ones)123456789101112131415161718192021function showCase(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase(new String('A'));A.Case AB.Case BC.Do not know!D.undefined 考察switch()和判等switch()使用===判等，而new String(&#39;A&#39;)!==&#39;A&#39;,所以选C 10.What is the result of this expression? (or multiple ones)123456789101112131415161718192021function showCase2(value) &#123; switch(value) &#123; case 'A': console.log('Case A'); break; case 'B': console.log('Case B'); break; case undefined: console.log('undefined'); break; default: console.log('Do not know!'); &#125;&#125;showCase2(String('A'));A.Case AB.Case BC.Do not know!D.undefined 考察String()方法和判等String(&#39;A&#39;)没有新建一个对象，而是返回一个string的基本类型，所以选A 11.What is the result of this expression? (or multiple ones)12345678910111213141516function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, '13', -9, Infinity];values.map(isSane);A.[true, true, true, true, true]B.[true, true, true, true, false]C.[true, true, true, false, false]D.[true, true, false, false, false] 考察取余操作符取余操作符保证符号，所以-9 % 2 === -1 , Infinity % 2 =&gt; NaN所以选C 12.What is the result of this expression? (or multiple ones)12345678parseInt(3, 8)parseInt(3, 2)parseInt(3, 0)A.3, 3, 3B.3, 3, NaNC.3, NaN, NaND.other 考察parseInt()函数，分析见第1题，答案应该为3,NaN,3 所以选D 13.What is the result of this expression? (or multiple ones)123456Array.isArray(Array.prototype)A.trueB.falseC.errorD.other 考察Array.prototype，是数组，所以选A 14.What is the result of this expression? (or multiple ones)1234567891011var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log("wut");&#125;A.trueB.falseC."wut"D.other 考察if()和判等,见js相等性比较if([])都会执行，所以if([0])更会执行，对象和布尔值比较，布尔值转换为数字，对象转换为原始值比较,[0] == true // false所以选B 15.What is the result of this expression? (or multiple ones)123456[]==[]A.trueB.falseC.errorD.other 考察相等性比较，见js相等性比较对象和对象比较，引用相同返回true,否则返回false,所以选B 16.What is the result of this expression? (or multiple ones)1234567'5' + 3'5' - 3A."53", 2B.8, 2C.errorD.other 考察+，-运算符,字符串会使用+运算符做连接，但是遇到-则转换为数值进行运算。所以选A 17.What is the result of this expression? (or multiple ones)1234561 + - + + + - + 1A.2B.1C.errorD.other 考察一元+, -中间一元加号不影响，两个一元减号负负得正变加号,所以选A 18.What is the result of this expression? (or multiple ones)12345678var ary = Array(3);ary[0]=2ary.map(function(elem) &#123; return '1'; &#125;);A.[2, 1, 1]B.["1", "1", "1"]C.[2, "1", "1"]D.other 考察map函数删除或未赋值的元素不会被遍历到，返回[2, undefiend, undefiend]，所以选D 19.What is the result of this expression? (or multiple ones)1234567891011121314function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a, b, c) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1, 1, 1)A.3B.12C.errorD.other 考察函数的arguments函数的arguments与参数是相对应的，但不是同一片内存空间，所以答案为21，选D 20.What is the result of this expression? (or multiple ones)12345678var a = 111111111111111110000, b = 1111;a + b;A.111111111111111111111B.111111111111111110000C.NaND.Infinity 考察js的大数精度a &gt; 2^53 -1， js中的大数精度也缺失了，选B 21.What is the result of this expression? (or multiple ones)1234567var x = [].reverse;x();A.[]B.undefinedC.errorD.window 题目基于ECMA 262 (5.1)的浏览器环境，[].reverse返回this，被浏览器调用之后为window。选D 22.What is the result of this expression? (or multiple ones)123456Number.MIN_VALUE &gt; 0A.falseB.trueC.errorD.other 考察NumberNumber.MIN_VALUE是大于0的最小数，所以选B 23.What is the result of this expression? (or multiple ones)123456[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]A.[true, true]B.[true, false]C.errorD.other 考察&lt;运算符(1 &lt; 2) &lt; 3,1 &lt; 2 //true 转换为1 1 &lt; 3 // true(3 &lt; 2) &lt; 1,3 &lt; 2 //false 转换为0 0 &lt; 1 //true所以选A 24.What is the result of this expression? (or multiple ones)1234567// the most classic wtf2 == [[[2]]]A.trueB.falseC.undefinedD.other 考察==对象和其他值比较时，会将对象转换为原始值，[[[2]]]转换原始值为2所以返回true 25.What is the result of this expression? (or multiple ones)123456783.toString()3..toString()3...toString()A."3", error, errorB."3", "3.0", errorC.error, "3", errorD.other 我靠了考察Number对象中.表示小数还是使用方法的问题。3.x表示数字3后面加上x的后缀，后缀可以为空，但是不可以为3.toString()，所以Number对象若使用toString方法，必须加上()，如(3).toString()，否则表示小数，这题很贼。选C 26.What is the result of this expression? (or multiple ones)12345678910(function()&#123; var x = y = 1;&#125;)();console.log(y);console.log(x);A.1, 1B.error, errorC.1, errorD.other 考察匿名函数变量定义连等赋值从右到左进行解析，得到y = 1; var x = y，所以x为局部变量，y为全局变量。所以选C 27.What is the result of this expression? (or multiple ones)123456789var a = /123/, b = /123/;a == ba === bA.true, trueB.true, falseC.false, falseD.other 考察对象比较两个对象比较==和===效果一样的，均比较引用是否相同。所以选C 28.What is the result of this expression? (or multiple ones)123456789101112var a = [1, 2, 3], b = [1, 2, 3], c = [1, 2, 4]a == ba === ba &gt; ca &lt; cA.false, false, false, trueB.false, false, false, falseC.true, true, false, trueD.other 考察数组比较基于引用值是否相同比较数组对象是否相等，基于标准字典的Unicode值来进行比较数组的大小选A 29.What is the result of this expression? (or multiple ones)1234567var a = &#123;&#125;, b = Object.prototype;[a.prototype === b, Object.getPrototypeOf(a) === b]A.[false, true]B.[true, true]C.[false, false]D.other 考察原型和原型对象Object.getPrototypeOf()方法返回指定对象的原型，即实例对象内部的_proto_属性,即我们常说的原型链，所有对象的原型均从Object继承而来。如果没有继承属性，则返回 null(最顶层的Object)。prototype为原型对象，只有Function对象有，其他对象都没有。所以选A。 30.What is the result of this expression? (or multiple ones)12345678function f() &#123;&#125;var a = f.prototype, b = Object.getPrototypeOf(f);a === bA.trueB.falseC.nullD.other 考察原型和原型对象函数原型对象： 12345Function.prototype = &#123; constructor : Function, __proto__ : parent prototype,//原型对象为了实现继承的 some prototype properties: ...&#125;; 而Object.getPrototypeOf()返回对象的原型即_proto_，这个属性是对象本身为了实现继承的，是指向父对象的原型对象。选B 函数的原型对象和原型 31.What is the result of this expression? (or multiple ones)123456789function foo() &#123; &#125;var oldName = foo.name;foo.name = "bar";[oldName, foo.name]A.errorB.["", ""]C.["foo", "foo"]D.["foo", "bar"] 考察函数名的只读性函数名只读，不可修改，但是js里对其修改不报错，很奇怪。选C 32.What is the result of this expression? (or multiple ones)123456"1 2 3".replace(/\d/g, parseInt)A."1 2 3"B."0 1 2"C."NaN 2 3"D."1 NaN 3" 考察replace和parseInt函数replace函数中第二个参数为function函数，function函数的参数： match 匹配的子串。(对应于上述的$&amp;。) p1, p2, ... 假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。） offset 匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1） string 被匹配的原字符串。无括号，传入的是match, offset, string，所以parseInt()接收到的参数是[1, 0], [2, 2], [3, 4]，得到1 NaN 3，选D 33.What is the result of this expression? (or multiple ones)1234567891011function f() &#123;&#125;var parent = Object.getPrototypeOf(f);f.name // ?parent.name // ?typeof eval(f.name) // ?typeof eval(parent.name) // ?A."f", "Empty", "function", "function"B."f", undefined, "function", errorC."f", "Empty", "function", errorD.other 考察函数的原型parent.name为函数原型的名字，即原型链指向的其构造函数的原型对象的名字，返回空字符串，这个对象被定义了，但是不在这个作用域中。eval对表达式进行求值。选C 34.What is the result of this expression? (or multiple ones)1234567var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()]A.[true, false]B.errorC.[true, true]D.[false, true] 考察正则表达式对象的test()方法其参数为字符串类型，参数为空时，将其转化为字符undefined，所以选C 35.What is the result of this expression? (or multiple ones)123456[,,,].join(", ")A.", , , "B."undefined, undefined, undefined, undefined"C.", , "D."" 考察数组长度问题js定义数组允许在数组末尾加逗号，所以这个数组的长度为3，所以选C 36.What is the result of this expression? (or multiple ones)1234567var a = &#123;class: "Animal", name: 'Fido'&#125;;a.classA."Animal"B.ObjectC.an errorD.other 考察对象的class浏览器兼容性问题除了IE均返回&quot;Animal&quot;，IE不能将保留字作为对象的属性所以选D 37.What is the result of this expression? (or multiple ones)123456var a = new Date("epoch")A.Thu Jan 01 1970 01:00:00 GMT+0100 (CET)B.current timeC.errorD.other 考察Date对象创建Date实例可使用new Date(dateString),dateString需符合RFC2822格式，否则返回NaN。chrome中测试返回invalid date。所以选D 38.What is the result of this expression? (or multiple ones)12345678var a = Function.length, b = new Function().lengtha === bA.trueB.falseC.errorD.other 考察函数的长度Function.length定义为1，而函数的prototype的长度为0所以选B 39.What is the result of this expression? (or multiple ones)123456789var a = Date(0);var b = new Date(0);var c = new Date();[a === b, b === c, a === c]A.[true, true, true]B.[false, false, false]C.[false, true, false]D.[true, false, false] 考察Date对象参见Date对象 123var a = Date(0); // 返回当前时间，为字符串格式var b = new Date(0); // 返回1970...var c = new Date(); // 返回当前时间，为对象格式 不考虑返回类型，a, b, c也不会达到===程度的相等，选B 40.What is the result of this expression? (or multiple ones)1234567var min = Math.min(), max = Math.max()min &lt; maxA.trueB.falseC.errorD.other Math.min() // 无参数返回Inifinty,Math.max() // 无参数返回-Inifinty所以选择B 41.What is the result of this expression? (or multiple ones)123456789101112131415161718function captureOne(re, str) &#123; var match = re.exec(str); console.log(match); console.log(re.lastIndex); return match &amp;&amp; match[1];&#125;var numRe = /num=(\d+)/ig, wordRe = /word=(\w+)/i, a1 = captureOne(numRe, "num=1"), a2 = captureOne(wordRe, "word=1"), a3 = captureOne(numRe, "NUM=2"), a4 = captureOne(wordRe, "WORD=2");[a1 === a2, a3 === a4]A.[true, true]B.[false, false]C.[true, false]D.[false, true] 考察正则表达式对象的/g使用和exec()方法当正则表达式使用g标志时，可以多次执行exec方法来查找同一个字符串中的成功匹配。当你这样做时，查找将从正则表达式的lastIndex属性指定的位置开始。(test()也会更新lastIndex属性)。当调用exec()的正则表达式对象具有修饰符g时，它将把当前正则表达式对象的lastIndex属性设置为最近一次成功匹配的下一个位置，当同一个正则表达式第二次调用exec( )，即使匹配的是不同的字符串，它会将从lastIndex属性所指示的字符串处开始检索，如果exec()没有发现任何匹配结果，它会将lastIndex重置为0。所以a1执行完，numRe.lastIndex为5, a3无法匹配到，返回null。选择C 42.What is the result of this expression? (or multiple ones)12345678var a = new Date("2014-03-19"), b = new Date(2014, 03, 19);[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]A.[true, true]B.[true, false]C.[false, true]D.[false, false] 考察Date()的获取属性的方法,参加Date对象。用new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]])方法构造Date对象，月份从0开始，所以a, b表示的是不同的日子。所以选D 43.What is the result of this expression? (or multiple ones)12345678910if ('http://giftwrapped.com/picture.jpg'.match('.gif')) &#123; 'a gif file'&#125; else &#123; 'not a gif file'&#125;A.'a gif file'B.'not a gif file'C.errorD.other 考察String.prototype.match()方法和if()String.prototype.match()方法未匹配到返回null，匹配到返回Array。对参数非正则对象对其进行隐式转换，&#39;.gif&#39;中.匹配除回车之外的任意字符。所以选择A 44.What is the result of this expression? (or multiple ones)1234567891011121314function foo(a) &#123; var a; return a;&#125;function bar(a) &#123; var a = 'bye'; return a;&#125;[foo('hello'), bar('hello')]A.["hello", "hello"]B.["hello", "bye"]C.["bye", "bye"]D.other 考察变量提升和初始化变量提升，但是若变量已经存在于作用域中，那么就会移除变量定义，但是不会移除变量初始化。所以选B]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的Function对象总结]]></title>
    <url>%2F2017%2F08%2F12%2Fjs-function%2F</url>
    <content type="text"><![CDATA[属性argumentsarguments是一个类似数组的对象, 对应于传递给函数的参数。arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。 转换数组arguments对象不是一个Array。它类似于数组，但除了长度之外没有任何数组属性。例如，它没有pop方法。但是它可以被转换为一个真正的数组：123let args = Array.prototype.slice.call(arguments); let args = [].slice.call(arguments); 你还可以使用Array.from()方法或spread运算符将arguments转换为真正的数组：12let args = Array.from(arguments);let args = [...arguments]; 属性arguments.callee指向当前执行的函数。arguments.length指向传递给当前函数的参数数量。 lengthlength是函数对象的一个属性值，指该函数有多少个必须要传入的参数，那些已定义了默认值的参数不算在内，比如function（xx = 0）的length是0。与之对比的是，arguments.length是函数被调用时实际传参的个数。 Function构造器本身也是个Function。他的length属性值为 1 。该属性 Writable: false, Enumerable: false,Configurable: true。 Function原型对象的length属性值为 0 。 方法Function.prototype.apply()apply()方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 语法：1func.apply(thisArg, [argsArray]) 参数thisArg在func函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给func函数。如果该参数的值为null或undefined，则表示不需要传入任何参数。从ECMAScript5开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 描述在调用一个存在的函数时，你可以为其指定一个this对象。this指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，`而不用在新对象中重复写该方法。 apply与call非常相似，不同之处在于提供参数的方式。apply使用参数数组而不是一组参数列表（原文：a named set of parameters）。apply可以使用数组字面量（array literal），如 fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])，或数组对象， 如fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))。 你也可以使用arguments对象作为argsArray参数。arguments是一个函数的局部变量。它可以被用作被调用对象的所有未指定的参数。这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 Function.prototype.call()call()方法调用一个函数,其具有一个指定的this值和分别地提供的参数(参数的列表)。 注意：该方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 语法1func.call(thisArg[, arg1[, arg2[, ...]]]) 参数thisArg在func函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。arg1, arg2, ...指定的参数列表。 返回值返回结果包括指定的this值和参数。 描述可以让call()中的对象调用当前对象所拥有的function。你可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试总结]]></title>
    <url>%2F2017%2F08%2F09%2Finterview%2F</url>
    <content type="text"><![CDATA[2017-08-22更新 添加双飞翼、圣杯布局 2017-08-30更新 添加BFC 2017-08-31更新 添加js模块化,函数节流 2017-09-01更新 添加this对象分析 2017-09-02更新 添加并发编程与事件循环 2017-09-04更新 添加浏览器渲染，重排，重绘 2017-09-06更新 添加HTTP缓存，离线应用和客户端存储 2017-09-09更新 JS事件循环,setTimeout,setInterval 2017-09-21更新 Ajax原生实现过程 2017-09-23更新 添加HTTP/HTTPS 开放性问题为什么选择前端？项目遇到的问题及如何解决？技术性问题 JS类问题作用域参见我的博客Javascript函数和作用域总结 原型参见我的博客Javascript原型对象和原型链 闭包继承 面向对象和继承，object.create的实现原理? 设计模式观察者模式，实现原理？ Jquery Jquery特性及优缺点？ ES6 特性 ES6中的箭头函数可以用作构造函数吗？ Ajax参见我的博客前端Ajax操作总结 前端JS框架React/Vue/NG NG的双向数据绑定? 面向切面编程和函数式编程跨域 postmessage和iframe怎么结合使用? 那些操作会有跨域的限制？为什么要有跨域的限制？没有跨域的限制会怎么样？ 深拷贝怎么实现js中连续触发事件的稀释方法函数节流参见浅谈javascript节流在前端开发中，有时会为页面绑定resize事件，或者为一个页面元素绑定拖拽事件（其核心就是绑定mousemove），这种事件有一个特点，用户可能在一个短的时间内触发非常多次事件绑定程序。而DOM操作时很消耗性能的，这个时候如果你为这些事件绑定一些操作DOM节点的操作的话，那就会引发大量的计算，在用户看来，页面可能就一时间没有响应，这个页面一下子变卡了变慢了。甚至在IE下，如果你绑定的resize事件进行较多DOM操作，其高频率可能直接就使得浏览器崩溃。函数节流，简单地讲，就是让一个函数无法在很短的时间间隔内连续调用，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。函数节流背后的思想是指某些代码不可以在没有间断的情况下连续重复执行(代码可参见javascript高级程序设计p615) 123456function throttle(method, context) &#123; clearTimeout(method.tId); method.tId = setTimeout(function()&#123; method.call(context); &#125;, 100);&#125; 函数throttle接收两个参数:要执行的函数以及在哪个作用域执行。上面这个函数首先清除了之前设置的任何定时器，然后创建一个新的定时器，将其ID存储在方法的tId属性中。如果没有给第二个参数，那么就在全局作用域中。代码： 1234567function resizeDiv()&#123; var div = document.getElementById('myDiv'); div.style.height = div.offsetWidth + 'px';&#125;window.onresize = function()&#123; throttle(resizeDiv);&#125; 这样两次函数调用之间至少间隔100ms。 函数防抖参见js中连续触发事件的稀释方法（函数节流、函数防抖、标识变量）如果一直触发一个事件，函数节流的方法定义的方法永远不会执行，就像一个水龙头，如果关闭了，永远不会出水；函数防抖的方法像一个关闭水龙头不好用，当关闭水龙头隔一段时间会有滴水一样。就是一个事件如果频繁触发，会隔一段时间执行一次。函数防抖最常见的应用场景就是用户注册时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，再弹出提示语。以下还是以页面元素滚动监听的例子，来进行解析函数防抖的实现方式如下： 123456789101112131415161718192021var debounce = function(fn,delay,mustRunDelay)&#123; var timer = null; var t_start; return function()&#123; var context = this; var args = arguments; var t_curr = new Date(); clearTimeout(timer); if(!t_start)&#123; t_start = t_curr; &#125; if(t_curr - t_start &gt;= mustRunDelay) &#123; fn.apply(context,args); t_start = t_curr &#125; else &#123; timer = setTimeout(function()&#123; fn.apply(context,args); &#125;,delay); &#125; &#125;&#125; 该函数接收三个参数，分别为要执行的函数，隔多长时间清除函数定时器以及多长时间需要执行一次。如果利用函数防抖实现resize事件，实现方法如下: 1window.onresize = throttleV2(resizeDiv,50,100); 标识变量(立flag)参见js中连续触发事件的稀释方法（函数节流、函数防抖、标识变量）在项目中需要使用scroll事件，当scroll滚动到页面底部时，发送请求验证还有没有其他的资源需要加载。如果直接使用scroll事件，当滚动到文档底部发送ajax请求的话，ajax请求会连续触发。为了解决这个问题，设置一个初始值为true的标志变量，只有标识变量为true时才能发送ajax请求。当发送ajax请求时，将标志变量设为false，收到请求的响应并处理完后将标志变量设为true。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var pageIndex = &#123; newPage : 1, hotPage:1&#125;var scrollFlag = &#123; newFlag: true, hotFlag: true,&#125;EventUtil.addHandler(window,'scroll',function()&#123; scrollE(newPost,'new'); &#125;)function scrollE(ele,str)&#123;var totalHeight = document.documentElement.scrollTop + document.body.scrollTop + document.documentElement.clientHeight ; if(totalHeight &gt; ele.offsetTop + ele.offsetHeight) &#123; if(scrollFlag[str + "Flag"])&#123; scrollFlag[str + "Flag"] = false ; if(pageIndex[str + "Page"]&lt; 10) &#123; pageIndex[str + "Page"]++; var xhr=createXHR(); var postHtml = ele.innerHTML; xhr.onreadystatechange=function()&#123; if(xhr.readyState==1)&#123; ele.innerHTML = postHtml + '&lt;div class = "loading"&gt;&lt;div class="load-info"&gt;&lt;span class="load-img"&gt;&lt;/span&gt;我去拿数据 等我一会儿&lt;/div&gt;&lt;/div&gt;' &#125; if (xhr.readyState == 4) &#123; if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304) &#123; var res = xhr.responseText; res = JSON.parse(res); ele.innerHTML = postHtml + res.htmlres; if(res[str+'IsLastPage'])&#123; ele.innerHTML = ele.innerHTML+'&lt;div class = "final-page"&gt;&lt;span&gt;别拉啦 我已经加载完了&lt;span&gt;&lt;/div&gt;' &#125; else &#123; scrollFlag[str + "Flag"] = true; &#125; &#125;else&#123; console.log("request was unsuccessful:"+xhr.status); &#125; &#125; &#125; xhr.open('GET','postpage/' + str + '/' + pageIndex[str + "Page"],true); xhr.send(); &#125; &#125; &#125;&#125; javascript模块化模块的写法参见Javascript模块化编程（一）：模块的写法 原始：污染全局变量 对象：内部属性被访问 立即执行函数：模块的基本写法 放大模式：实现继承，参数为另一模块 宽放大模式：模块网络获取，加载时间不确定，参数可以为空对象 输入全局变量：显式地将其他变量输入模块。 AMD规范参见Javascript模块化编程（二）：AMD规范 模块规范：AMD -&gt; COMMONJS;CMD Node环境: 模块化参照Commonjs,使用require()加载模块 浏览器环境，若使用Commonjs规范，require()加载必须等待，浏览器处于假死状态。因此不能采用同步加载，只能采用异步加载。由此诞生AMD规范 AMD(Asynchronous Module Definition,异步模块定义)。require([module], callback);主要有两个Javascript库实现了AMD规范：require.js和curl.js。 require.js的用法参见Javascript模块化编程（三）：require.js的用法 requirejs实现js文件的异步加载，避免网页失去响应；管理模块之间的依赖性，便于代码的编写和维护。 AMD模块加载1&lt;script src="js/require.js" data-main="js/main" defer async="true"&gt;&lt;/script&gt; main.js即为主程序入口 1234// main.jsrequire(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123; // some code here&#125;); AMD模块定义如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 123456789// math.jsdefine(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性 12345678 define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;); Javascript垃圾回收参见JavaScript 内存管理 &amp; 垃圾回收机制垃圾回收机制原理：垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 方法标记清除js 中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个而变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。 引用计数这是最简单的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。Netscape Navigator3 是最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的引用。 触发条件IE6 的垃圾回收是根据内存分配量运行的，当环境中存在 256 个变量、4096 个对象、64K 的字符串任意一种情况的时候就会触发垃圾回收器工作，看起来很科学，不用按一段时间就调用一次，有时候会没必要，这样按需调用不是很好嘛？但是如果环境中就是有这么多变量一直存在，现在脚本如此复杂，很正常，那么结果就是垃圾回收器一直在工作，这样浏览器就没法玩了。 微软在 IE7 中做了调整，触发条件不再是固定的，而是动态修改的，初始值和IE6相同，如果垃圾回收器回收的内存分配量低于程序占用内存的 15%，说明大部分内存不可被回收，设的垃圾回收触发条件过于敏感，这时候把临界条件翻倍，如果回收的内存高于 85%，说明大部分内存早就该清理了，这时候把触发条件置回。这样就使垃圾回收工作智能了很多。 合理的 GC 方案JavaScript 引擎基础 GC 方案是（simple GC）：mark and sweep（标记清除），即： 遍历所有可访问的对象。 回收已不可访问的对象。 GC的缺陷和其他语言一样，JavaScript 的 GC 策略也无法避免一个问题：GC 时，停止响应其他操作，这是为了安全考虑。而 JavaScript 的 GC 在 100ms 甚至以上，对一般的应用还好，但对于 JS 游戏，动画连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免 GC 造成的长时间停止响应。 setInterval和setTimeout参见我的博客Javascript中并发编程与事件循环 javascript中的this参见我的博客this对象 js事件循环与并发编程参见我的博客Javascript中并发编程与事件循环 CSS问题浏览器CSS hack 各浏览器对元素的初始样式不同，可以进行reset操作 实现bootstrap栅格系统Canvas Canvas上画个圆，可以用诸如getElementById()之类的方法获取吗？ 答：不可以，canvas是通过js绘制的图形，图形是一个一个像素画上去的，不可以获取到。但是svg是基于XML格式，内部是一个个节点，可以用DOM操作获取节点。 canvas上的图像获取到吗？ 答：可以，canvas原生的toDataURL()方法获取图像的Base64编码 BFCFormatting context是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 最常见的Formatting context有Block fomatting context(简称BFC)和Inline formatting context(简称IFC)。CSS2.1 中只有BFC和IFC, CSS3中还增加了GFC和FFC. 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的float不是none) 绝对定位元素 (元素具有position为absolute或fixed) 内联块 (元素具有display: inline-block) 表格单元格 (元素具有display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有display: table-caption, HTML表格标题默认属性) 具有overflow且值不是visible的块元素， display: flow-root column-span: all应当总是会创建一个新的格式化上下文，即便具有column-span: all的元素并不被包裹在一个多列容器中。 BFC有一下特性： 内部的Box会在垂直方向，从顶部开始一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生叠加 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box叠加。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然。 计算BFC的高度时，浮动元素也参与计算。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (float) 与清除浮动 (clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。 两栏布局，左边固定，要求先加载内容区域，说出多种方法 圣杯布局 双飞翼布局 flex布局 如何实现Bootstrap的栅格布局计算机网络问题HTTP、HTTPS协议参见我的博客HTTP/HTTPS协议总结 TCP/IP协议综合URL输入后，具体的技术过程，浏览器怎么渲染的？ Web后台问题(node) 后端为什么使用node？ express/koa自动化构建工具 你使用过的构建工具，说说对webpack的理解? 图片压缩、上传、下载和缓存浏览器浏览器内部标签页间的通讯用什么方式？浏览器渲染，重排和重绘参见我的博客浏览器渲染原理总结 客户端存储参见我的博客Web应用客户端存储 性能优化HTTP缓存和离线应用参见我的博客Web缓存总结 数据库问题 数据库缓存 前端安全 HTTPS sql注入 xss攻击 csrf攻击 移动端问题数据结构和算法排序 快速排序 二叉排序树 动态规划搜索其他找出100万以内的质数？参见找出100万以内的质数 参考文献： 两列布局分析 Javascript模块化编程（一）：模块的写法 Javascript模块化编程（二）：AMD规范 Javascript模块化编程（三）：require.js的用法 浅谈javascript节流 js中连续触发事件的稀释方法（函数节流、函数防抖、标识变量） JavaScript 内存管理 &amp; 垃圾回收机制]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS hack]]></title>
    <url>%2F2017%2F08%2F09%2Fhack%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript操作DOM总结]]></title>
    <url>%2F2017%2F08%2F07%2Fjs-dom%2F</url>
    <content type="text"><![CDATA[2017-09-09更新 DOM文档对象模型 (DOM) 是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变文档的结构，样式和内容。DOM 将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。简言之，它会将web页面和脚本或程序语言连接起来。 DOM重要数据类型Document对象继承自Node和EventTarget继承自HTMLDocument接口参见Document 对象 说明 document 当一个成员返回document对象（例如，元素的ownerDocument属性返回,它所属于document) ，这个对象就是document对象本身。 element element是指由 DOM API 中成员返回的类型为element的一个元素或节点。 例如，document.createElement()方法会返回一个node的对象引用，也就是说这个方法返回了在DOM中创建的 element。element对象实现了DOM Element接口以及更基本的Node接口。 nodeList nodeList是一个元素的数组，如从document.getElementsByTagName()方法返回的就是这种类型。 nodeList中的条目由通过下标有两种方式进行访问：list.item(1),list[1],两种方式是等价的，第一种方式中item()是nodeList对象中的单独方法。 后面的方式则使用了经典的数组语法来获取列表中的第二个条目。 attribute 当attribute通过成员函数 (例如，通过createAttribute()方法) 返回时，它是一个为属性暴露出专门接口的对象引用。DOM中的属性也是节点，就像元素一样，只不过您可能会很少使用它。 namedNodeMap namedNodeMap和数组类似，但是条目是由name或index访问的，虽然后一种方式仅仅是为了枚举方便，因为在 list 中本来就没有特定的顺序。 出于这个目的，namedNodeMap有一个item()方法，你也可以从namedNodeMap添加或移除条目。 window对象表示浏览器中的内容 DOM创建DOM节点（Node）通常对应于一个标签，一个文本，或者一个HTML属性。DOM节点有一个nodeType属性用来表示当前元素的类型，它是一个整数: Element，元素 Attribute，属性 Text，文本DOM节点创建最常用的便是document.createElement和document.createTextNode方法： 123var el1 = document.createElement('div');var el2 = document.createElement('input');var node = document.createTextNode('hello world!'); DOM查询元素查询的API返回的的结果是DOM节点或者DOM节点的列表。document提供了两种Query方法。123456789// 返回当前文档中第一个类名为 "myclass" 的元素var el = document.querySelector(".myclass");// 返回一个文档中所有的class为"note"或者 "alert"的div元素var els = document.querySelectorAll("div.note, div.alert");// 获取元素var el = document.getElementById('xxx');var els = document.getElementsByClassName('highlight');var els = document.getElementsByTagName('td'); Element也提供了很多相对于元素的DOM导航方法：123456789101112131415161718// 获取父元素、父节点var parent = ele.parentElement;var parent = ele.parentNode;// 获取子节点，子节点可以是任何一种节点，可以通过nodeType来判断var nodes = ele.children; // 查询子元素var els = ele.getElementsByTagName('td');var els = ele.getElementsByClassName('highlight');// 当前元素的第一个/最后一个子元素节点var el = ele.firstElementChild;var el = ele.lastElementChild;// 下一个/上一个兄弟元素节点var el = ele.nextElementSibling;var el = ele.previousElementSibling; DOM更改123456789// 添加、删除子元素ele.appendChild(el);ele.removeChild(el);// 替换子元素ele.replaceChild(el1, el2);// 插入子元素parentElement.insertBefore(newElement, referenceElement); 属性操作12345678910111213// 获取一个&#123;name, value&#125;的数组var attrs = el.attributes;// 获取、设置属性var c = el.getAttribute('class');el.setAttribute('class', 'highlight');// 判断、移除属性el.hasAttribute('class');el.removeAttribute('class');// 是否有属性设置el.hasAttributes(); Node.innerTextNode.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。 作为一个获取器，如果用光标突出显示元素的内容，然后将其复制到剪贴板，则它将近似于用户将获得的文本。此功能最初由Internet Explorer引入，并在所有主要浏览器供应商采用后于2016年在HTML标准中正式规定。 Node.textContent是一个有点类似的替代方案，虽然两者之间有重要的区别。 element.innerHTMLElement.innerHTML属性设置或获取描述元素后代的HTML语句。 Note: 如果一个&lt;div&gt;,&lt;span&gt;, 或 &lt;noembed&gt;节点具有一个文本子节点,包含字符(&amp;),(&lt;), 或(&gt;), innerHTML将这些字符分别返回为＆amp;, ＆lt;和＆gt;。使用Node.textContent获取一个这些文本节点内容的正确副本。 参考文献 原生JavaScript的DOM操作汇总 DOM概述]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript零散笔记]]></title>
    <url>%2F2017%2F08%2F06%2Fjs-other%2F</url>
    <content type="text"><![CDATA[JavaScript 中包含以下 7 个全局函数escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )。 JavaScript为指定元素绑定一个事件处理器函数Javascript块内声明函数不要在块内声明一个函数（严格模式会报语法错误）。如果确实需要在块中定义函数，可以使用函数表达式来声明函数。 12345678910/* Recommended */if (x) &#123; var foo = function() &#123;&#125;;&#125;/* Wrong */if (x) &#123; function foo() &#123;&#125;&#125; Jquery获取宽高12345678alert($(window).height()); //浏览器当前窗口可视区域高度 alert($(document).height()); //浏览器当前窗口文档的高度 alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度 alert($(document).width());//浏览器当前窗口文档对象宽度 alert($(document.body).width());//浏览器当前窗口文档body的高度 alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin 浏览器兼容性问题 SD9017: Firefox 不支持 DOM 对象的 outerHTML、innerText、outerText 属性(参见http://w3help.org/zh-cn/causes/SD9017) SD9010: 仅 IE 中的 createElement 方法支持传入 HTML String 做参数 SD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现 2017.08.15更新 parseInt()parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。 语法1parseInt(string, radix); 参数string要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用ToString抽象操作)。字符串开头的空白符将会被忽略。radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。 返回值返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回NaN。 描述parseInt函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。例如：radix参数为10将会把第一个参数看作是一个数的十进制表示，8对应八进制，16对应十六进制，等等。基数大于10时，用字母表中的字母来表示大于9的数字。例如十六进制中，使用A到F。如果parseInt遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。parseInt将截取整数部分。开头和结尾的空白符允许存在，会被忽略。在没有指定基数，或者基数为0的情况下，JavaScript作如下处理： 如果字符串string以”0x”或者”0X”开头,则基数是16(16进制). 如果字符串string以”0”开头,基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript5规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串string以其它任何值开头，则基数是10(十进制)。 如果第一个字符不能被转换成数字，parseInt返回NaN。 算术上，NaN不是任何一个进制下的数。你可以调用isNaN来判断parseInt是否返回NaN。NaN参与的数学运算其结果总是NaN。将整型数值以特定基数转换成它的字符串值可以使用intValue.toString(radix). null与undefined值null是一个 JavaScript 字面量，表示空值（null or an “empty” value），即没有对象被呈现（no object value is present）。它是JavaScript原始数据类型之一。 全局属性undefined表示原始值undefined。它是一个JavaScript的原始数据类型 。JavaScript的原始数据类型：String,Number,Bollean,null,undefined,symbol(ES2015新增) null与undefined的不同点：123456789typeof null // object (因为一些以前的原因而不是&apos;null&apos;)typeof undefined // undefinednull === undefined // falsenull == undefined // truenull === null // truenull == null // true!null //trueisNaN(1 + null) // falseisNaN(1 + undefined) // true js精度丢失计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。解决方案： 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数） switchswitch()使用===判断相等 2017.08.19更新 Number.prototype.toString()使用注意Number对象使用toString方法，Number对象必须加上(),否则表示小数。不加括号会报错。 2017.08.20更新 RegExp.prototype.exec()RegExp.prototype.test()Date对象构造函数1234new Date();//访问当前时间new Date(value);new Date(dateString);new Date(year, month[, day[, hour[, minutes[, seconds[, milliseconds]]]]]); 参数value代表自1970年1月1日00:00:00 (世界标准时间) 起经过的毫秒数。dateString`表示日期的字符串值。该字符串应该能被Date.parse()方法识别(符合IETF-compliant RFC 2822 timestamps或version of ISO8601)。year代表年份的整数值。为了避免2000年问题最好指定4位数的年份; 使用 1998, 而不要用 98.month代表月份的整数值从0（1月）到11（12月）。day代表一个月中的第几天的整数值，从1开始。hour代表一天中的小时数的整数值 (24小时制)。minute分钟数。second秒数。millisecond表示时间的毫秒部分的整数值。 注意 Note 1: 需要注意的是只能通过调用Date构造函数来实例化日期对象：以常规函数调用它（即不加new操作符）将会返回&gt;一个字符串，而不是一个日期对象。另外，不像其他JavaScript 类型，Date对象没有字面量格式。 Note2 : 当Date作为构造函数调用并传入多个参数时，如果数值大于合理范围时（如月份为13或者分钟数为70），相邻的数值会被调整。比如new Date(2013, 13, 1)等于new Date(2014, 1, 1)，它们都表示日期2014-02-01（注意月份是从0开始的）。其他数值也是类似，new Date(2013, 2, 1, 0, 70)等于new Date(2013, 2, 1, 1, 10)，都表示时间2013-03-01T01:10:00。 Date.parse()Date.parse()方法解析一个表示某个日期的字符串，并返回从1970-1-1 00:00:00 UTC 到该日期对象（该日期对象的UTC时间）的毫秒数，如果该字符串无法识别，或者一些情况下，包含了不合法的日期数值（如：2015-02-31），则返回值为NaN。 语法显示调用：1Date.parse(dateString) 隐式调用：1new Date(dateString) 参数dateString一个符合IETF-compliant RFC 2822 timestamps或version of ISO8601日期格式的字符串（其他格式也许也支持，但结果可能与预期不符）。 返回值一个表示从1970-1-1 00:00:00 UTC到给定日期字符串所表示时间的毫秒数的数值。如果参数不能解析为一个有效的日期，则返回NaN。描述 Date.prototype.getDay()语法1dateObj.getDay() 参数无 返回值getDay()返回一个整数值：0代表星期日,1代表星期一,2代表星期二,依次类推。 Date.prototype.getDate()语法1dateObj.getDate() 参数无 返回值getDate()返回一个1到31的整数值。 ## 语法1dateObj.getMonth() 参数无 返回值getMonth返回一个0到11的整数值：0代表一月份，1代表二月分，2 代表三月份，依次类推。 正则表达式RegExpg全局匹配;找到所有匹配，而不是在第一个匹配后停止 浏览器内核chrome: Webkit –&gt; BlinkSafari: WebkitMozilla: GeckoIE: TridentOpear: Presto –&gt; Blink 浏览器解析方式 非怪异（标准）模式 怪异模式(一个不含任何DOCTYPE的网页将会以 怪异(quirks) 模式渲染。) 部分怪异（近乎标准）模式(实施了一种表单元格尺寸的怪异行为，除此之外符合标准定义。) HTML5提供的&lt;DOCTYPE html&gt;是标准模式，向后兼容的, 等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的 标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。 DOM结构DOM节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 节点的关系父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）: 在节点树中，顶端节点被称为根（root） 每个节点都有父节点、除了根（它没有父节点） 一个节点可拥有任意数量的子 同胞是拥有相同父节点的节点 HTML5新增与HTML4不同之处 文件类型声明（&lt;!DOCTYPE&gt;）仅有一型：&lt;!DOCTYPE HTML&gt;。 新的解析顺序：不再基于SGML。 新的元素：section, video, progress, nav, meter, time, aside, canvas, command, datalist, details, embed, figcaption, figure, footer, header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary, wbr。 input元素的新类型：date, email, url等等。 新的属性：ping（用于a与area）, charset（用于meta）, async（用于script）。 全域属性：id, tabindex, repeat。 新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。 移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike, tt。 新应用程序接口（API）除了原先的DOM接口，HTML5增加了更多样化的API:- HTML Geolocation HTML Drag and Drop HTML Local Storage HTML Application Cache HTML Web Workers HTML SSE HTML Canvas/WebGL HTML Audio/VideoHTML5文档类型声明在 HTML5 中，文档类型声明很简单：&lt;!DOCTYPE HTML&gt;在所有 HTML 文档中规定文档类型很重要，这样浏览器才能了解所预期的文档类型。HTML 4.01 中的 doctype 需要引用一个 DTD，这是因为 HTML 4.01 基于 SGML。HTML5 不基于 SGML，也不需要引用 DTD，但是需要声明文档类型让浏览器按照它们应该的方式来运行。 外边距叠加外边距叠加是一个相当简单的概念。 但是，在实践中对网页进行布局时， 它会造成许多混淆。 简单的说， 当两个或更多个垂直边距相遇时， 它们将形成一个外边距。这个外边距的高度等于两个发生叠加的外边距的高度中的较大者。但是注意只有普通文档流中块框的垂直外边距才会发生外边距叠加。 行内框、 浮动框或绝对定位框之间的外边距不会叠加。 一般来说， 垂直外边距叠加有三种情况： 元素自身叠加。当元素没有内容（即空元素）、内边距、边框时，它的上下边距就相遇了，即会产生叠加（垂直方向）。 当为元素添加内容、内边距、边框任何一项，就会取消叠加。 相邻元素叠加。相邻的两个元素，如果它们的上下边距相遇，即会产生叠加。 包含（父子）元素叠加。包含元素的外边距隔着父元素的内边距和边框， 当这两项都不存在的时候，父子元素垂直外边距相邻，产生叠加。添加任何一项即会取消叠加。 参见给了body position:relative后 margin-top影响其他元素定位位置是为什么? 变量对象基本类型红宝书上解释的五种基本类型： number string boolean undefined null但是也有人认为是六种，加上object, 成为复杂数据类型。 特殊包装类Boolean: 布尔对象String: 字符串对象Number: 数字对象这些对象的创建，是通过相应的内置构造器创建，并且包含原生值作为其内部属性，这些对象可以转换省原始值，反之亦然。1234567891011121314var c = new Boolean(true);var d = new String('test');var e = new Number(10);// 转换成原始值// 使用不带new关键字的函数с = Boolean(c);d = String(d);e = Number(e);// 重新转换成对象с = Object(c);d = Object(d);e = Object(e); typeof操作符返回的类型只有六种: string number boolean undefined object function instanceof操作符instanceof操作符用来比较两个操作数的构造函数。只有在比较自定义的对象时才有意义。如果用来比较内置类型，将会和typeof操作符 一样用处不大。 Object.prototype.toString获取[[class]]检测一个对象的类型，强烈推荐使用Object.prototype.toString方法； 因为这是唯一一个可依赖的方式。正如上面表格所示，typeof的一些返回值在标准文档中并未定义， 因此不同的引擎实现可能不同。 我们使用Object.prototype.toString方法:123Object.prototype.toString.call([]) // "[object Array]"Object.prototype.toString.call(&#123;&#125;) // "[object Object]"Object.prototype.toString.call(2) // "[object Number]" 事件监听HTML内联属性类似&lt;button onclick=&quot;alert(&#39;你点击了这个按钮&#39;);&quot;&gt;点击这个按钮&lt;/button&gt;的方式，这种方式会使JS与HTML高度耦合，不利于开发和维护，不推荐使用。 DOM属性绑定使用DOM元素的onXXX属性设置，简单易懂，兼容性好。缺点是只能绑定一个处理函数。 事件监听函数使用事件监听函数element.addEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;);，在element这个对象上面添加一个事件监听器，当监听到有事件发生的时候，调用这个回调函数。至于这个参数，表示该事件监听是在“捕获”阶段中监听（设置为true）还是在“冒泡”阶段中监听（设置为false）。 移除事件监听使用事件解除绑定方法:element.removeEventListener(&lt;event-name&gt;, &lt;callback&gt;, &lt;use-capture&gt;);需要注意的是，绑定事件时的回调函数不能是匿名函数，必须是一个声明的函数，因为解除事件绑定时需要传递这个回调函数的引用，才可以断开绑定。 模拟触发事件内置的时间也可以被JavaScript模拟触发，使用dispatchEvent方法。 自定义事件与自定义事件的函数有Event、CustomEvent和dispatchEvent。 Event直接自定义事件，使用Event构造函数 CustonEventCustomEvent可以创建一个更高度自定义事件，还可以附带一些数据，具体用法如下：1var myEvent = new CustomEvent(eventname, options); dispatchEvent这个用于触发自定义的事件 事件顺序W3C :首先进入事件捕获阶段-&gt;达到元素后-&gt;进入事件冒泡阶段。开发者可以通过addEventListener函数的第三个参数设置事件触发的阶段，默认为false,冒泡阶段。而DOM1级别的事件绑定则只能在冒泡阶段触发。 事件代理事件绑定后，检测顺序就会从被绑定的DOM下滑到触发的元素，再冒泡会绑定的DOM上。也就是说，如果你监听了一个DOM节点，那也就等于你监听了其所有的后代节点。代理的意思就是只监听父节点的事件触发，以来代理对其后代节点的监听，而你需要做的只是通过currentTarget属性得到触发元素并作出回应。使用事件代理意味着你可以节省大量重复的事件监听，以减少浏览器资源消耗。还有一个好处就是让HTML独立起来，比如之后还有要加子元素的需求，也不需要再为其单独加事件监听了。获取点击的li节点的内容12345678&lt;ul id="parent-list"&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;li&gt;Item 6&lt;/li&gt;&lt;/ul&gt; 1234567891011var ul =document.getElementsByTagName("ul")[0];ul.addEventListener('click',function()&#123; //兼容IE event = event || window.event; //IE使用srcElement，这里获取目标元素 var target = event.target || event.srcElement; //对目标元素进行判定 if(target&amp;&amp;target.nodeName.toUpperCase()=="LI")&#123;/*判断目标事件是否为li*/ alert(target.innerHTML); &#125;&#125;,false); jquery delegate函数$(selector).delegate(childSelector,event,data,function)delegate()方法为指定的元素（属于被选元素的子元素）添加一个或多个事件处理程序，并规定当这些事件发生时运行的函数。使用delegate()方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。 事件的Event对象当一个事件被触发的时候，会创建一个事件对象（Event Object），这个对象里面包含了一些有用的属性或者方法。事件对象会作为第一个参数，传递给我们的回调函数。 常用属性和方法type(string): 事件的名称，比如 “click”。target(node): 事件要触发的目标节点。currentTarget(node): 它就指向正在处理事件的元素：这恰是我们需要的。很不幸的是微软模型中并没有相似的属性, 你也可以使用”this”关键字。事件属性也提供了一个值可供访问:event.currentTarget。bubbles (boolean): 表明该事件是否是在冒泡阶段触发的。preventDefault (function): 这个方法可以禁止一切默认的行为，例如点击 a 标签时，会打开一个新页面，如果为 a 标签监听事件 click 同时调用该方法，则不会打开新页面。stopPropagation (function): 很多时候，我们触发某个元素，会顺带触发出它父级身上的事件，这有时候是我们不想要的，大多数我们想要的还是事件相互独立。所以我们可以选择阻止事件冒泡，使用event.stopPropagation().stopImmediatePropagation (function): 与stopPropagation类似，就是阻止触发其他监听函数。但是与stopPropagation不同的是，它更加 “强力”，阻止除了目标之外的事件触发，甚至阻止针对同一个目标节点的相同事件。cancelable (boolean): 这个属性表明该事件是否可以通过调用event.preventDefault方法来禁用默认行为。eventPhase (number): 这个属性的数字表示当前事件触发在什么阶段。 0: none 1: 捕获 2: 目标 3: 冒泡pageX和pageY (number): 这两个属性表示触发事件时，鼠标相对于页面的坐标。isTrusted (boolean): 表明该事件是浏览器触发（用户真实操作触发），还是 JavaScript代码触发的。 事件的回调函数事件绑定函数时，该函数会以当前元素为作用域执行,所以回调函数中的this是当前的DOM元素。如果我们需要指定作用域，可以选择: 使用匿名函数包裹回调函数 使用bind方法 常用事件load 资源加载完成时触发。这个资源可以是图片、CSS 文件、JS 文件、视频、document和window等等。DOMContentLoaded DOM构建完毕的时候触发, jQuery的ready方法包裹的就是这个事件。beforeunload 当浏览者在页面上的输入框输入一些内容时，未保存、误操作关掉网页可能会导致输入信息丢失。当浏览者输入信息但未保存时关掉网页，我们就可以开始监听这个事件,这时候试图关闭网页的时候，会弹窗阻止操作，点击确认之后才会关闭。当然，如果没有必要，就不要监听，不要以为使用它可以为你留住浏览者。resize 当节点尺寸发生变化时，触发这个事件。通常用在window上，这样可以监听浏览器窗口的变化。通常用在复杂布局和响应式上。出于对性能的考虑，你可以使用函数throttle或者debounce技巧来进行优化，throttle方法大体思路就是在某一段时间内无论多次调用，只执行一次函数，到达时间就执行；debounce 方法大体思路就是在某一段时间内等待是否还会重复调用，如果不会再调用，就执行函数，如果还有重复调用，则不执行继续等待。error 当我们加载资源失败或者加载成功但是只加载一部分而无法使用时，就会触发error事件，我们可以通过监听该事件来提示一个友好的报错或者进行其他处理。比如 JS 资源加载失败，则提示尝试刷新；图片资源加载失败，在图片下面提示图片加载失败等。该事件不会冒泡。因为子节点加载失败，并不意味着父节点加载失败，所以你的处理函数必须精确绑定到目标节点。 IE事件123element.attachEvent(&lt;event-name&gt;, &lt;callback&gt;);event = event || window.event`node = event.srcElement || event.target; ES6先记录一些内容： Arrow Function Let Proxy Destructuring Tail Calling Template Strings Class Promises Generator for…in…和for…of…for……in……遍历对象所有的可枚举对象 12345678910111213141516171819var obj = &#123; 'a': 1, 'b': 2, 'c': 3&#125;;Object.prototype.age = 24;Object.defineProperty(obj, "school", &#123; configurable: true, writable: true, //枚举的属性 enumerable: true, value: 'whut'&#125;)// var a = Object.keys(obj);for (var index in obj) &#123; if (obj.hasOwnProperty(index)) &#123; console.log(obj[index]); &#125;&#125; for……of……CSS截断单行截断多行截断参考文献 MDN-Date MDN-Date.parse() MDN-Date.prototype.getDay() MDN-Date.prototype.getDate() MDN-Date.prototype.getMonth() MDN-正则表达式 MDN-RegExp 变量对象]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript函数和作用域总结]]></title>
    <url>%2F2017%2F08%2F05%2Fjs-scope%2F</url>
    <content type="text"><![CDATA[2017-09-01 添加this对象分析 一、执行环境和作用域执行环境(execution context)定义了函数或变量有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境。某个执行环境的所有代码执行完毕后，该环境销毁，保存在其中的所有变量和函数定义也随之销毁。（全局执行环境直到应用程序退出才会销毁）每个函数都有自己的执行环境。当执行流程进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象最开始只包含一个变量，即arguments对象(这个对象在全局环境中不存在的)，作用域链中的下一个对象来自包含(外部)环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程中始终从作用域链的前端开始。搜索过程始终从作用域链的前端开始然后逐级地向后回溯，知道找到标识符为止（若找不到，通常会导致错误发生） js没有块级作用域，但是在es6中新增let关键字可定义块级变量。 二、函数定义函数声明123function sum(num1,num2)&#123; return num1 + num2;&#125; 函数表达式123var sum = function(num1,num2)&#123; return num1 + num2;&#125; 解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解析执行。在代码开始之前，解析器就已通过一个名为函数声明提升(function declaration hoisting)的过程，将函数声明添加到执行环境中。对代码求值时，Javascript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，Javascript引擎也能把函数声明提升到顶部。 Function构造函数12//接收任意数量参数，最后一个参数始终被看做函数体var sum = new Function('num1','num2','return num1 + num2');//不推荐 函数是对象，函数名是指针 没有重载同名函数后一个函数会覆盖前一个函数，不会发生函数重载 三、参数传递基本类型按值传递1234567function setNum(num)&#123; num += 10; return num;&#125;var a = 10;var result = setNum(a);console.log(result);//20 引用类型按指针的值传递，并非按引用传递1234567891011121314151617181920function setObj(obj)&#123; obj.name = 'zxlg'; return obj;&#125;var person = new Object();setObj(person);console.log(person.name);// 'zxlg'//使用对象，看似按引用传递，//其实不然，参数传递的是指针的值，//指针的值是不会变的，指针指向的内容有可能会被改变function setObj(obj)&#123; obj.name = 'zxlg'; obj = new Object(); obj.name = 'fool'; return obj;&#125;var person = new Object();setObj(person);console.log(person.name);//'zxlg' 四、arguments对象和this对象arguments对象类数组对象，包含着传入函数中的所有参数，可以用方括号访问它的每一个元素，使用length来确定传进多少个元素。函数命名的参数只提供便利，但不是必需的。1234function doAdd(num1,num2)&#123; arguments[1] = 10; console.log(arguments[0] + num2);&#125; arguments的值永远与对应命名参数的值保持同步。在非严格模式下，重写arguments[1]，也就修改了num2,结果均变为10(严格模式下重写arguments的值会导致语法错误)。但它们的内存空间是独立的，而arguments的值会与参数的值同步。 若只传入一个参数，那么arguments[1]设置的值不会反应到命名参数中，因为arguments对象的长度是由传入参数的个数决定的，不是由定义函数的参数的个数决定的。 没有传递值的命名参数自动被赋予undefined值，类似于定义变量但没有初始化。 arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向这个拥有arguments对象的函数。12345678//阶乘函数function factorial(num)&#123; if(num &lt; 1)&#123; return 1; &#125;else&#123; return num * factorial(num - 1); &#125;&#125; 函数有名字，函数的执行与函数名factorial紧紧耦合在一起，使用arguments.callee可消除这种耦合。1234567function factorial(num)&#123; if(num &lt; 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num - 1); &#125;&#125; this对象this是一个完全根据调用点（函数在代码中被调用的位置而不是被声明的位置）而为每次函数调用建立的绑定。this引用的是函数执行的环境对象，即调用函数的那个对象。参见《你不懂JS: this 与对象原型》第二章: this 豁然开朗！ this的四种绑定方式默认绑定123456// 1 默认绑定全局变量function foo() &#123; console.log(this.a);&#125;var a = 2;foo(); // 非严格模式下:2; 严格模式下：Cannot read property 'a' of undefined 我们考察调用点来看看foo()是如何被调用的。在我们的代码段中，foo()是被一个直白的，毫无修饰的函数引用调用的。没有其他的我们将要展示的规则适用于这里，所以默认绑定在这里适用。如果strict mode在这里生效，那么对于默认绑定来说全局对象是不合法的，所以this将被设置为undefined。 隐含绑定1234567891011// 2 obj 对象在函数被调用的时间点上“拥有”或“包含”这个 函数引用function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); // 2 调用点使用obj环境来引用函数，所以可以说obj对象在函数被调用的时间点上“拥有”或“包含”这个函数引用。在foo()被调用的位置上，它被冠以一个指向obj的对象引用。当一个方法引用存在一个环境对象时，隐含绑定规则会说：是这个对象应当被用于这个函数调用的this绑定。注意foo()被声明然后作为引用属性添加到obj上的方式。无论foo()是否一开始就在obj上被声明，还是后来作为引用添加（如上面代码所示），这个函数都不被obj所真正“拥有”或“包含”。123456789101112131415// 3 对象属性引用链的最后一层是影响调用点的function foo() &#123; console.log(this.a);&#125;var obj2 = &#123; a: 42, foo: foo&#125;;var obj1 = &#123; a: 2, obj2: obj2&#125;;obj1.obj2.foo(); // 42 只有对象属性引用链的最后一层是影响调用点的。 隐含丢失123456789101112131415// 4 隐含丢失function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数引用！var a = "oops, global"; // `a` 也是一个全局对象的属性bar(); // "oops, global" 尽管bar似乎是obj.foo的引用，但实际上它只是另一个foo本身的引用而已。另外，起作用的调用点是bar()，一个直白毫无修饰的调用，因此默认绑定适用于这里。1234567891011//等价于function foo() &#123; console.log(this.a);&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数引用！var a = "oops, global"; // `a` 也是一个全局对象的属性foo(); // "oops, global" 当我们考虑传递一个回调函数时：123456789101112131415161718function foo() &#123; console.log( this.a );&#125;function doFoo(fn) &#123; // `fn` 只不过 `foo` 的另一个引用 fn(); // &lt;-- 调用点!&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "oops, global"; // `a` 也是一个全局对象的属性doFoo( obj.foo ); // "oops, global" 参数传递仅仅是一种隐含的赋值，而且因为我们在传递一个函数，它是一个隐含的引用赋值，所以最终结果和我们前一个代码段一样。123456789101112131415161718192021//等价于function foo() &#123; console.log( this.a );&#125;function doFoo(fn) &#123; // `fn` 只不过 `foo` 的另一个引用 fn(); // &lt;-- 调用点!&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "oops, global"; // `a` 也是一个全局对象的属性doFoo( function foo() &#123; console.log( this.a );// "oops, global"&#125;); 那么如果接收你所传递回调的函数不是你的，而是语言内建的呢？没有区别，同样的结果。123456789101112function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "oops, global"; // `a` 也是一个全局对象的属性setTimeout( obj.foo, 100 ); // "oops, global" 123456789101112131415//等价于function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = "oops, global"; // `a` 也是一个全局对象的属性setTimeout( function foo() &#123; console.log( this.a );// "oops, global"&#125;, 100 ); 明确绑定JavaScript语言中的“所有”函数都有一些工具（通过他们的[[Prototype]]）可以用于这个任务。具体地说，函数拥有call(..)和apply(..)方法。它们接收的第一个参数都是一个用于this的对象，之后使用这个指定的this来调用函数。因为你已经直接指明你想让this是什么，所以我们称这种方式为明确绑定。12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2// 通过 foo.call(..) 使用 明确绑定 来调用 foo，允许我们强制函数的 this 指向 obj。 硬绑定单独依靠明确绑定仍然b不能解决函数“丢失”自己原本的this绑定，或者被第三方框架覆盖，等等问题。123456789101112131415161718function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call( obj );&#125;;bar(); // 2setTimeout( bar, 100 ); // 2// `bar` 将 `foo` 的 `this` 硬绑定到 `obj`// 所以它不可以被覆盖bar.call( window ); // 2 由于硬绑定是一个如此常用的模式，它已作为ES5的内建工具提供：Function.prototype.bind12345678910111213function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a: 2&#125;;var bar = foo.bind( obj );var b = bar( 3 ); // 2 3console.log( b ); // 5 bind(..)返回一个硬编码的新函数，它使用你指定的this环境来调用原本的函数。 注意：在 ES6 中，bind(..)生成的硬绑定函数有一个名为.name的属性，它源自于原始的目标函数（target function）。举例来说：bar = foo.bind(..)应该会有一个bar.name属性，它的值为&quot;bound foo&quot;，这个值应当会显示在调用栈轨迹的函数调用名称中。 new绑定首先，让我们重新定义JavaScript的“构造器”是什么。在JS中，构造器仅仅是一个函数，它们偶然地与前置的new操作符一起调用。它们不依附于类，它们也不初始化一个类。它们甚至不是一种特殊的函数类型。它们本质上只是一般的函数，在被使用new来调用时改变了行为。实际上不存在“构造器函数”这样的东西，而只有函数的构造器调用。 当在函数前面被加入new调用时，也就是构造器调用时，下面这些事情会自动完成： 一个全新的对象会凭空创建（就是被构建） 这个新构建的对象会被接入原形链（[[Prototype]]-linked） 函数调用的this绑定到这个新构建的对象 除非函数返回一个它自己的其他对象，否则这个被new调用的函数将自动返回这个新构建的对象。 123456function foo(a) &#123; this.a = a;&#125;var bar = new foo( 2 );console.log( bar.a ); // 2 通过在前面使用new来调用foo(..)，我们构建了一个新的对象并把这个新对象作为foo(..)调用的this 四种绑定方式的优先级默认绑定在四种规则中优先级最低的。 隐含绑定和明确绑定优先级12345678910111213141516171819function foo() &#123; console.log( this.a );&#125;var obj1 = &#123; a: 2, foo: foo&#125;;var obj2 = &#123; a: 3, foo: foo&#125;;obj1.foo(); // 2obj2.foo(); // 3obj1.foo.call( obj2 ); // 3obj2.foo.call( obj1 ); // 2 明确绑定的优先级要高于隐含绑定，这意味着你应当在考察隐含绑定之前首先考察明确绑定是否适用。 new绑定和明确绑定、隐含绑定的优先级12345678910111213141516171819function foo(something) &#123; this.a = something;&#125;var obj1 = &#123; foo: foo&#125;;var obj2 = &#123;&#125;;obj1.foo( 2 );console.log( obj1.a ); // 2obj1.foo.call( obj2, 3 );console.log( obj2.a ); // 3var bar = new obj1.foo( 4 );console.log( obj1.a ); // 2console.log( bar.a ); // 4 new绑定的优先级要高于隐含绑定 注意：new和call/apply不能同时使用，所以new foo.call(obj1)是不允许的，也就是不能直接对比测试new绑定和明确绑定。但是我们依然可以使用硬绑定来测试这两个规则的优先级。在我们进入代码中探索之前，回想一下硬绑定物理上是如何工作的，也就是Function.prototype.bind(..)创建了一个新的包装函数，这个函数被硬编码为忽略它自己的this绑定（不管它是什么），转而手动使用我们提供的。那么似乎硬绑定（明确绑定的一种）的优先级要比new绑定高，而且不能被new覆盖。12345678910111213function foo(something) &#123; this.a = something;&#125;var obj1 = &#123;&#125;;var bar = foo.bind( obj1 );bar( 2 );console.log( obj1.a ); // 2var baz = new bar( 3 );console.log( obj1.a ); // 2console.log( baz.a ); // 3 bar是硬绑定到obj1的，但是new bar(3)并没有像我们期待的那样将obj1.a变为3。反而，硬绑定（到obj1）的bar(..)调用可以被new所覆盖。使用new创建了一个名为baz的新创建的对象，而且我们确实看到baz.a的值为3。 结论现在，我们可以按照优先顺序来总结一下从函数调用的调用点来判定this的规则了。按照这个顺序来问问题，然后在第一个规则适用的地方停下。 函数是通过new被调用的吗（new绑定）？如果是，this就是新构建的对象。 1var bar = new foo() 函数是通过call或apply被调用（明确绑定），甚至是隐藏在bind硬绑定之中吗？如果是，this就是那个被明确指定的对象。 1var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this就是那个环境对象。 1var bar = obj1.foo() 否则，使用默认的this（默认绑定）。如果在strict mode下，就是undefined，否则是global对象。 1var bar = foo() 以上，就是理解对于普通的函数调用来说的this绑定规则。是的……几乎是全部。 例外被忽略的this如果你传递null或undefined作为call、apply或bind的this绑定参数，那么这些值会被忽略掉，取而代之的是默认绑定规则将适用于这个调用。一个很常见的做法是，使用apply(..)来将一个数组散开，从而作为函数调用的参数。相似地，bind(..)可以柯里化参数（预设值），也可能非常有用。12345678910function foo(a,b) &#123; console.log( "a:" + a + ", b:" + b );&#125;// 将数组散开作为参数foo.apply( null, [2, 3] ); // a:2, b:3// 用 `bind(..)` 进行柯里化var bar = foo.bind( null, 2 );bar( 3 ); // a:2, b:3 注意：ES6中有一个扩散操作符：...，它让你无需使用apply(..)而在语法上将一个数组“散开”作为参数，比如foo(...[1,2])表示foo(1,2)——如果this绑定没有必要，可以在语法上回避它。不幸的是，柯里化在ES6中没有语法上的替代品，所以bind(..)调用的this参数依然需要注意。 可是，在你不关心this绑定而一直使用null的时候，有些潜在的“危险”。如果你这样处理一些函数调用（比如，不归你管控的第三方包），而且那些函数确实使用了this引用，那么默认绑定规则意味着它可能会不经意间引用（或者改变，更糟糕！）global对象（在浏览器中是window）。 更安全的this也许某些“更安全”的做法是：为了this而传递一个特殊创建好的对象，这个对象保证不会对你的程序产生副作用。从网络学（或军事）上借用一个词，我们可以建立一个“DMZ”（非军事区）对象——只不过是一个完全为空，没有委托的对象。 如果我们为了忽略自己认为不用关心的this绑定，而总是传递一个DMZ对象，那么我们就可以确定任何对this的隐藏或意外的使用将会被限制在这个空对象中，也就是说这个对象将global对象和副作用隔离开来。创建完全为空的对象的最简单方法就是Object.create(null)。Object.create(null)和{}很相似，但是没有指向Object.prototype的委托，所以它比{}“空得更彻底”12345678910111213function foo(a,b) &#123; console.log( "a:" + a + ", b:" + b );&#125;// 我们的 DMZ 空对象var ø = Object.create( null );// 将数组散开作为参数foo.apply( ø, [2, 3] ); // a:2, b:3// 用 `bind(..)` 进行 curryingvar bar = foo.bind( ø, 2 );bar( 3 ); // a:2, b:3 间接引用另外一个要注意的是，你可以（有意或无意地！）创建对函数的“间接引用（indirect reference）”，在那样的情况下，当那个函数引用被调用时，默认绑定规则也会适用。一个最常见的间接引用产生方式是通过赋值：1234567891011function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3//将o.foo函数赋值给p.foo函数，然后立即执行。相当于仅仅是foo()函数的立即执行(p.foo = o.foo)(); // 2 赋值表达式p.foo = o.foo的结果值是一个刚好指向底层函数对象的引用。如此，起作用的调用点就是foo()，而非你期待的p.foo()或o.foo()。根据上面的规则，默认绑定适用。12345678910function foo() &#123; console.log( this.a );&#125;var a = 2;var o = &#123; a: 3, foo: foo &#125;;var p = &#123; a: 4 &#125;;o.foo(); // 3//将o.foo函数赋值给p.foo函数，之后p.foo函数再执行，是属于p对象的foo函数的执行p.foo = o.foo;p.foo();//4 提醒：无论如何得到适用默认绑定的函数调用，被调用函数的内容的strict mode状态——而非函数的调用点——决定了this引用的值：不是global对象（在非strict mode下），就是undefined（在strict mode下）。 软绑定（Softening Binding）硬绑定是一种通过将函数强制绑定到特定的this上，来防止函数调用在不经意间退回到默认绑定的策略（除非你用new去覆盖它！）。问题是，硬绑定极大地降低了函数的灵活性，阻止我们手动使用隐含绑定或后续的明确绑定来覆盖this。如果有这样的办法就好了：为默认绑定提供不同的默认值（不是global或undefined），同时保持函数可以通过隐含绑定或明确绑定技术来手动绑定this。 我们可以构建一个所谓的软绑定工具来模拟我们期望的行为。12345678910111213141516171819if (!Function.prototype.softBind) &#123; Function.prototype.softBind = function(obj) &#123; var fn = this, curried = [].slice.call( arguments, 1 ), bound = function bound() &#123; return fn.apply( (!this || (typeof window !== "undefined" &amp;&amp; this === window) || (typeof global !== "undefined" &amp;&amp; this === global) ) ? obj : this, curried.concat.apply( curried, arguments ) ); &#125;; bound.prototype = Object.create( fn.prototype ); return bound; &#125;;&#125; 这里提供的softBind(..)工具的工作方式和ES5内建的bind(..)工具很相似，除了我们的软绑定行为。它用一种逻辑将指定的函数包装起来，这个逻辑在函数调用时检查this，如果它是global或undefined，就使用预先指定的默认值（obj），否则保持this不变。它也提供了可选的柯里化行为（见先前的bind(..)讨论）。 123456789101112131415161718function foo() &#123; console.log("name: " + this.name);&#125;var obj = &#123; name: "obj" &#125;, obj2 = &#123; name: "obj2" &#125;, obj3 = &#123; name: "obj3" &#125;;var fooOBJ = foo.softBind( obj );fooOBJ(); // name: objobj2.foo = foo.softBind(obj);obj2.foo(); // name: obj2 &lt;---- 看!!!fooOBJ.call( obj3 ); // name: obj3 &lt;---- 看!setTimeout( obj2.foo, 10 ); // name: obj &lt;---- 退回到软绑定 软绑定版本的foo()函数可以如展示的那样被手动this绑定到obj2或obj3，如果默认绑定适用时会退到obj。 this词法–ES6箭头函数箭头函数不是通过function关键字声明的，而是通过所谓的“大箭头”操作符：=&gt;。与使用四种标准的this规则不同的是，箭头函数从封闭它的（函数或全局）作用域采用this绑定。123456789101112131415161718function foo() &#123; // 返回一个箭头函数 return (a) =&gt; &#123; // 这里的 `this` 是词法上从 `foo()` 采用的 console.log( this.a ); &#125;;&#125;var obj1 = &#123; a: 2&#125;;var obj2 = &#123; a: 3&#125;;var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是3! 在foo()中创建的箭头函数在词法上捕获foo()被调用时的this，不管它是什么。因为foo()被this绑定到obj1，bar（被返回的箭头函数的一个引用）也将会被this绑定到obj1。一个箭头函数的词法绑定是不能被覆盖的（就连new也不行！）。 最常见的用法是用于回调，比如事件处理器或计时器：123456789101112function foo() &#123; setTimeout(() =&gt; &#123; // 这里的 `this` 是词法上从 `foo()` 采用 console.log( this.a ); &#125;,100);&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 虽然箭头函数提供除了使用bind(..)外，另外一种在函数上来确保this的方式，这看起来很吸引人，但重要的是要注意它们本质是使用广为人知的词法作用域来禁止了传统的this机制。在ES6之前，我们已经有了相当常用的模式，这些模式几乎和ES6的箭头函数的精神没有区别：123456789101112function foo() &#123; var self = this; // 词法上捕获 `this` setTimeout( function()&#123; console.log( self.a ); &#125;, 100 );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 虽然对不想用bind(..)的人来说self = this和箭头函数都是看起来不错的“解决方案”，但它们实质上逃避了this而非理解和接受它。 如果你发现你在写this风格的代码，但是大多数或全部时候，你都用词法上的self = this或箭头函数“技巧”抵御this机制，那么也许你应该： 仅使用词法作用域并忘掉虚伪的this风格代码。 完全接受this风格机制，包括在必要的时候使用bind(..)，并尝试避开self = this和箭头函数的“词法this”技巧。 一个程序可以有效地同时利用两种风格的代码（词法和this），但是在同一个函数内部，特别是对同种类型的查找，混合这两种机制通常是自找麻烦，而且很难维护。 javascript如此复杂的原因是因为函数过于强大。因为，函数是对象，所以原型链比较复杂；因为函数可以作为值被传递，所以执行环境栈比较复杂；同样地，因为函数具有多种调用方式，所以this的绑定规则也比较复杂。只有理解了函数，才算理解了javascript 五、prototype属性六、变量提升变量提升(Hoisting)被认为是思考执行上下文（特别是创建和执行阶段）在JavaScript中如何工作的一般方式。但变量提升(Hoisting)可能会导致误解。例如，提升教导变量和函数声明被物理移动到编码的顶部，这不算什么。真正发生的什么是在编译阶段将变量和函数声明放入内存中，但仍然保留在编码中键入的位置。1234567891011121314151617181920212223242526/*** 不推荐的方式：先调用函数，再声明函数 */catName(&quot;Chloe&quot;);function catName(name) &#123; console.log(&quot;My cat&apos;s name is &quot; + name);&#125;/*The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;*/// 等价于/*函数声明提升*/function catName(name) &#123; console.log(&quot;My cat&apos;s name is &quot; + name);&#125;catName(&quot;Tigger&quot;);/*The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;*/ 即使我们先在代码中调用函数，在写该函数之前，代码仍然可以工作。 Hoisting 也适用于其他数据类型和变量。变量可以在声明之前进行初始化和使用。但是如果没有初始化，就不能使用。JavaScript 仅提升声明，而不是初始化。如果你使用的是在使用后声明和初始化的一个变量，那么该值将是 undefined。以下两个示例演示了相同的行为。12345678910111213141516var x = 1; // 声明 + 初始化 xconsole.log(x + &quot; &quot; + y); // y 是未定义的var y = 2;// 声明 + 初始化 y//上面的代码和下面的代码是一样的 var x = 1; // 声明 + 初始化 xvar y; //声明 yconsole.log(x + &quot; &quot; + y); //y 是未定义的y = 2; // 初始化 y ES6 : let 不存在 Hoisting 七、检测类型 检测基本数据类型：typeof 123456var str = &apos;zxlg&apos;; console.log(typeof str); // stringvar num = 9; console.log(typeof num);// numbervar bool = true; console.log(typeof bool);// booleanvar u; console.log(typeof u);// undefinedvar nul = null; console.log(typeof nul);// objectvar obj = new Object(); console.log(typeof obj);// object 检测引用类型：instanceoftypeof检测所有引用类型均为object，想得到何种引用类型可使用instanceof (2017.8.7新增)检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false,因为基本类型都不是对象。 123456var arr = [1,2,3];console.log(arr instanceof Object); // trueconsole.log(arr instanceof Array); // truevar reg = /\d+/;console.log(arr instanceof Array); // falseconsole.log(arr instanceof RegExp); // true 参考文献 MDN变量提升 Javascript高级程序设计(第3版) Javascript的this用法 《你不懂JS: this 与对象原型》 第二章: this 豁然开朗！ 深入理解this机制系列第一篇——this的4种绑定规则]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>this对象</tag>
        <tag>js作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP/HTTPS协议总结]]></title>
    <url>%2F2017%2F08%2F05%2Fhttp%2F</url>
    <content type="text"><![CDATA[2017-09-23更新 添加HTTP状态码,HTTPS HTTPHTTP协议在TCP/IP协议栈的位置如下图所示：由于HTTP报文是面向文本的，因此报文中的每一个字段都是一些ASCII码串，但各个字段的长度是不确定的。 请求报文格式如上图所示：请求报文分为四个部分： 请求行：包含请求方法，URL和HTTP版本号，中间用空格分隔； 请求头： 首部字段名： + 空格 + value； 空行：请求头之后必须有空行； 请求数据：POST请求数据，格式为key:value形式。GET不行，它的数据放在URL中； 响应报文格式如上图所示：响应报文分为四个部分： 响应行：包含HTTP版本，状态码和短语，中间用空格分隔； 响应头： 首部字段名： + 空格 + value； 空行：响应头之后必须有空行； 实体主体：响应数据，HTML文本，图片等二进制数据 POST和GET区别引用：HTTP请求中POST和GET请求的区别？ 首先引入一个副作用的概念，副作用指当你发送完一个请求以后，网站上的资源状态没有发生修改，即认为这个请求是无副作用的。比如注册用户这个请求是有副作用的，获取用户详情可以认为是无副作用的。再引入一个幂等性的概念，幂等是说，一个请求原封不动的发送N次和M次（N不等于M，N和M都大于1）服务器上资源的状态最终是一致的。比如发贴是非幂等的，重放10次发贴请求会创建10个帖子。但修改帖子内容是幂等的，一个修改请求重放无论多少次，帖子最终状态都是一致的。唠叨了这么多，回过头来，何时用 PUT POST GET DELETE：GET：无副作用，幂等PUT：副作用，幂等POST：副作用，非幂等DELETE：副作用，幂等为了进一步区分这些请求方式的应用场景，我们再引入一个技术特性，request body，就是大家广为流传的 “POST 请求传输数据量比较大“ 这一说法的来源。POST/PUT 请求可以通过传递 request body 来发送大量的数据，而 GET/DELETE 不能。 请求动作 有无副作用 是否幂等 数据发送方式 GET 无副作用 幂等 不可带 Request Body PUT 副作用 幂等 可以带 Request Body POST 副作用 非幂等 可以带 Request Body DELETE 副作用 幂等 不可带 Request Body 区别： GET参数通过URL传递，POST参数放在Request body中。 GET在浏览器回退时是无害的，而POST会再次提交请求。 GET请求会被浏览器主动缓存，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求在URL中传送的参数是有长度限制的，而POST没有。限制主要来自浏览器和服务器，各个标准不同。IE为2083个字符。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET在浏览器回退时是无害的，而POST会再次提交请求。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。(相对安全) HTTP首部参见我的博客HTTP首部字段解析 HTTP状态码1xx消息这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。 状态码 英文名称 中文名称 说明 1xx 临时响应 表示临时响应并需要请求者继续执行操作的状态代码。 100 Continue 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。 101 Switching Protocols 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换。 2xx成功这一类型的状态码，代表请求已成功被服务器接收、理解、并接受 状态码 英文名称 中文名称 说明 2xx 成功 表示成功处理了请求的状态代码。 200 OK 成功 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 Created 已创建 请求成功并且服务器创建了新的资源。 202 Accepted 已接受 服务器已接受请求，但尚未处理。 203 Non-Authoritative Information 非授权信息 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 No Content 无内容 服务器成功处理了请求，但没有返回任何内容。 205 Reset Content 重置内容 服务器成功处理了请求，但没有返回任何内容。 206 Partial Content 部分内容 服务器成功处理了部分 GET 请求。 3xx重定向这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。 状态码 英文名称 中文名称 说明 3xx 重定向 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。代码 说明 300 Multiple Choices 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者选择一项操作，或提供操作列表供请求者选择。 301 Moved Permanently 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。 302 Found(原始描述短语为“Moved Temporarily”) 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 See Other 查看其他位置 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 304 Not Modified 未修改 自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 305 Use Proxy 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理。 307 Temporary Redirect 临时重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 4xx客户端错误这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。 状态码 英文名称 中文名称 说明 4xx 请求错误 这些状态代码表示请求可能出错，妨碍了服务器的处理。 400 Bad Request 错误请求 服务器不理解请求的语法。 401 Unauthorized 未授权 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 Forbidden 禁止 服务器拒绝请求。 404 Not Found 未找到 服务器找不到请求的网页。 405 Method Not Allowed 方法禁用 禁用请求中指定的方法。 406 Not Acceptable 不接受 无法使用请求的内容特性响应请求的网页。 407 Proxy Authentication Required 需要代理授权 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 Request Timeout 请求超时 服务器等候请求时发生超时。 409 Conflict 冲突 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 Gone 已删除 如果请求的资源已永久删除，服务器就会返回此响应。 411 Length Required 需要有效长度 服务器不接受不含有效内容长度标头字段的请求。 412 Precondition Failed 未满足前提条件 服务器未满足请求者在请求中设置的其中一个前提条件。 413 Request Entity Too Large 请求实体过大 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 Request-URI Too Long 请求的 URI 过长 请求的 URI（通常为网址）过长，服务器无法处理。 415 Unsupported Media Type 不支持的媒体类型 请求的格式不受请求页面的支持。 416 Requested Range Not Satisfiable 请求范围不符合要求 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 Expectation Failed 未满足期望值 服务器未满足”期望”请求标头字段的要求。 5xx服务器错误表示服务器无法完成明显有效的请求。这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。这些状态码适用于任何响应方法。 状态码 英文名称 中文名称 说明 5xx 服务器错误 这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。 500 Internal Server Error 服务器内部错误 服务器遇到错误，无法完成请求。 501 Not Implemented 尚未实施 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 Bad Gateway 错误网关 服务器作为网关或代理，从上游服务器收到无效响应。 503 Service Unavailable 服务不可用 服务器目前无法使用（由于超载或停机维护），通常这只是暂时状态。 504 Gateway Timeout 网关超时 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 HTTP Version Not Supported HTTP 版本不受支持 服务器不支持请求中所用的 HTTP 协议版本。 HTTPSHTTPS协议在HTTP协议基础之上添加了SSL(Secure Sockets Layer)/TLS(Transport Layer Security)层。不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。 窃听风险（eavesdropping）：第三方可以获知通信内容。 篡改风险（tampering）：第三方可以修改通信内容。 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 SSL/TLS协议是为了解决这三大风险而设计的，希望达到： 所有信息都是加密传播，第三方无法窃听。 具有校验机制，一旦被篡改，通信双方会立刻发现。 配备身份证书，防止身份被冒充。 HTTP协议和HTTPS协议区别 HTTPS协议需要到CA申请证书。 HTTP是超文本传输协议，信息是明文传输；HTTPS 则是具有安全性的SSL加密传输协议。 HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。 HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。 基本运行过程SSL/TLS协议的基本思路是采用公钥加密法，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。但是，这里有两个问题。（1）如何保证公钥不被篡改？解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。（2）公钥加密计算量太大，如何减少耗用的时间？解决方法：每一次会话（session），客户端和服务器端都生成一个”会话密钥”（session key），用它来加密信息。由于”会话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密”会话密钥”本身，这样就减少了加密运算的消耗时间。 因此，SSL/TLS协议的基本过程是这样的： 客户端向服务器端索要并验证公钥。 双方协商生成”会话密钥”。 双方采用”会话密钥”进行加密通信。 上面过程的前两步，又称为”握手阶段”（handshake）。 握手阶段详细过程握手阶段图解： 客户端发出请求（ClientHello）首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步，客户端主要向服务器提供以下信息。 支持的协议版本，比如TLS 1.0版。 一个客户端生成的随机数，稍后用于生成”会话密钥”。 支持的加密方法，比如RSA公钥加密。 支持的压缩方法。 这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。 服务器回应（SeverHello）服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 一个服务器生成的随机数，稍后用于生成”会话密钥”。 确认使用的加密方法，比如RSA公钥加密。 服务器证书。 除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供”客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。 客户端回应客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息。 一个随机数。该随机数用服务器公钥加密，防止被窃听。 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称”Premaster key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把”会话密钥”。至于为什么一定要用三个随机数，来生成”会话密钥”，dog250解释得很好： “不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。对于RSA密钥交换算法来说，”Premaster key”本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。“Premaster”的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么”Premaster secret”就有可能被猜出来，那么仅使用”Premaster secret”作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上”Premaster secret”三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。” 此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。 服务器的最后回应服务器收到客户端的第三个随机数”Premaster key”之后，计算生成本次会话所用的”会话密钥”。然后，向客户端最后发送下面信息。 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用”会话密钥”加密内容。 总结握手阶段 第一步，爱丽丝给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方&gt;法。第二步，鲍勃确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。第三步，爱丽丝确认数字证书有效，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给鲍勃。第四步，鲍勃使用自己的私钥，获取爱丽丝发来的随机数（即Premaster secret）。第五步，爱丽丝和鲍勃根据约定的加密方法，使用前面的三个随机数，生成”会话密钥”（session key），用来加密接下来的整个会话过程。 握手阶段重点 生成会话密钥一共需要三个随机数。 握手之后的会话使用”会话密钥”加密（对称加密），服务器的公钥和私钥只用于加密和解密”会话密钥”（其实是加密、解密生成“会话密钥”的随机数），无其他作用。 服务器公钥放在服务器的数字证书之中。 安全性保证Premaster secret保证会话密钥安全性 整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。第三个随机数是经过公钥加密的，保证了信息的安全。虽然理论上，只要服务器的公钥足够长（比如2048位），那么Premaster secret可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的RSA算法，改为 Diffie-Hellman算法（简称DH算法）。采用DH算法后，Premaster secret不需要传递，双方只要交换各自的参数，就可以算出这个随机数。 参见DH算法的握手阶段 数字证书安全性通过公钥加密的数据，只能通过私钥解开。这个叫非对称加密。通过私钥加密的数据，只能通过公钥解开。这个叫数字签名。 受信任的第三方保护服务器公钥，防止被伪造和篡改。其中使用数字签名和摘要，保证其不被伪造和篡改。 参考文献 HTTP请求中POST和GET请求的区别？ HTTP状态码 你应该知道的HTTP基础知识 HTTP协议解析 SSL/TLS协议运行机制的概述 图解SSL/TLS协议 HTTP首部]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>HTTP</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议总结]]></title>
    <url>%2F2017%2F08%2F05%2Ftcp-ip%2F</url>
    <content type="text"><![CDATA[暂封]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript异步总结]]></title>
    <url>%2F2017%2F08%2F05%2Fjs-async%2F</url>
    <content type="text"><![CDATA[2017-09-12更新 Generator函数从语法上看，可以把它理解成状态机，封装了多种内部状态。执行Generator函数会返回一个遍历器对象，代表Generator函数的内部指针。也就是说Generator除了是状态机还是一个遍历器对象生成器。返回遍历器对象，可以依次遍历Generator函数内部的每一个状态。 特征 function和函数名之间有*号； 函数体内部用yield语句定义不同的内部状态。 调用和普通函数调用一样。但是函数并不执行，必须调用next方法,使得指针移向下一个状态，直到下一个yield语句或return语句。Generator函数是分段执行的，yield语句是暂停执行的标记，next方法会恢复执行。next方法返回对象为{value: value; done: boolean},value为yield语句的值，即内部状态的值，done属性表示遍历是否结束。yield语句不能用在普通函中，否则会报错。yield语句本身没有返回值，或者说为undefined，next方法可以带一个参数，这个参数会被当作上一条yield语句的返回值。但是引擎忽略next方法时的参数，只有第二次使用next方法带参数才是有效的。从语义上讲，第一次next方法用来启动遍历器对象。for……of自动遍历Generator函数，无需使用next方法。 方法Generator.prototype.return() 返回给定的值，并终结Generator函数的遍历 yield* 方法在一个Generator函数中调用另一个Generator函数，默认是没有效果的。而yield*语句可以用来在一个Generator函数中调用另一个Generator函数]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Ajax操作总结]]></title>
    <url>%2F2017%2F08%2F05%2Fajax%2F</url>
    <content type="text"><![CDATA[2017-09-21更新 Jquery实现Ajax123456789101112131415//测试Jquery的Ajax请求var testAjax = $('#test-ajax');testAjax.click(function (event) &#123; $.ajax(&#123; method: 'POST', url: '/about', cache: false, success: function (res) &#123; alert('使用jquery发送ajax请求成功，返回为：' + res); &#125;, error: function (res) &#123; alert('ajax出错'); &#125; &#125;);&#125;); 原生Javascript实现Ajaxxhr对象创建首先检测原生XHR对象是否存在，如果存在则返回它的新实例。如果原生对象不存在，则检测ActiveX对象。如果这两种对象都不存在，就抛出一个错误。12//IE5、IE6使用ActiveXObject建立xhr对象var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 12345678910111213141516171819function createXHR()&#123; if(typeof XMLHttpRequest != 'undefined')&#123; return new XMLHttpRequest(); &#125;else if(typeof argument.callee.activeXString != 'string')&#123; var versions = ['MXSML2.XMLHTTP','MXSML2.XMLHttp.3.0','MXSML2.XMLHttp.6.0']; var i len; for(i = 0;len=versions.length;i&lt;len;i++)&#123; try&#123; new ActiveXObject(versions[i]); argument.callee.activeXString = versions[i]; &#125;catch&#123; &lt;!-- 跳过 --&gt; &#125; &#125; return new ActiveXObject(argument.callee.activeXString); &#125;else&#123; throw new Error("没有XHR对象存在"); &#125;&#125; xhr用法先上代码：12345678910111213var xhr = new XMLHttpRequest();xhr.onreadystatechange = function()&#123; if(this.readyState == 4)&#123; if((this.status &gt;= 200 &amp;&amp; this.status &lt; 300) || this.status == 304)&#123; //处理response &#125;else&#123; //处理error &#125; &#125;&#125;xhr.open('get','/xhr',true);xhr.send(); 发送数据在使用XHR对象时，要调用的第一个方法是open()，open(get/post,url,false/true)它接受3个参数： 请求类型:最常用的就是get和post 请求路径：就是要请求的操作的文件的url 是否异步发送的布尔值 xhr.open(&#39;get&#39;,&#39;/xhr&#39;,true);,url相对于执行代码的当前页面（当然也可以使用绝对路径）,调用open()方法并不会真正发送请求，而只是启动一个请求以备发送 要发送特定的请求,必须调用send()方法: xhr.send();，send()方法接收一个参数，即要作为请求主体发送的数据。 异步处理发送异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下： 0：未初始化。尚未调用open()方法。 1：启动。已经调用open()方法，但尚未调用send()方法。 2：发送。已经调用send()方法，但尚未接收到响应。 3：接收。已经接收到部分响应数据。 4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。 只要readyState属性的值由一个值变成另一个值，都会触发一次readystatechange事件。可以利用这个事件来检测每次状态变化后readyState的值。通常我们只对readyState值为4的阶段感兴趣，因为这时所有数据都已经就绪。但必须在调用open()之前指定onreadystatechange事件处理程序才能确保跨浏览器兼容性。 在接收到响应之前还可以调用abort()方法来取消异步请求,xhr.abort(); 响应处理在收到响应后，响应的数据会自动填充XHR对象的属性，相关的属性如下：responseText：作为响应主体被返回的文本。responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含着响应数据的XML DOM文档。status：响应的HTTP状态。statusText：HTTP状态的说明 XMLHttpRequest 2级XMLHttpRequest2级使用方法，无需检查readyState状态1234567891011//XMLHttpRequest2级使用方法 无需检查readyState状态var xhr = new XMLHttpRequest();xhr.onload = function()&#123; if((this.status &gt;= 200 &amp;&amp; this.status &lt; 300) || this.status == 304&gt;)&#123; //处理response &#125;else&#123; //处理error &#125;&#125;xhr.open('get','/xhr',true);xhr.send();]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ajax</tag>
        <tag>XMLHttpRequest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《影响力》读书笔记]]></title>
    <url>%2F2017%2F08%2F05%2Feffect%2F</url>
    <content type="text"><![CDATA[于2017.7.1读完，于2017.8.5建立读书笔记暂封]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《自控力》读书笔记]]></title>
    <url>%2F2017%2F08%2F05%2Fself-control%2F</url>
    <content type="text"><![CDATA[于2017.7.22读完，于2017.8.5建读书笔记暂封 更新]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown技巧]]></title>
    <url>%2F2017%2F08%2F04%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[代码代码区块 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以 第二种，在代码段落的头部和尾部用```包围起来 行内代码块用` `包围 链接文字链接1[链接名称](http://链接网址) 网址链接1&lt;http://链接网址&gt; 图片行内式1![alt图片名称](http://图片网址) 设置图片居中1234&lt;div align='center'&gt;![alt图片名称](http://图片网址)&lt;p&gt;图片名&lt;/p&gt;&lt;/div&gt; 参考式1![alt图片名称][本地图片地址] 目前为止Markdown 还没有办法指定图片的宽高，如果需要，可以使用普通的&lt;img&gt;标签。 表格单元格和表头使用|来分隔不同的单元格，使用-来分隔表头和其他行 1234name | age---- | ---LearnShare | 12Mike | 32 name age LearnShare 12 Mike 32 对齐在表头下方的分隔线标记中加入:，即可标记下方单元格内容的对齐方式： :---代表左对齐:--:代表居中对齐---:代表右对齐 1234| left | center | right || :--- | :----: | ----: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 内嵌HTML不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了。 注意 HTML 区块元素，比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt;标签。 公式如果想要在Markdown文档中显示一个公式就需要先插入下面一句话，这实际上是插入了一个图片。 1![公式名](http://latex.codecogs.com/png.latex?这里输入您的公式) 上面这句话是插入一个png图片格式的公式，而下面这句话则是插入gif图片格式的公式。 1![公式名](http://latex.codecogs.com/png.latex?这里输入您的公式) 引用Markdown 标记区块引用是使用类似 email 中用&gt;的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt;&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上&gt;： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的&gt;： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt;&gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt; return shell_exec("echo $input | $markdown_script"); 转义Markdown符号用反斜杠\转义 横线在一行中用三个以上的星号(*)、减号(-)、下划线(_)来建立一个分隔线；除空格外行内不能有其他字符；（除第一个符号的左侧最多添加三个空格外）三个相同符号两侧可以添加任意多个空格。 参考文献 Markdown教程 Markdown 编辑器语法指南 Markdown 语法说明 (简体中文版) / (点击查看快速入门)]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript相等性比较]]></title>
    <url>%2F2017%2F08%2F04%2Fjs-equal%2F</url>
    <content type="text"><![CDATA[JavaScript有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 &lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。字符串比较则是使用基于标准字典的Unicode值来进行比较的, 数组也是这样比较的。 一、宽松相等(==)比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。 类型相同的，执行===比较 null == undefiend // true(特殊定义的)，undefiend与null与其他对象与基础类型的值均不相等; A与数字B比较时，将A转换为数字ToNumber，若A为对象先转为原始值ToPrimitive再转为数字ToNumber; A与布尔类型B比较，将A和B转换为数字ToNumber，若A为对象先转为原始值ToPrimitive再转为数字ToNumber; A与字符串B比较，若A为数字和布尔类型，则将A和B转换为数字，若A为对象先转为原始值ToPrimitive，之后不转数字了; ToNumberToNumber(A) 尝试在比较前将参数A转换为数字，这与+A（单目运算符+）的效果相同。 ToPrimitiveToPrimitive(A)通过尝试依次调用A的A.toString()参见Object.prototype.toString()和A.valueOf()参见Object.prototype.valueOf()方法，将参数A转换为原始值（Primitive）。 其中，A.toString()返回 “[object type]”, A.valueOf()返回原始值。Javascript隐式装箱也是用ToPrimitive(),在Javascript只有字符串和数字才能相加。参见What is {} + {} in JavaScript? 二、一致/严格相等(===)一致运算符不会进行类型转换，仅当操作数严格相等时返回true 123456789101112131415var num = 0;var obj = new String("0");var str = "0";var b = false;console.log(num === num); // trueconsole.log(obj === obj); // trueconsole.log(str === str); // trueconsole.log(num === obj); // falseconsole.log(num === str); // falseconsole.log(obj === str); // falseconsole.log(null === undefined); // falseconsole.log(obj === null); // falseconsole.log(obj === undefined); // false 对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：第一个情况是，浮点数0是不分正负的。区分+0和-0在解决一些特定的数学问题时是必要的，但是大部分境况下我们并不用关心。全等操作符认为这两个值是全等的。第二个情况是，浮点数包含了NaN值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为NaN与其他任何值都不全等，包括它自己。（等式 (x !== x) 成立的唯一情况是 x 的值为NaN） 三、Object.is （ECMAScript 2015/ ES6 新特性）Object.is的行为方式与三等式相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同，而Object.is（NaN，NaN）将为true。(通常使用双等号或三等于将NaN与NaN进行比较结果为false，因为IEEE 754如是说。)除了+0和-0,其他时候避免使用Object.is,包括NaN。 四、判等表 x y == === Object.is undefined undefined true true true null null true true true true true true true true false false true true true “foo” “foo” true true true { foo: “bar” } x true true true 0 0 true true true +0 -0 true true false 0 false true false false “” false true false false “” 0 true false false “0” 0 true false false “17” 17 true false false [1,2] “1,2” true false false new String(“foo”) “foo” true false false null undefined true false false null false false false false undefined false false false false { foo: “bar” } { foo: “bar” } false false false new String(“foo”) new String(“foo”) false false false 0 null false false false 0 NaN false false false “foo” NaN false false false NaN NaN false false true 1234567891011121314// true 两个操作数均为String'foo' === 'foo'var a = new String('foo');var b = new String('foo');// false a,b对象引用不同a == b// false a,b均为对象，但是引用不同a === b// true 操作数类型不同，对象a转换为String类型a == 'foo' 五、参见==比较表 if()比较表(2017.8.6新增) Javascript比较表 参考文献 MDN比较运算符 MDN相等性比较 ECMAScript官方文件 js比较表 ECMAScript ToPrimitive object原始值 What is {} + {} in JavaScript?]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的Array对象总结]]></title>
    <url>%2F2017%2F08%2F03%2Fjs-Array%2F</url>
    <content type="text"><![CDATA[一、属性Array.lengthlength属性的值是一个 0 到 2^32-1的整数。 你可以通过减小length属性的值来截短一个数组，但不能通过增大length属性的值来延长这个数组 Array.prototypeArray.prototype属性表示Array构造函数的原型;Array.prototype本身也是一个Array 二、方法Array.prototype.concat()不改变数组 语法var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]) 参数valueN需要与原数组合并的数组或非数组值。详见下文。 返回值新的Array实例。 描述concat方法将创建一个新的数组，然后将调用它的对象(this指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat方法并不修改调用它的对象(this指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的String和Number对象):concat方法会复制字符串和数字的值放到新数组里 Array.prototype.filter()语法var new_array = arr.filter(callback[, thisArg]) 参数callback用来测试数组的每个元素的函数。调用时使用参数(element, index, array)。返回true表示保留该元素（通过测试），false则不保留。thisArg可选。执行callback时的用于this的值。 返回值一个新的通过测试的元素的集合的数组 描述filter为数组中的每个元素调用一次callback函数，并利用所有使得callback返回true或等价于true的值的元素创建一个新数组。callback只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过callback测试的元素会被跳过，不会被包含在新数组中。callback被调用时传入三个参数： 元素的值 元素的索引 被遍历的数组 如果为filter提供一个thisArg参数，则它会被作为callback被调用时的this值。否则，callback的this值在非严格模式下将是全局对象，严格模式下为undefined。 filter不会改变原数组。filter遍历的元素范围在第一次调用callback之前就已经确定了。在调用filter之后被添加到数组中的元素不会被filter遍历到。如果已经存在的元素被改变了，则他们传入callback的值是filter遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。 Array.prototype.find()Array.prototype.forEach()语法1234array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 参数callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue(当前值)数组中正在处理的当前元素。 index(索引)数组中正在处理的当前元素的索引。 array`forEach()`方法正在操作的数组。 thisArg可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined 描述forEach方法按升序为数组中含有效值的每一项执行一次callback函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为undefined的项）（例如在稀疏数组上）。callback函数会被依次传入三个参数： 数组当前项的值 数组当前项的索引 数组对象本身 如果给forEach传递了thisArg参数，当调用时，它将被传给callback函数，作为它的this值。否则，将会传入undefined作为它的this值。callback函数最终可观察到this值，这取决于函数观察到this的常用规则。forEach遍历的范围在第一次调用callback前就会确定。调用forEach后添加到数组中的项不会被callback访问到。如果已经存在的值被改变，则传递给callback的值是forEach遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用shift()) ，之后的元素将被跳过.forEach()为每个数组元素执行callback函数；不像map()或者reduce() ，它总是返回undefined值，并且不可链式调用。典型用例是在一个链的最后执行副作用。 Array.prototype.indexOf()indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法12arr.indexOf(searchElement)arr.indexOf(searchElement[, fromIndex = 0]) 参数searchElement要查找的元素。fromIndex开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找，以此类推。注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. 返回值首个被找到的元素在数组中的索引位置;若没有找到则返回-1 Array.prototype.join()不改变数组 Array.prototype.keys()Array.prototype.values()Array.prototype.entries()Array.prototype.pop()Array.prototype.push()Array.prototype.shift()Array.prototype.unshift()Array.prototype.map()语法123let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array &#125;[, thisArg]) 参数callback生成新数组元素的函数，使用三个参数：currentValue`callback的第一个参数，数组中正在处理的当前元素。indexcallback`的第二个参数，数组中正在处理的当前元素的索引。 `arraycallback的第三个参数，map方法被调用的数组。thisArg可选的。执行callback函数时,使用的this`值。 返回值一个新数组，每个元素都是回调函数的结果。 描述map方法会给原数组中的每个元素都按顺序调用一次callback函数。callback每次执行后的返回值（包括undefined）组合起来形成一个新数组。callback函数只会在有值的索引上被调用；那些从来没被赋过值或者使用delete删除的索引则不会被调用。callback函数会被自动传入三个参数：数组元素，元素索引，原数组本身。如果thisArg参数有值，则每次callback函数被调用的时候，this都会指向thisArg参数上的这个对象。如果省略了thisArg参数,或者赋值为null或undefined，则this指向全局对象。map不修改调用它的原数组本身（当然可以在callback执行时改变原数组）。使用map方法处理数组时，数组元素的范围是在callback方法第一次调用之前就已经确定了。在map方法执行的过程中：原数组中新增加的元素将不会被callback访问到；若已经存在的元素被改变或删除了，则它们的传递到callback的值是map方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。 Array.prototype.reduce()语法array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue) 参数callback执行数组中每个值的函数，包含四个参数accumulator上一次调用回调返回的值，或者是提供的初始值initialValuecurrentValue数组中正在处理的元素currentIndex数据中正在处理的元素索引,如果提供了initialValue,从0开始;否则从1开始array调用reduce的数组initialValue可选项，其值用于第一次调用callback的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。空数组调用reduce时没有设置初始值将会报错。 返回值函数累计处理的结果 描述reduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：accumulator初始值（或者上一次回调函数的返回值）currentValue当前元素值currentIndex当前索引array调用reduce的数组。回调函数第一次执行时，accumulator和currentValue的取值有两种情况：调用reduce时提供initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；没有提供initialValue，accumulator取数组中的第一个值，currentValue取数组中的第二个值。注意: 不提供initialValue，reduce会从索引1的地方开始执行callback方法，跳过第一个索引。提供initialValue，从索引0开始。 如果数组为空并且没有提供initialValue，会抛出TypeError。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue，或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 Array.prototype.reduceRight()Array.prototype.sort()改变数组 Array.prototype.reverse()改变数组 Array.prototype.slice()注意:’slice()’为浅拷贝,不改变数组 语法arr.slice(begin,end) 参数begin可选，从索引处开始提取，默认为0。如果参数为负数-a，从倒数第a个元素开始提取。slice(-2)表示从倒数第二提取到倒数第一(包含最后一个元素)。end可选，从索引处结束提取。slice(begin,end)包含begin但不包含end。如果为负数表示在倒数第几个结束提取，slice(-2,-1),不包含最后一个。end省略或大于数组长度，一直提取到原数组末尾 返回值一个含有提取元素的新数组 描述slice()不会修改数组，只会浅拷贝，规则如下： 对象引用(非对象直接量):concat方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 对于字符串、数字及布尔值来说（不是String、Number或者Boolean对象），slice会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。 Array.prototype.splice()改变数组，返回被删除元素组成的数组 参考文献 MDN]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中String对象总结]]></title>
    <url>%2F2017%2F08%2F03%2Fjs-String%2F</url>
    <content type="text"><![CDATA[2017.08.20更新 String.prototype.match()语法1str.match(regexp); 参数regexp一个正则表达式对象。如果传入一个非正则表达式对象，则会隐式地使用new RegExp(obj)将其转换为一个RegExp。如果你未提供任何参数，直接使用match()，那么你会得到一个包含空字符串的Array ：[&quot;&quot;]。 返回值array一个包含了整个匹配结果以及任何括号捕获的匹配结果的Array；如果没有匹配项，则返回null。 描述如果正则表达式没有g标志，则str.match()会返回和RegExp.exec()相同的结果。而且返回的Array拥有一个额外的input性，该属性包含被解析的原始字符串。另外，还拥有一个index属性，该属性表示匹配结果在原字符串中的索引（以0开始）。如果正则表达式包含g标志，则该方法返回一个Array，它包含所有匹配的子字符串而不是匹配对象。捕获组不会被返回(即不返回index属性和input属性)。如果没有匹配到，则返回null。 注意如果你需要知道一个字符串是否匹配一个正则表达式RegExp，可使用search()。如果你只是需要第一个匹配结果，你可能想要使用RegExp.exec()。如果你想要获得捕获组，并且设置了全局标志，你需要用RegExp.exec()。 String.prototype.replace()语法1str.replace(regexp|substr,newSubstr|function) 参数regexp (pattern)一个 正则表达式对象或者其字面量。该正则所匹配的内容会被第二个参数的返回值替换掉。substr (pattern)一个要被newSubStr替换的字符串。其被视为一整个字符串，而不是一个正则表达式。仅仅是第一个匹配会被替换。newSubStr(replacement)用于替换掉第一个参数在原字符串中的匹配部分的 字符串。该字符串中可以内插一些特殊的变量名。参考下面的使用字符串作为参数。function(replacement)一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考下面的指定一个函数作为参数。在这种情况下，当匹配执行后， 该函数就会执行。 函数的返回值作为替换字符串。 (注意: 上面提到的特殊替换参数在这里不能被使用。) 另外要注意的是， 如果第一个参数是正则表达式， 并且其为全局匹配模式， 那么这个方法将被多次调用， 每次匹配都会被调用。 function参数match匹配的子串。(对应于上述的$&amp;。)p1,p2, ...假如replace()方法的第一个参数是一个RegExp 对象，则代表第n个括号匹配的字符串。（对应于上述的$1，$2等。）offset匹配到的子字符串在原字符串中的偏移量。（比如，如果原字符串是“abcd”，匹配到的子字符串是“bc”，那么这个参数将是1）string被匹配的原字符串。12345function replacer(match, p1, p2, p3, offset, string) &#123; // p1 is nondigits, p2 digits, and p3 non-alphanumerics return [p1, p2, p3].join(&apos; - &apos;);&#125;var newString = &apos;abc12345#$*%&apos;.replace(/([^\d]*)(\d*)([^\w]*)/, replacer);//&apos;abc - 12345 - #$*%&apos; 返回值一个部分或全部匹配由替代模式所取代的新的字符串。 参考文献 MDN-String]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript定时器总结]]></title>
    <url>%2F2017%2F08%2F03%2Fjs-timing%2F</url>
    <content type="text"><![CDATA[setTimeoutsetInterval]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址学习总结]]></title>
    <url>%2F2017%2F02%2F22%2FIP%2F</url>
    <content type="text"><![CDATA[IP地址A级：1.0.0.0 - 126.255.255.255B级：128.0.0.0 - 191.255.255.255C级：192.0.0.0 - 223.255.255.255。 保留地址保留地址是有特殊用途的A类：127.X.X.X 用做循环测试B类：169.254.X.X 如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，就会得到其中一个IP 私有地址私有地址就是在互联网上不使用，而被用在局域网络中的地址A类：10.X.X.X是私有地址B类：172.16.0.0 - 172.31.255.255c类：192.168.X.X是私有地址。（192.168.0.0 - 192.168.255.255)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chmod命令用法]]></title>
    <url>%2F2016%2F12%2F20%2Fchmod%2F</url>
    <content type="text"><![CDATA[chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls-l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：命令：ls -al输出：12345678[root@localhost test]# ll -al总计 316lrwxrwxrwx 1 root root 11 11-22 06:58 linklog.log -&gt; log2012.log-rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log-rw-r--r-- 1 root root 61 11-13 06:03 log2013.log-rw-r--r-- 1 root root 0 11-13 06:03 log2014.log-rw-r--r-- 1 root root 0 11-13 06:06 log2015.log-rw-r--r-- 1 root root 0 11-16 14:41 log2016.log-rw-r--r-- 1 root root 0 11-16 14:43 log2017.log 我们以log2012.log为例：-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。例如：- rw- r-- r-- 表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。 确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。 chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。chmod命令详细情况如下: 1. 命令格式chmod [-cfvR] [--help] [--version] mode file 2. 命令功能用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。 3. 命令参数必要参数：-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数：–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限–version 显示版本信息&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限代号：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示– ：删除权限，用数字0表示s ：特殊权限该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 1）. 文字设定法：chmod ［who］ ［+ | - | =］ ［mode］ 文件名 2）. 数字设定法 我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。 例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。 数字设定法的一般形式为：chmod ［mode］ 文件名数字与字符对应关系如下：r=4，w=2，x=1若要rwx属性则4+2+1=7若要rw-属性则4+2=6；若要r-x属性则4+1=7。 4. 使用实例实例1：增加文件所有用户组可执行权限命令：chmod a+x log2012.log输出：123456[root@localhost test]# ls -al log2012.log -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod a+x log2012.log [root@localhost test]# ls -al log2012.log -rwxr-xr-x 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# 说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。 实例2：同时修改不同用户权限命令：chmod ug+w,o-x log2012.log输出：12345[root@localhost test]# ls -al log2012.log -rwxr-xr-x 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod ug+w,o-x log2012.log [root@localhost test]# ls -al log2012.log -rwxrwxr-- 1 root root 302108 11-13 06:03 log2012.log 说明：即设定文件text的属性为：文件属主（u） 增加写权限;与文件属主同组用户（g） 增加写权限;其他用户（o） 删除执行权限 实例3：删除文件权限命令：chmod a-x log2012.log输出：12345[root@localhost test]# ls -al log2012.log -rwxrwxr-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod a-x log2012.log [root@localhost test]# ls -al log2012.log -rw-rw-r-- 1 root root 302108 11-13 06:03 log2012.log 说明：删除所有用户的可执行权限 实例4：使用“=”设置权限命令：chmod u=x log2012.log输出：12345[root@localhost test]# ls -al log2012.log -rw-rw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod u=x log2012.log [root@localhost test]# ls -al log2012.log ---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log 说明：撤销原来所有的权限，然后使拥有者具有可读权限 实例5：对一个目录及其子目录所有文件添加权限命令：chmod -R u+x test4输出：1234567891011121314151617[root@localhost test]# cd test4[root@localhost test4]# ls -al总计 312drwxrwxr-x 2 root root 4096 11-13 05:50 .drwxr-xr-x 5 root root 4096 11-22 06:58 ..-rw-r--r-- 1 root root 302108 11-12 22:54 log2012.log-rw-r--r-- 1 root root 61 11-12 22:54 log2013.log-rw-r--r-- 1 root root 0 11-12 22:54 log2014.log[root@localhost test4]# cd ..[root@localhost test]# chmod -R u+x test4[root@localhost test]# cd test4[root@localhost test4]# ls -al总计 312drwxrwxr-x 2 root root 4096 11-13 05:50 .drwxr-xr-x 5 root root 4096 11-22 06:58 ..-rwxr--r-- 1 root root 302108 11-12 22:54 log2012.log-rwxr--r-- 1 root root 61 11-12 22:54 log2013.log-rwxr--r-- 1 root root 0 11-12 22:54 log2014.log` 说明：递归地给test4目录下所有文件和子目录的属主分配权限 其他一些实例1）. 命令：chmod 751 file说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限2）. 命令：chmod u=rwx,g=rx,o=x file说明：上例的另一种形式3）. 命令: chmod =r file说明：为所有用户分配读权限3）. 命令：chmod 444 file说明：同上例4）. 命令：chmod a-wx,a+r file说明：同上例]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学易悟道]]></title>
    <url>%2F2016%2F11%2F05%2Fyixue%2F</url>
    <content type="text"><![CDATA[一、学易最近研究易学、命理学，对老祖宗的文化更加敬仰、自豪和欣慰，也难怪四大文明古国，只有中国还一直传承了下来，并且传承了几千年了。老祖宗的智慧请不要随意否定和抨击。知乎上看到一段话觉得很有道理，在这里来引用： 我两年前看《佛兰西斯·培根传》的读书笔记，那个是印象深刻的感悟:实践出真知，一件事如果你不清楚或者没有接触过，最好不要对它做出评论评价。一个问题如果真的有兴趣，那么就应该实践一下，别人的答案可以收录参考，如果自己用心去感受的东西还没出来，那么对这个问题就应该说“不清楚”或者不说。学了过才知道原来不是八个字就可以把人生都算完的，要大运流年共十二个字。学过才知道八字是算人生大体走势的，不是万能的，很少人能精准到日或者时辰的。学过了才知道，专注做好一件事的重要性。学过了才知道，性格对人生的影响真的很大，可以告诉各位，改变性格也是改变命运的一个手段，至于性格那种好那种坏，请君斟酌。学过了才深深明白“积善之家，必有余庆。积不善之家，必余秧。”的道理。也是学了才让我继续坚持“塞翁失马焉知非福”的心态。《易经》象数理，我们学易术是为了跳过表象，用术数去明理。佛教说人有八万四千烦恼，也有八万四千法门可以成佛。各种术数也是其中明理的方法。关于改命：相信各位都很有兴趣，我的答案没什么特别。无非就是大家提倡的“诸恶莫作，众善奉行”。改变自己（性格，体质），多读书，多做善事，改风水等。若是明此理者，可以不算命，若是不明此理者，去算命也是得到这个回复。 作者：noiplee链接：https://www.zhihu.com/question/20773399/answer/16171663来源：知乎著作权归作者所有，转载请联系作者获得授权。 二、增益去害，趋吉避凶总结了自己的优缺点，和借鉴noiplee的各个方面要求自己，并希望引为自省！ 1. 保养身体 规律饮食，起居 锻炼身体 2. 弥补缺陷 提高格局，增强气量。做事前三思，做事时稳重！ 严以律己，宽以待人。积口德，增气量，非原则问题让一让又如何？做人留一线，日后好相见！ 细心，耐心，恒心。 细心，忌眼高手低；耐心，忌心浮气躁；恒心，忌半途而废！ 尊师重道，孝敬父母。 父母是生我养我之人，我是他们生命的延续，所以我也是另一个层次的他们，即爱父母也是爱自己；尊重师长，护持正道，发扬中国优秀传统文化！ 谦虚谨慎，敬畏自然。 切莫恃才傲物，记住聪明反被聪明误！ 我比别人知道得多的，不过是我知道自己无知。—–苏格拉底 3. 行善积德行善积德的10个方法： 助人为乐，与人为善。 敬爱存心。 成人之美。 劝人为善。 救人危急。 兴建大利。 舍财作福。 护持正法。 敬重尊长。 爱惜物命。 4. 多读书好读书，读好书，读书好！]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>易学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖延症再见「转」]]></title>
    <url>%2F2016%2F10%2F23%2Fdalay-bye%2F</url>
    <content type="text"><![CDATA[拖延症你好严格来说，拖延症甚至算不上一种「症」。无论从国际通用的精神疾病诊断与统计手册（ DSM-V ）还是中国的精神疾病诊断手册中都没有拖延症的名字。如果说拖延症是「病」，它可能由很多种不同的疾病引起。如抑郁症、焦虑症、成瘾症等等。拖延症只是表象，并不是问题的本质。 最常见的导致拖延症的原因： 一、诱惑米歇尔教授（做棉花糖实验的心理学家），认为人的大脑存在两个系统：「冷系统」和「热系统」。这两个系统就是长远利益与当前诱惑在我们大脑中交战的战场。「冷系统」的区域在我们的前额，它是理性的、自我控制的，它更高瞻远瞩，能为更长远的利益考虑，它在不停提醒我们「想想未来想想未来」。而「热系统」的区域在海马回和边缘系统附近，它是人脑最先进化出来的部分，和我们的冲动情绪有关。一旦诱惑出现，这个系统就会被激活，它会不停喊「及时行乐及时行乐」，让人变得急躁而短视，按冲动行事。认知神经学有一个「神经营销学」的领域，翻检大脑的每一个薄弱环节，设计制造出更多的、更有效的诱惑。我们身处一个擅长制造诱惑的时代。 二、压力「诱惑」和「压力」都会激发热系统。「诱惑」会让热系统产生趋近的冲动，让我们打开网页，远离工作，而「压力」则会让热系统产生逃避的冲动，让我们直接逃离带来压力的工作。更多时候，压力并不带来动力，反而带来拖延。压力会带来严重的逃避反应，让人没有勇气去面对和解决问题。面对任务时的时间压力有时候会让人产生这样的习得性无助，那种「我再努力也无法赶上时间进度」的感觉。这时候，压力除了制造焦虑，再也不会激起人战斗的欲望了。甚至连焦虑着急的情绪，也会逐渐转入抑郁，并破坏人的社会功能。拖延症的问题，某种意义上，也就是压力管理问题。 三、完美主义完美主义并不是以工作结果或者工作过程来评判的，而是以你对自己的期待来评判的。心理学将完美主义者分为适应良好的完美主义者和适应不良的完美主义者。 1、关于自我的区别①适应良好的完美主义不仅有对自己的高标准、严要求，而且相信自己有与这种要求相匹配的能力。他们的高标准与高的自我意向是相适应的。②适应不良的完美主义在高标准之外，却常有与之不匹配的低自我意向，他们并不相信自己真的能符合完美标准：「如果能做这么好就好了，可惜我肯定做不到」。所以高标准只会增加他们的挫败感，提醒他们自己的不完美，而他们偏偏又很难忍受自己的这种不完美。（不适应的完美主义者背后，常常有一个严厉得不近人情的父母。这些父母经常以批评代替鼓励，不断提醒他们各种缺陷和不足而非表扬他们有了进步。这种苛刻的态度会逐渐内化为他们的自我要求。） 2、关于失败的区别①适应良好的完美主义虽然同样讨厌失败，但他们会把失败看作成功路上必然的经历，看作成长和学习的机会。②适应不良的完美主义者却把一个人的能力看作固定的东西，而他们所面对的每个任务，都是对自己能力的证明和考验。把每个任务当作威胁而不是成长的机会。而失败也总会给他们带来很大的挫折感。 适应不良的完美主义者更容易拖延，原因：①在完美的标准下，他们会一直纠结每个不完美的开端，并把它们视作失败。②会把失败的意义无限扩大，并因此更害怕失败。所以有时候，他们宁愿在自我批评中拖延，也不愿去面对费力挣扎却仍然失败的风险。 四、控制和反抗控制感是人的基本需要。人都希望自己能为自己做主。可是在社会分工和组织序列中，深处底层的人们不得不听从老板或客户的指挥。因此拖延成了组织中的弱者表达不满的反抗工具。 五、对未来的错估拖延症患者经常面对着这样一个问题：该把工作放到现在还是留给未来。如心理距离理论所说，人们会用更抽象的视角来看待未来的任务和他们自己。人们会低估未来任务的难度。人们会忽略未来任务中很多恼人的细节，因此，未来的任务会比现在看起来更简单纯粹。人们还会高估未来自己的能力和专注度，同时高估未来可用的时间资源。这些对未来的系统性看法并不是拖延症患者才有，普通人也有，只是拖延症患者会更严重。 六、缺爱拖延症的患者经常陷入巨大的空虚当中。他们经常怀疑自己所做的事情的意义，甚至怀疑自己的整个人生的意义。所以他们需要到网游、酒精、当下肤浅的感官刺激中去寻找存在感。意义的本质是联结。它既可能是我们与他人的联结，也可能是我们与未来的联结。拖延症患者常常缺少这种因爱产生的意义感。他们是孤立的，并不觉得自己有人在乎，也不真的在乎别人。因此，当面临一个任务时，他们对拖延可能造成的对未来自己、对他人的影响漠不关心。但这种孤立和冷漠的感觉让人很难忍受，需要通过做其他刺激感官的事情来确认自己的存在感，于是，他们很容易变成其他方面的成瘾患者。 拖延症再见原则一：发挥梦想的力量要在拖延症中重拾梦想，我们应该仔细审视以下问题： 从长远看，我的目标是什么？为什么这个目标对我有特别的意义？如果实现了这个目标，我能得到什么？ 如果不拖延了，我能得到什么？它对实现这个目标会有什么样的帮助？ 如果不拖延了，我的生活会有什么样的改变？这种变化是我喜欢的吗？ 我在乎和在乎我的人都有哪些？如果我不拖延了，会给他们带来什么样的好处？我希望他们得到这个好处吗？ 试着想象自己实现目标以后的画面和场景，想得越细致越好。经常提醒自己，我为什么要克服拖延症。强化你要拖延的事与你梦想的联系。 警惕两种错误：①用立志代替行动。澄清梦想和列目标当然也是努力的一种，但它只是起点，不能代替现实的努力。②跟自己死磕。真正适应性的思维，既有对梦想的执著，也有灵活的态度。根本目标不变的情况下换一条路。 原则二：觉察而非控制大脑运行的规律之一，是不能用意志去控制自己的想法。当人们控制自己的思维不去想某件事时，反而会比不控制自己思维时要想得更多。这种效应称为「讽刺性反弹」（ ironic rebound ）。想通过抑制想法来抵御诱惑，实在是南辕北辙。因此在思维中给诱惑留下弹性的空间，温柔地觉察自己的欲望但不付诸行动。用觉察代替控制，提醒自己我们的目标和梦想，反而能让诱惑的吸引力降低。 原则三：自我激励而非自我谴责内疚和自责能用于抵抗拖延症是一种错觉。通常的情况是，我们在上一次拖延中对自己态度越严厉，下次越拖延就越严重。内疚和自责会让我们陷入「放纵 — 自责 — 更严重地放纵」的恶性循环。内疚和自责会降低我们的自尊，让我们觉得自己懒惰、一事无成，进而破罐子破摔。内疚和自责也会带来更多的压力，而压力会让我们更容易屈从诱惑。相比于内疚，自我谅解反而更能增强责任感。这是因为一旦摆脱了内疚和自责，我们反而能够思考为什么会失败，而不是简单地把原因归于自己的无能。告诉自己，我只是一个凡人，接纳自己的不足，爱自己。在拖延之后，用自我激励代替自我谴责，提醒自己能够做得更好。 原则四：和自己谈判拖延症的特点之一，就是很难从娱乐状态切换到工作状态，但一旦投入工作了，需要的意志力就没那么大。让自己从放松娱乐状态重新回到工作状态，与自己谈判：「不想工作啊？」「嗯。」「不玩行不行？」「憋不住啊。」「这样，你先到书桌边工作半小时行不行？就半小时。半小时后允许你玩。」（太难那就10分钟）「那 …… 行吧。」 原则五：目标和计划好计划的几个原则： 一、做计划之前，先要有两个目标。 一个目标是抽象的、长远的。它应该跟我们的梦想有关。它应该是积极目标而非消极目标。（如「快乐地生活」是积极目标，「减少抑郁」不是。） 具体的目标。具体目标应该跟抽象目标有直接的联系。具体的目标决定了计划是否可以执行。具体目标包含这两个问题的答案：怎么样算做成了？什么时候做成？ 重点：把大目标分解成小目标。小目标能够让我们的计划循序渐进。合理的小目标应该是对你来说不太难，又不太容易，是你踮着脚能够到的。（小目标的成功会让你相信改变是可能的，并进一步激发你改变的愿望。某部分规律的生活，能够让你获得一种掌控感。） 二、反馈。 一个是百分比。当开始计划一项任务时，用一个百分比来表示在这个任务上已经有了多少积累，大概进展到什么程度了。百分比不需要太精确，你心里的感觉就可以。每次完成一个任务，都调整一下这个百分比，这样会有进步的感觉。 打 √ 打 × 。把你所有要完成的事写下来，每次做完一件，给自己打一个 √ ，否则，打一个 × ，并注明为什么没完成。 三、把不可控的目标转为可控目标。拖延的问题，有时候是因为我们不愿意去面对不确定性。但这种不确定性总会存在，但这种不确定性的背后，都会有我们可以控制的部分。把事情背后可控的部分做成计划，这会让我们意识到，哪怕我们没法决定很多事，我们仍然有很多事可做。至于其他，就让我们交给天意了。 原则六： GTD （ Get Things Done ）有时候拖延，是因为事情太多太杂。多任务交错会导致火气与混乱。通常的任务管理方法，是列出所要做的事情，并按轻重缓急进行排序。GTD 提出的原则，是多做一步，不仅列出要做的事情，而且列出这件事下一步该怎么做：处理、搁置还是丢弃？（一旦做出计划潜意识就不会再反复提醒了） 原则七：积极拖延斯坦福大学约翰 · 佩里教授在《拖拉一点又何妨》中提出「结构化拖延」。把看起来最重要、最紧急的事排在清单最前头，把其他不紧急但也值得一做的事排在清单后面，为了避免去做清单最前面的任务，人就会努力做清单后面的任务。 原则八：和他人建立联系「宅」容易生出拖延症的原因： 我们内心里其实都有一个关于「空间功能」的假设。在这个假设里，图书馆、自习室或者写字间是和工作相联系的，而家或宿舍是和休息或娱乐相联系的。 人是社会的动物，总是以他人的行为为参照。学习或者工作氛围很容易相互感染，反之如果你一个人宅着，你能参照的就只有自己了。 如果你一直宅着，你很难跟别人建立起有效的情感联系。如前文所说的缺爱。 原则九：设想未来我们对未来自己的设想和对别人的设想在很多地方是类似的。对未来自己的善意和对他人的善意是类似，而对未来自己的痛苦也和对他人的痛苦是类似，而这种痛苦很难完全被感受到。自我管理其实也像管理团队。团队中，「现在的我」是嫡系和亲信，拖延的人太习惯把好处留给他，把脏活累活留给别人。「未来的我」就是那个干脏活累活背黑锅的「别人」。要管理好一个团队，你必须要公正处事，平衡各方面的关系。你需要拉近「现在的我」和「未来的我」的距离。（作者的方法是给未来的自己写信，想想他会怎么看待「现在的我」，会如何看待「现在的我」所做的选择，如何因为「现在的我」的辛勤努力而心怀感激。） 原则十：冥想、运动和睡眠每当烦躁抑郁的时候，坚持做一段时间的冥想。重要的不是冥想，还在于冥想背后传递的生活理念和态度 —— 专注于此时此刻，和自己在一起，觉察而非改变，接纳而非批判。最好是能在心平气和的时候养成每天做半小时冥想的习惯。（卡巴金《正念》，正念式冥想）和其他心理问题一样，拖延症只是我们整个生活图景的一部分。拖延症的背后，是我们的恐惧和期待、犹疑和奋斗、局限和潜力、现实和梦想，是我们的人生，和人生的意义。有时候我们会这样，迷茫、自我怀疑、焦虑，因看不清远方的目标而不知道该做什么，如果这时候你还有足够的精力和资源照亮你脚下的一点点路，那么就看脚下。走着走着，回过头，也许你发现自己已经走得很远了。 转载地址：http://blog.sina.com.cn/u/1708023907]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>拖延症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《子平真诠》—— 沈孝瞻]]></title>
    <url>%2F2016%2F10%2F11%2Fziping%2F</url>
    <content type="text"><![CDATA[一、论十干十二支天地之间，一气而己。惟有动静，遂分阴阳。有老少，遂分四象。老者极动静之时，是为太阳太阴；少者初动初静之际，是为少阴少阳。有是四象，而五行具于其中矣。水者，太阴也；火者，太阳也；木者，少阳也；金者，少阴也；土者，阴阳老少、木火金水冲气所结也。 有是五行，何以又有十干十二支乎？盖有阴阳，因生五行，而五行之中，各有阴阳。即以木论，甲乙者，木之阴阳也。甲者，乙之气；乙者，甲之质。在天为生气，而流行于万物者，甲也；在地为万物，而承兹生气者，乙也。又细分之，生气之散布者，甲之甲，而生气之凝成者，甲之乙；万木之所以有枝叶者，乙之甲，而万木之枝枝叶叶者，乙之乙也。方其为甲，而乙之气已备；及其为乙，而甲之质乃坚。有是甲乙，而木之阴阳具矣。 何以复有寅卯者，又与甲乙分阴阳天地而言之者也。以甲乙而分阴阳，则甲为阳，乙为阴，木之行于天而为阴阳者也。以寅卯而阴阳，则寅为阳，卯为阴，木之存乎地而为阴阳者也。以甲乙寅卯而统分阴阳，则甲乙为阳寅卯为阴，木之在天成象而在地成形者也。甲乙行乎天，而寅卯受之；寅卯存乎也，而甲乙施焉。是故甲乙如官长，寅卯如该管地方。甲禄于寅，乙禄于卯，如府官之在郡，县官之在邑，而各司一月之令也。 甲乙在天，故动而不居。建寅之月，岂必当甲？建卯之月，岂必当乙？寅卯在地，故止而不迁。甲虽递易，月必建寅；乙虽递易，月必建卯。以气而论，甲旺于乙；以质而论，乙坚于甲。而俗书谬论，以甲为大林，盛而宜斩，乙为微苗，脆而莫伤，可为不知阴阳之理者矣。以木类推，余者可知，惟土为木火金水冲气，故寄旺于四时，而阴阳气质之理，亦同此论。欲学命者，必须先知干支之说，然后可以入门。 二、论阴阳生克四时之运，相生而成，故木生火，火生土，土生金，金生水，水复生木，即相生之序，循环迭运，而时行不匮。然而有生又必有克，生而不克，则四时亦不成矣。克者，所以节而止之，使之收敛，以为发泄之机，故曰“天地节而四时成”。即以木论，木盛于夏，杀于秋，杀者，使发泄于外者藏收内，是杀正所以为生，大易以收剑为性情之实，以兑为万物所说，至哉言乎！譬如人之养生，固以饮食为生，然使时时饮食，而不使稍饥以待将来，人寿其能久乎？是以四时之运，生与克同用，克与生同功。 然以五行而统论之，则水木相生，金木相克。以五行之阴阳而分配之，则生克之中，又有异同。此所以水同生木，而印有偏正；金同克木，而局有官煞也。印绶之中，偏正相似，生克之殊，可置勿论；而相克之内，一官一煞，淑慝判然，其理不可不细详也。 即以甲乙庚辛言之。甲者，阳木也，木之生气也；乙者，阴木也，木之形质也。庚者，阳金也，秋天肃杀之气也；辛者，阴金也，人间五金之质也。木之生气，寄于木而行于天，故逢秋天为官，而乙则反是，庚官而辛杀也。又以丙丁庚辛言之。丙者，阳火也，融和之气也；丁者，阴火也，薪传之火也。秋天肃杀之气，逢阳和而克去，而人间之金，不畏阳和，此庚以丙为杀，而辛以丙为官也。人间金铁之质，逢薪传之火而立化，而肃杀之气，不畏薪传之火。此所以辛以丁为杀，而庚以丁为官也。即此以推，而余者以相克可知矣。 三、论阴阳生死五行干支之说，已详论于干支篇。干动而不息，支静而有常。以每干流行于十二支之月，而生旺墓绝系焉。 阳主聚，以进为进，故主顺；阴主散，以退为退，故主逆。此生沐浴等项，所以有阳顺阴逆之殊也。四时之运，功成者去，等用者进，故每流行于十二支之月，而生旺墓绝，又有一定。阳之所生，即阴之所死，彼此互换，自然之运也。即以甲乙论，甲为木之阳，木之枝枝叶叶，受天生气，己收藏饱足，可以为来克发泄之机，此其所以生于亥也。木当午月，正枝叶繁盛之候，而甲何以死？却不是外虽繁盛，而内之生气发泄已尽，此其所以死于午也。乙木反是，午月枝叶繁盛，即为之生，亥月枝叶剥落，即为之死。以质而论，自与气殊也。以甲乙为例，余可知矣。 支有十二月，故每干长生至胎养，亦分十二位。气之由盛而衰，衰而复盛，逐节细分，遂成十二。而长生沐浴等名，则假借形容之词也。长生者，犹人之初生也。沐浴者，犹人既生之后，而沐浴以去垢；如果核既为苗，则前之青壳，洗而去之矣。冠带者，形气渐长，犹人之年长而冠带也。临官者，由长而壮，犹人之可以出仕也。帝旺者，壮盛之极，犹人之可以辅帝而大有为也。衰者，盛极而衰，物之初变也。病者，衰之甚也。死者，气之尽而无余也。墓者，造化收藏，犹人之埋于土者也。绝者，前之气已绝，后之气将续也。胎者，后之气续而结聚成胎也。养者，如人养母腹也。自是而后，长生循环无端矣。 人之日主，不必生逢禄旺，即月令休囚，而年日时中, 得长禄旺，便不为弱，就使逢库，亦为有根。时产谓投库而必冲者，俗书之谬也，但阳长生有力，而阴长生不甚有力，然亦不弱。若是逢库，则阳为有根，而阴为无用。盖阳大阴小，阳得兼阴，阴不能兼阳，自然之理也。 四、论十干配合性情合化之义，以十干阴阳相配而成。河图之数，以一二三四五配六七八九十，先天之道也。故始于太阴之水，而终于冲气之土，以气而语其生之序也。盖未有五行之先，必先有阴阳老少，而后冲气，故生以土。终之既有五行，则万物又生于土，而水火木金，亦寄质焉，故以土先之。是以甲己相合之始，则化为土；土则生金，故乙庚化金次之；金生水，故丙辛化水又次之；水生木，故丁壬化木又次之；木生火，故戊癸化火又次之，而五行遍焉。先之以土，相生之序，自然如此。此十干合化之义也。 其性情何也？盖既有配合，必有向背。如甲用辛官，透丙作合，而官非其官；甲用癸印，透戊作合，而印非其印；甲用己财，己与别位之甲作合，而财非其财。如年己月甲，年上之财，被月合去，而日主之甲乙无分；年甲月己，月上之财，被年合去，而日主之甲乙不与是也。甲用丙食与辛作合，而非其食，此四喜神因合而无用者也。 又如甲逢庚为煞，与乙作合，而煞不攻身；甲逢乙为劫财，甲逢丁为伤，与壬作合，而丁不为伤官；甲逢壬为枭，与丁作合，而壬不夺食。此四忌神因合化吉者也。 盖有所合则有所忌，逢吉不为吉，逢凶不为凶。即以六亲言之，如男以财为妻，而被别干合去，财妻岂能亲其夫乎？女以官为夫，而被他干合去，官夫岂能爱其妻乎？此谓配合之性情，因向背而殊也。 五、论十干合而不合十干化合之义，前篇既明之矣，然而亦有合而不合者，何也？ 盖隔于有所间也，譬如人彼此相好，而有人从中间之，则交必不能成。譬如甲与己合，而甲己中间，以庚间隔之，则甲岂能越克我之庚而合己？此制于势然也，合而不敢合也，有若无也。 又有隔位太远，如甲在年干，己在时上，心虽相契，地则相远，如人天南地北，不能相合一般。然于有所制而不敢合者，亦稍有差，合而不能合也，半合也，其为祸福得十之二三而已。 又有合而无伤于合者，何也？如甲生寅卯，月时两透辛官，以年丙合月辛，是为合一留一，官星反轻。甲逢月刃，庚辛并透，丙与辛合，是为合官留煞，而煞刃依然成格，皆无伤于合也。 又有合而不以合论者，何也？本身之合也。盖五阳逢财，五阴遇官，俱是作合，惟是本身十干合之，不为合去。假如乙用庚官，日干之乙，与庚作合，是我之官，是我合之。何为合去？若庚在年上，乙在月上，则月上之乙，先去合庚，而日干反不能合，是为合去也。又如女以官为夫，丁日逢壬，是我之夫，是我合之，正如夫妻相亲，其情愈密。惟壬在月上，而年丁合之，日干之丁，反不能合，是以己之夫星，被姊妹合去，夫星透而不透矣。 然又有争合妒合之说，何也？如两辛合丙，两丁合壬之类，一夫不娶二妻，一女不配二夫，所以有争合妒合之说。然到底终有合意，但情不专耳。若以两合一而隔位，则全无争妒。如庚午、乙酉、甲子、乙亥，两乙合庚，甲日隔之，此高太尉命，仍作合煞留官，无减福也。 六、论十干得时不旺失时不弱书云，得时俱为旺论，失时便作衰看，虽是至理，亦死法也。然亦可活看。夫五行之气，流行四时，虽日干各有专令，而其实专令之中，亦有并存者在。假若春木司令，甲乙虽旺，而此时休囚之戊己，亦尝艳于天地也。特时当退避，不能争先，而其实春土何尝不生万物，冬日何尝不照万国乎？ 况八字虽以月令为重，而旺相休囚，年月日时，亦有损益之权，故生月即不值令，而年时如值禄旺，岂便为衰？不可执一而论。犹如春木虽强，金太重而木亦危。干庚辛而支酉丑，无火制而晃富，逢土生而必夭，是以得时而不旺也。秋木虽弱，木根深而木亦强。干甲乙而支寅卯，遇官透而能受，逢水生而太过，是失时不弱也。 是故十干不论月令休囚，只要四柱有根，便能受财官食神而当伤官七煞。长生禄旺，根之重者也；墓库余气，根之轻者也。得一比肩，不如得支中一墓库，如甲逢未、丙逢戌之类。乙逢戌、丁逢丑、不作此论，以戌中无藏木，丑中无藏火也。得二比肩，不如得一余气，如乙逢辰、丁逢未之类。得三比肩，不如得一长生禄刃，如甲逢亥子寅卯之类。阴长生不作此论，如乙逢午、丁逢酉之类，然亦为明根，比得一余气。盖比劫如朋友之相扶，通根如室家之可住；干多不如根重，理固然也。 今人不知命理，见夏水冬火，不问有无通根，便为之弱。更有阳干逢库，如壬逢辰、丙坐戌之类，不以为水火通根身库，甚至求刑冲开之。此种谬论，必宜一切扫除也。 七、论刑冲会合解法刑者，三刑也，子卯巳申子类是也。冲者，六冲也，子午卯酉之类是也，会者，三会也，申子辰之类是也。合者，六合也，子与丑合之类是也。此皆以地支宫分而言，系对射之意也。三方为会，朋友之意也。并对为合，比邻之意也。至于三刑取庑，姑且阙疑，虽不知其所以然，于命理亦无害也。 八字支中，刑冲俱非美事，而三合六合，可以解之。假如甲生酉月，逢卯则冲，而或支中有戌，则卯与戌合而不冲；有辰，则酉与辰合而不冲；有亥与未，则卯与亥未会而不冲；有巳与丑，则酉与巳丑会而不冲。是会合可以解冲也。又如丙生子月，逢卯则刑，而或支中有戌，则与戌合而不刑；有丑，则子与丑合而不刑；有亥与未，则卯与亥未会而不刑；有申与辰，则子与申辰会而不刑。是会合可以解刑也。 又有因解而反得刑冲者，何也？假如甲生子月，支逢二卯相并，二卯不刑一子，而支又逢戌，戌与卯合，本为解刑，而合去其一，则一合而一刑，是因解而反得刑冲也。 又有刑冲而会合不能解者，何也？假如子年午月，日坐丑位，丑与子合，可以解冲，而时逢巳酉，则丑与巳酉会，而子复冲午；子年卯月，日坐戌位，戌与卯合，可以解刑，而或时逢寅午，则戌与寅午会，而卯复刑子。是会合而不能解刑冲也。 更有刑冲而可以解刑者，何也？盖四柱之中，刑冲俱不为美，而刑冲用神，尤为破格，不如以另位之刑冲，解月令之刑冲矣。假如丙生子月，卯以刑子，而支又逢酉，则又与酉冲不刑月令之官。甲生酉月，卯日冲之，而时逢子立，则卯与子刑，而月令官星，冲之无力，虽于别宫刑冲，六亲不无刑克，而月官犹在，其格不破。是所谓以刑冲而解刑冲也。 如此之类，在人之变化而己。 八、论用神八字用神，专求月令，以日干配月令地支，而生克不同，格局分焉。财官印食，此用神之善而顺用之者也；煞伤劫刃，用神之不善而逆用之者也。当顺而顺，当逆而逆，配合得宜，皆为贵格。 是以善而顺用之，则财喜食神以相生，生官以护财；官喜透财以相生，生印以护官；印喜官煞以相生，劫才以护印；食喜身旺以相生，生财以护食。不善而逆用之，则七煞喜食神以制伏，忌财印以资扶；伤官喜佩印以制伏，生财以化伤；阳刃喜官煞以制伏，忌官煞之俱无；月劫喜透官以制伏，利用财而透食以化劫。此顺逆之大路也。 今人不知专主提纲，然后将四柱干支，字字统归月令，以观喜忌，甚至见正官佩印，则以为官印双全，与印绶用官者同论；见财透食神，不以为财逢食生，而以为食神生财，与食神生财同论；见偏印透食，不以为泄身之秀，而以为枭神夺食，宜用财制，与食神逢枭同论；见煞逢食制而露印者，不为去食护煞，而以为煞印相生，与印绶逢煞者同论；更有煞格逢刃，不以为刃可帮身制煞，而以为七煞制刃，与阳刃露煞者同论。此皆由不知月令而妄论之故也。 然亦有月令无用神者，将若之何？如木生寅卯，日与月同，本身不可为用，必看四柱有无财官煞食透干会支，另取用神；然终以月令为主，然后寻用，是建禄月劫之格，非用而即用神也。 九、论用神成败救应用神专寻月令，以四柱配之，必有成败。何谓成？如官逢财印，又无刑冲破害，官格成也。财生官旺，或财逢食生而身强带比，或财格透印而位置妥贴，两不相克，财格成也。印轻逢煞，或官印双全，或身印两旺而用食伤泄气，或印多逢财而财透根轻，印格成也。食神生财，或食带煞而无财，弃食就煞而透印，食格成也。身强七煞逢制，煞格成也。伤官生财，或伤官佩印而伤官旺，印有根，或伤官旺、身主弱而透煞印，或伤官带煞而无财，伤官格成也。阳刃透官煞而露财印，不见伤官，阳刃格成也。建禄月劫，透官而逢财印，透财而逢食伤，透煞而遇制伏，建禄月劫之格成也。 何谓败？官逢伤克刑冲，官格败也；财轻比重，财透七煞，财格败也；印轻逢财，或身强印重而透煞，印格败也；食神逢枭，或生财露煞，食神格败也；七煞逢财无制，七煞格败也；伤官非金水而见官，或生财生带煞，或佩印而伤轻身旺，伤官格败也；阳刃无官煞，刃格败也；建禄月劫，无财官，透煞印，建禄月劫之格败也。 成中有败，必是带忌；败中有成，全凭救应。何谓带忌？如正官逢财而又逢伤；透官而又逢合；财旺生官而又逢伤逢合；印透食以泄气，而又遇财露；透煞以生印，而又透财，以去印存煞；食神带煞印而又逢财；七煞逢食制而又逢印；伤官生财而财又逢合；佩印而印又遭伤，透财而逢煞，是皆谓之带忌也。何谓救应？如官逢伤而透印以解之，杂煞而合煞以清之，刑冲而会合以解之；财逢劫而透食以化之，生官以制之，逢煞而食神制煞以生财，或存财而合煞；印逢财而劫财以解之，或合财而存印；食逢枭而就煞以成格，或生财以护食；煞逢食制，印来护煞，而逢财以去印存食；伤官生财透煞而煞逢合；阳刃用官煞带伤食，而重印以护之；建禄月劫用官，遇伤而伤被合，用财带煞而煞被合，是谓之救应也。 八字妙用，全在成败救应，其中权轻权重，甚是活泼。学者从此留心，能于万变中融以一理，则于命之一道，其庶几乎！ 十、论用神变化用神既主月令矣，然月令所藏不一，而用神遂有变化。如十二支中，除子午卯酉外，余皆有藏，不必四库也。即以寅论，甲为本主，如郡之有府，丙其长生，如郡之有同知，戊亦长生，如郡之有通判；假使寅月为提，不透甲而透丙，则如知府不临郡，而同知得以作主。此变化之由也。 故若丁生亥月，本为正官，支全卯未，则化为印。己生申月，本属伤官。藏庚透壬，则化为财。凡此之类皆用神之变化也。 变之而善，其格愈美；变之不善，其格遂坏，何谓变之而善？如辛生寅月，逢丙而化财为官；壬生戌月逢辛而化煞为印。癸生寅月，不专以煞论。此二者以透出而变化者也。癸生寅月，月令伤官秉令，藏甲透丙，会午会戌，则寅午戌三合，伤化为财；加以丙火透出，完全作为财论，即使不透丙而透戊土，亦作财旺生官论。盖寅午戌三合变化在前，不作伤官见官论也。乙生寅月，月劫秉令，会午会戌，则劫化为食伤，透戊则为食伤生财，不作比劫争财论。此二者因会合而变化者。因变化而忌化为喜，为变之善者。 何谓变之而不善？如丙生寅月，本为印绶，甲不透干而会午会戌，则化为劫。丙生申月，本属偏财，藏庚透壬，会子会辰，则化为煞。如此之类亦多，皆变之不善者也。 又有变之而不失本格者。如辛生寅月，透丙化官，而又透甲，格成正财，正官乃其兼格也。乙生申月，透壬化印，而又透戊，则财能生官，印逢财而退位，虽通月令，格成伤官，百戊官忌见。丙生寅月，午戌会劫，而又或透甲，或透壬，则仍为印而格不破。丙生申月，逢壬化煞，而又透戊，则食神能制煞生财，仍为财格，不失富贵。如此之类甚多，是皆变而不失本格者也。 是故八字非用神不立，用神非变化不灵，善观命者，必于此细详之。 十一、论用神纯杂用神既有变化，则变化之中，遂分纯、杂。纯者吉，杂者凶。 何谓纯？互用而两相得者是也。如辛生寅月，甲丙并透，财与官相生，两相得也。戊生申月，庚壬并透，财与食相生，两相得也。癸生未月，乙己并透，煞与食相克，相克而得其当，亦两相得也。如此之类，皆用神之纯者。 何谓杂？互用而两不相谋者是也。如壬生未月，乙己并透，官与伤相克，两不相谋也。甲也辰月，戊壬并透，印与财相克，亦两不相谋也。如此之类，皆用之杂者也。 纯杂之理，不出变化，分而疏之，其理愈明，学命者不可不知也。 十二、论用神格局高低八字既有用神，必有格局，有格局必有高低，财官印食煞伤劫刃，何格无贵？何格无贱？由极贵而至极贱，万有不齐，其变千状，岂可言传？然其理之大纲，亦在有情、有力无力之间而已。 如正官佩印，不如透财，而四柱带伤，反推佩印。故甲透酉官，透丁合壬，是谓合伤存官，遂成贵格，以其有情也。财忌比劫，而与煞作合，劫反为用。故甲生辰月，透戊成格，遇乙为劫，逢庚为煞，二者相合，皆得其用，遂成贵格，亦以其有情也。 身强煞露而食神又旺，如乙生酉月，辛金透，丁火刚，秋木盛，三者皆备，极等之贵，以其有力也。官强财透，身逢禄刃，如丙生子月，癸水透，庚金露，而坐寅午，三者皆均，遂成大贵，亦以其有力也。 又有有情而兼有力，有力而兼有情者。如甲用酉官，壬合丁以清官，而壬水根深，是有情而兼有力者也。乙用酉煞，辛逢丁制，而辛之禄即丁之长生，同根月令，是有力而兼有情者也。是皆格之最高者也。 如甲用酉官，透丁逢癸，癸克不如壬合，是有情而非情之至。乙逢酉逢煞，透丁以制，而或煞强而丁稍弱，丁旺而煞不昂，又或辛丁并旺而乙根不甚深，是有力而非力之全，格之高而次者也。 至如印用七煞，本为贵格，而身强印旺，透煞孤贫，盖身旺不劳印生，印旺何劳煞助？偏之又偏，以其无情也。伤官佩印，本秀而贵，而身主甚旺，伤官甚浅，印又太重，不贵不秀，盖欲助身则身强，制伤则伤浅，要此重印何用？是亦无情也。又如煞强食旺而身无根，身强比重而财无气，或夭或贫，以其无力也。是皆格之低而无用者也。 然其中高低之故，变化甚微，或一字而有千钧之力，或半字而败全局之美，随时观理，难以拟议，此特大略而已。 十三、论用神因成得败因败得成八字之中，变化不一，遂分成败；而成败之中，又变化不测，遂有因成得败，因败得成之奇。 是故化伤为财，格之成也，然辛生亥月，透丁为用，卯未会财，乃以党煞，因成得败矣。印用七煞，格之成也，然癸生申月，秋金重重，略带财以损太过，逢煞则煞印忌财，因成得败也。如此之类，不可胜数，皆因成得败之例也。 官印逢伤，格之败也，然辛生戊戌月，年丙时壬，壬不能越戊克丙，而反能泄身为秀，是因败得成矣。煞刃逢食，格之败也，然庚生酉月，年丙月丁，时上逢壬，则食神合官留煞，而官煞不杂，煞刃局清，是因败得成矣。如此之类，亦不可胜数，皆因败得成之例也。 其间奇奇怪怪，变幼无穷，惟以理权衡之，随在观理，因时运化，由他奇奇怪怪，自有一种至当不易不论。观命者毋眩而无主、执而不化也。 十四、论用神配气候得失论命惟以月令用神为主，然亦须配气候而互参之。譬如英雄豪杰，生得其时，自然事半功倍；遭时不顺，虽有奇才，成功不易。 是以印绶遇官，此谓官印双全，无人不贵。而冬木逢水，虽透官星，亦难必贵，盖金寒而水益冻，冻水不能生木，其理然也。身印两旺，透食则贵，凡印格皆然。而用之冬木，尤为秀气，以冬木逢火，不惟可以泄身，而即可以调候也。 伤官见官，为祸百端，而金水见之，反为秀气。非官之不畏夫伤，而调候为急，权而用之也。伤官带煞，随时可用，而用之冬金，其秀百倍。 伤官佩印，随时可用，而用之夏木，其秀百倍，火济水，水济火也。 伤官用财，本为贵格，而用之冬水，即使小富，亦多不贵，冻水不能生木也。 伤官用财，即为秀气，而用之夏木，贵而不甚秀，燥土不甚灵秀也。 春木逢火，则为木为通明，而夏木不作此论；秋金遇水，则为金水相涵，而冬金不作此论。气有衰旺，取用不同也。春木逢火，木火通明，不利见官；而秋金遇水，金水相涵，见官无碍。假如庚生申月，而支中或子或辰，会成水局，天干透丁，以为官星，只要壬癸不透露干头，便为贵格，与食神伤官喜见官之说同论，亦调候之道也。 食神虽逢正印，亦谓夺食，而夏木火盛，轻用之亦秀而贵，与木火伤官喜见水同论，亦调候之谓也。此类甚多，不能悉述，在学者引伸触类，神而明之而已。 十五、论相神紧要月令既得用神，则别位亦必有相，若君之有相，辅者是也。如官逢财生，则官为用，财为相；财旺生官，则财为用，官为相；煞逢食制，则煞为用，食为相。然此乃一定之法，非通变之妙。要而言之，凡全局之格，赖此一字而成者，均谓之相也。 伤用神甚于伤身，伤相甚于伤用。如甲用酉官，透丁逢壬，则合伤存官以成格者，全赖壬之相；戊用子财，透甲并己，则合煞存财以成格者，全赖己之相；乙用酉煞，年丁月癸，时上逢戊，则合去癸印以使丁得制煞者，全赖戊之相。 癸生亥月，透丙为财，财逢月劫，而卯未来会，则化水为木而转劫以生财者，全赖于卯未之相。庚生申月，透癸泄气，不通月令而金气不甚灵，子辰会局，则化金为水而成金水相涵者，全赖于子辰之相。如此之类，皆相神之紧要也。 相神无破，贵格已成；相神相伤，立败其格。如甲用酉官，透丁逢癸印，制伤以护官矣，而又逢戊，癸合戊而不制丁，癸水之相伤矣；丁用酉财，透癸逢己，食制煞以生财矣，而又透甲，己合甲而不制癸，己土之相伤矣。是皆有情而化无情，有用而成无用之格也。 凡八字排定，必有一种议论，一种作用，一种弃取，随地换形，难以虚拟，学命者其可忽诸？ 十六、论杂气如何取用四墓者，冲气也，何以谓之杂气？以其所藏者多，用神不一，故谓之杂气也。如辰本藏戊，而又为水库，为乙余气，三者俱有，于何取用？然而甚易也，透干会取其清者用之，杂而不杂也。 何谓透干？如甲生辰月，透戊则用偏财，透癸则用正印，透乙则用月劫是也。 何谓会支？如甲生辰月，逢申与子会局，则用水印是也。一透则一用，兼透则兼用，透而又会，则透与会并用。其合而有情者吉，其合而无情者则不吉。 何谓有情？顺而相成者是也。如甲生辰月，透癸为印，而又会子会申以成局，印绶之格，清而不杂，是透干与会支，合而有情也。又如丙生辰月，透癸为官，而又逢己以为印，官与印相生，而印又能去辰中暗土以清官，是两干并透，合而情也。又如甲生丑月，辛透为官，或巳酉会成金局，而又透己财以生官，是两干并透，与会支合而有情也。 何谓无情？逆而相背者是也。如壬生未月，透己为官，而地支会亥卯以成伤官之局，是透官与会支，合而无情者也。又如甲生辰月，透戊为财，又或透壬癸以为印，透癸则戊癸作合，财印两失，透壬则财印两伤，又以贪财坏印，是两干并透，合而无情也。又如甲生戌月，透辛为官，而又透丁以伤官，月支又会寅会午以成伤官之局，是两干并透，与会支合而无情也。 又有有情而卒成无情者，何也？如甲生辰月，逢壬为印，而又逢丙，印绶本喜泄身为秀，似成格矣，而火能生土，似又助辰中之戊，印格不清，是必壬干透而支又会申会子，则透丙亦无所碍。又有甲生辰月，透壬为印，虽不露丙而支逢戌位，戌与辰冲，二者为月冲而土动，干头之壬难通月令，印格不成，是皆有情而卒无情，富而不贵者也。 又有无情而终有情者，何也？如癸生辰月，透戊为官，又有会申会子以成水局，透干与会支相克矣。然所克者乃是劫财，譬如月劫用官，何伤之有？又如丙生辰月，透戊为食，而又透壬为煞，是两干并透，而相克也。然所克者乃是偏官，譬如食神带煞，煞逢食制，二者皆是美格，其局愈贵。是皆无情而终为有情也。 如此之类，不可胜数，即此为例，旁悟而已。 十七、论墓库刑冲之说辰戌丑未，最喜刑冲，财官入库不冲不发——此说虽俗书盛称之，然子平先生造命，无是说也。夫杂气透干会支，岂不甚美？又何劳刑冲乎？假如甲生辰月，戊土透岂非偏财？申子会岂非印绶？若戊土不透，即辰戌相冲，财格犹不甚清也。至于透壬为印，辰戌相冲，将以累印，谓之冲开印库可乎？ 况四库之中，虽五行俱有，而终以土为主。土冲则灵，金木水火，岂取胜以四库之冲而动乎？故财官属土，冲则库启，如甲用戊财而辰戌冲，壬用己官而丑未冲之类是也。然终以戊己干头为清用，干既透，即不冲而亦得也。至于财官为水，冲则反累，如己生辰月，壬透为财，戌冲则劫动，何益之有？丁生辰月，透壬为官，戌冲则伤官，岂能无害？其可谓之逢冲而壬水之财库官库开乎？ 今人不知此理，甚有以出库为投库。如丁生辰月，壬官透干，不以为库内之壬，干头透出，而反为干头之壬，逢辰入库，求戌以冲土，不顾其官之伤。更有可笑者，月令本非四墓，别有用神，年月日时中一带四墓，便求刑冲；日临四库不以为身坐库根，而以为身主入库，求冲以解。种种谬论，令人掩耳。 然亦有逢冲而发者，何也？如官最忌冲，而癸生辰月，透戊为官，与戌相冲，不见破格，四库喜冲，不为不足。却不知子午卯酉之类，二者相仇，乃冲克之冲，而四墓土自为冲，乃冲动之冲，非冲克之冲也。然既以土为官，何害于事乎？ 是故四墓不忌刑冲，刑冲未必成格。其理甚明，人自不察耳。 十八、论四吉神能破格财官印食，四吉神也，然用之不当，亦能破格。 如食神带煞，透财为害，财能破格也；春木火旺，见官则忌，官能破格也；煞逢食制，透印无功，印能破格也；财旺生官，露食则杂，食能破格也。 是故官用食破，印用财破。譬之用药，参苓芪术，本属良材，用之失宜，亦能害人。官忌食伤，财畏比劫，印惧财破，食畏印夺，参合错综，各极其妙。弱者以生扶为喜，强者因生扶而反害；衰者以裁抑为忌，太旺者反以裁抑而得益。吉凶喜忌，全在是否合于需要，不因名称而有分别也。 十九、论四凶神能成格煞伤枭刃，四凶神也，然施之得宜，亦能成格。如印绶根轻，透煞为助，煞能成格也。财逢比劫，伤官可解，伤能成格也。食神带煞，灵枭得用，枭能成格也。财逢七煞，刃可解厄，刃能成格也。 是故财不忌伤，官不忌枭，煞不忌刃，如治国长抢大戟，本非美具，而施之得宜，可以戡乱。 二十、论生克先后分吉凶月令用神，配以四柱，固有每字之生克以分吉凶，然有同此生克，而先后之间，遂分吉凶者，尤谈命之奥也。 如正官同是财伤并透，而先后有殊。假如甲用酉官，丁先戊后，后则以财为解伤，即不能贵，后运必有结局。若戊先而丁后时，则为官遇财生，而后因伤破，即使上运稍顺，终无结局，子嗣亦难矣。 印格同是贪格坏印，而先后有殊。如甲用子印，己先癸后，即使不富，稍顺晚境；若癸先而己在时，晚景亦悴矣。 食神同是财枭并透，而先后有殊。如壬用甲食，庚先丙后，晚运必亨，格亦富而望贵。若丙先而庚在时，晚运必淡，富贵两空矣。 七煞同是财食并透，而先后大殊。如己生卯月，癸先辛后，则为财以助用，而后煞用食制，不失大贵。若辛先而癸在时，则煞逢食制，而财转食党煞，非特不贵，后运萧索，兼难永寿矣。 他如此类，可以例推。然犹吉凶易者也，至丙生甲寅月，年癸时戊，官能生印，而不怕戊合；戊能泄身为秀，而不得越甲以合癸，大贵之格也。假使年月戊癸而时甲，或年甲而月癸时戊，则戊无所隔而合全癸，格大破矣。 丙生辛酉，年癸时己，伤因财间，伤之无力，间有小贵。假如癸己产并而中无辛隔，格尽破矣。 辛生申月，年壬月戊，时上丙官，不愁隔戊之壬，格亦许贵。假使年丙月壬而时戊，或年戊月丙而时壬，则壬能克丙，无望其贵矣。 如此之类，不可胜数，其中吉凶似难猝喻。然细思其故，理甚显然，特难为浅者道耳。 二十一、论星辰无关格局八字格局，专以月令配四柱，至于星辰好歹，既不能为生克之用，又何以操成败之权？况于局有碍，即财官美物，尚不能济，何论吉星？于局有用，即七煞伤官，何谓凶神乎？是以格局既成，即使满盘孤辰入煞，何损其贵？格局既破，即使満盘天德贵人，何以为功？今人不知轻重，见是吉星，遂致拋却用神，不管四柱，妄论贵贱，谬谈祸福，甚可笑也。 况书中所云禄贵，往往指正官而言，不是禄堂人贵人。如正财得伤贵为奇，伤贵也，伤官乃生财之具，正财得之，所以为奇，若指贵人，则伤贵为何物乎？又若因得禄而避位，得禄者，得官也，运得官乡，宜乎进爵，然如财用伤官食神，运透官则格条，正官运又遇官则重，凡此之类，只可避位也。若作禄堂，不独无是理，抑且得禄避位，文法上下相顾。古人作书，何至不通若是！ 又若女命，有云“贵众则舞裙歌扇”。贵众者，官众也，女以官为夫，正夫岂可叠出乎？一女众夫，舞裙歌扇，理固然也。若作贵人，乃是天星，并非夫主，何碍于众，而必为娼妓乎？ 然星辰命书，亦有谈及，不善看书者执之也。如“贵人头上带财官，门充驰马”，盖财官如人美貌，贵人如人衣服，貌之美者，衣服美则现。其实财官成格，即非贵人头上，怕不门充驰马！又局清贵，又带二德，必受荣封。若专主二德，则何不竟云带二德受两国之封，而秘先曰无煞乎？若云命逢险格，柱有二德，逢凶有救，右免于危，则亦有之，然终无关于格局之贵贱也。 二十二、论外格用舍八字用神既专主月令，何以又有外格乎？外格者，盖因月令无用，权而用之，故曰外格也。 如春木冬水、土生四季之类，日与月同，难以作用，类象、属象、冲财、会禄、刑合、遥迎、井栏、朝阳诸格，皆可用也。若月令自有用神，岂可另寻外格？又或春木冬水，干头已有财官七煞，而弃之以就外格，亦太谬矣。是故干头有财，何用冲财？干头有官，何用合禄？书云“提纲有用提纲重”，又曰“有官莫寻格局”，不易之论也。 然所谓月令无用者，原是月令本无用神，而今人不知，往往以财被劫官被伤之类。用神已破，皆以为月令无取，而弃之以就外格，则谬之又谬矣。 二十三、论宫分用神配六亲人有六亲，配之八字，亦存于命。 其由宫分配之者，则年月日时，自上而下，祖父妻子，亦自上而下。以地相配，适得其宜，不易之位也。 其由用神配之者，则正印也母，身所自出，取其生我也。若偏财受我克制，何反为父？偏财者，母之正夫也，正印为母，则偏才为父矣。正财为妻，受我克制，夫为妻纲，妻则从夫。若官煞则克制乎我，何以反为子女也？官煞者，财所生也，财为妻妾，则官煞为子女矣。至于比肩为兄弟，又理之显然者。 其间有无得力，或吉或凶，则以四柱所存或年月或日时财官伤刃，系是何物，然后以六亲配之用神。局中作何喜忌，参而配之，可以了然矣。 二十四、论妻子大凡命中吉凶，于人愈近，其验益灵。富贵贫贱，本身之事，无论矣，至于六亲，妻以配身，子为后嗣，亦是切身之事。故看命者，妻财子提纲得力，或年干有用，皆主父母身所自出，亦自有验。所以提纲得力，或年干有用，皆主父母双全得力。至于祖宗兄弟，不甚验矣。 以妻论之，坐下财官，妻当贤贵；然亦有坐财官而妻不利，逢伤刃而妻反吉者，何也？此盖月令用神，配成喜忌。如妻宫坐财，吉也，而印格逢之，反为不美。妻坐官，吉也，而伤官逢之，岂能顺意？妻坐伤官，凶也，而财格逢之，可以生堸，煞格逢之，可以制煞，反主妻能内助。妻坐阳刃，凶也，而或财官煞伤等格，四柱已成格局，而日主无气，全凭日刃帮身，则妻必能相关。其理不可执一。 既看妻宫，又看妻星。妻星者，干头之财也。妻透而成局，若官格透财、印多逢财、食伤透财为用之类，即坐下无用，亦主内助。妻透而破格，若印轻财露、食神伤官、透煞逢财之类，即坐下有用，亦防刑克。又有妻透成格，或妻宫有用而坐下刑冲，未免得美妻而难偕老。又若妻星两透，偏正杂出，何（可）一夫而多妻，亦防刑克之道也。 至于子息，其看宫分与星所透喜忌，理与论妻略同。但看子息，长生沐浴之歌，亦当熟读，如“长生四子中旬半，沐浴一双保吉祥，冠带临官三子位，旺中五子自成行，衰中二子病中一，死中至老没儿郞，除非养取他之子，入墓之时命夭亡，受气为绝一个子，胎中头产养姑娘，养中三子只留一，男子宫中子细详”是也。 然长生论法，用阳而不用阴。如甲乙日只用庚金长生，巳酉丑顺数之局，而不用辛金逆数之子申辰。虽书有官为女煞为男之说，然终不可以甲用庚男而用阳局，乙用辛男而阴局。盖木为日主，不问甲乙，总以庚为男辛为女，其理为然，拘于官煞，其能验乎？ 所以八字到手，要看子息，先看时支。如甲乙生日，其时果系庚金何宫？或生旺，或死绝，其多寡已有定数，然后以时干子星配之。如财格而时干透食，官格而时干透财之类，皆谓时干有用，即使时逢死绝，亦主子贵，但不甚繁耳。若又逢生旺，则麟儿绕膝，岂可量乎？若时干不好，子透破局，即逢生旺，难为子息。若又死绝，无所望矣。此论妻子之大略也。 二十五、论行运论运与看命无二法也。看命以四柱干支，配月令之喜忌，而取运则又以运之干，配八字之喜忌。故运中每运行一字，即必以此一字，配命中干支而统观之，为喜为忌，吉凶判然矣。 何为喜？命中所喜之神，我得而助之者是也。如官用印以制伤，而运助印；财生官而身轻，而运助身；印带财以为忌，而运劫财；食带煞以成格，身轻而运逢印，煞重而运助食；伤官佩印，而运行官煞；阳刃用官，而运助财乡；月劫用财，而运行伤食。如此之类，皆美运也。 何谓忌？命中所忌，我逆而施之者是也。如正官无印，而运行伤；财不透食，而运行煞；印绶用官，而运合官；食神带煞，而运行财；七煞食制，而运逢枭；伤官佩印，而运行财；阳刃用煞，而运逢食；建禄用官，而运逢伤。如此之类，皆败运也。 其有似喜而实忌者，何也？如官逢印运，而本命有合，印逢官运，而本命用煞之类是也。 有似忌而实喜者，何也？如官逢伤运，而命透印，财行煞运，而命透食之类是也。 又有行干而不行支者，何也？如丙生子月亥年，逢丙丁则帮身，逢巳午则相冲是也。 又有行支而不行干者，何也？如甲生酉月，辛金透而官犹弱，逢申酉则官植根，逢庚辛则混煞重官之类是也。 又有干同一类而不两行者，何也？如丁生亥月，而年透壬官，逢丙则帮身，逢丁则合官之类是也。 又有支同一类而不两行者，何也？如戊生卯月，丑年，逢申则自坐长生，逢酉则会丑以伤官之类是也。 又有同是相冲而分缓急者，何也？冲年月则急，冲日时则缓也。 又有同是相冲而分轻重者，何也？运本美而逢冲则轻，运既忌面又冲则重也。 又有逢冲而不冲，何也？如甲用酉官，行卯则冲，而本命巳酉相会，则冲无力；年支亥未，则卯逢年会而不冲月官之类是也。 又有一冲而得两冲者，何也？如乙用申官，两申并而不冲一寅，运又逢寅，则运与本命，合成二寅，以冲二申之类是也。 二十六、论行运成格变格命之格局，成于八字，然配之以运，亦有成格变格之要权。其成格变格，较之喜忌祸福尤重。 何为成格,本命用神，成而未全，从而就之者是也。如丁生辰月，透壬为宫，而运逢申子以会之；乙生辰月，或申或子会印成局，而运逢壬癸以透之。如此之类，皆成格也。 何为变格,如丁生辰月，透壬为官，而运逢戌，透出辰中伤官；壬生戌月，丁己并透，而支又会寅会午，作财旺生官矣，而运逢戊土，透出戌中七煞；壬生亥月，透己为用，作建禄用官矣，而运逢卯未，会亥成本，又化建禄为伤。如此之类，皆变格也。 然亦有逢成格而不喜者，何也？如壬生午月，运透己官，而本命有甲乙之类是也。 又有逢变格而不忌者，何也？如丁生辰月，透壬用官，逢戊而命有甲；壬生亥月，透己用官，运逢卯未，而命有庚辛之类是也。 成格变格，关系甚大，取运者其细详之。 二十七、论喜忌干支有别命中喜忌，虽支干俱有，而干主天，动而有为，支主地，静以待用，且干主一而支藏多，为福为祸，安不得殊？ 譬如甲用酉官，逢庚辛则官煞杂，而申酉不作此例。申亦辛之旺地，辛坐申酉，如府官又掌道印也。逢二辛则官犯重，而二酉不作此例。辛坐二酉，如一府而摄二郡也，透丁则伤官，而逢午不作此例。丁动而午静，且丁巳并藏，安知其为财也？ 然亦有支而能作祸福者，何也？如甲用酉官，逢午酉未能伤，而又遇寅遇戌，不隔二位，二者合而火动，亦能伤矣。即此反观，如甲生甲月，午不制煞，会寅会戌，二者清局而火动，亦能矣。然必会有动，是正与干有别也。即此一端，余者可知。 二十八、论支中喜忌逢运透清支中喜忌，固与干有别矣，而运逢透清，则静而待用者，正得其用，而喜忌之验，于此乃见。何谓透清？如甲用酉官，逢辰未即为财，而运透戊，逢午未即为伤，而运透丁之类是也。 若命与运二支会局，亦作清论。如甲用酉官，本命有午，而运逢寅戌之类。然在年则重，在日次之，至于时生于午，而运逢寅戌会局，则缓而不急矣。虽格之成败高低，八字已有定论，与命中原有者不同，而此五年中，亦能炒其祸福。若月令之物，而运中透清，则与命中原有者，不甚相悬，即前篇所谓行运成格变格是也。 故凡一八字到手，必须逐干逐支，上下统看。支为干之生地，干为支之发用。如命中有一甲字，则统观四支，有寅亥卯未等字否，有一字，皆甲木之根也。有一亥字，则统观四支，有壬甲二字否。有壬，则亥为壬禄，以壬水用；用甲，则亥为甲长生，以甲木用；用壬甲俱全，则一以禄为根，一以长生为根，二者并用。取运亦用此术，将本命八字，逐干支配之而已。 二十九、论时说拘泥格局 八字用神专凭月令，月无用神，台寻格局。月令，本也；外格，未也。今人不知轻重，拘泥格局，执假失真。 故戊生甲寅之月，时上庚甲，不以为明煞有制，而以为专食之格，逢甲减福。丙生子月，时逢巳禄，不以为正官之格，归禄帮身，而以为日禄归时，逢官破局。辛日透丙，时遇戊子，不以为辛日得官逢印，而以为朝阳之格，因丙无成。财逢时煞，不以为生煞攻身，而以为时上偏官。 癸生巳月，时遇甲寅，不以为暗官受破，而以为刑合成格。 癸生冬月，酉日亥时，透戊坐戌，不以为月劫建禄，用官通根，而以为拱戌之格，填实不利。辛日坐丑，寅年，亥月，卯时，不以为正财之格，而以为填实拱贵。 乙逢寅月，时遇丙子，不以为木火通明，而以为格成鼠贵。 如此谬论，百无一是，此皆由不知命理，妄为评断。 三十、论时说以讹传讹八字本有定理，理之不明，遂生导端，妄言妄听，牢不可破。如论干支，则不知阴阳之理，而以俗书体象歌诀为确论；论格局，则不知专寻月令，而以拘泥外格为活变；论生克，则不察喜忌，而以伤旺扶弱为定法；论行运，则不问同中有导，而以干支相类为一例。 究其缘由，一则书中用字轻重，不知其意，而谬生偏见；一则以鹆书无知妄作，误会其说，而深入迷途；一则论命取运，偶然湊合，而遂以己见为不易，一则以古人命式，亦有误收，即收之不误，又以己意入外格，尤为害人不浅。 如壬申、癸丑、己丑、甲戌，本杂气财旺生官也，而以为乙亥时，作时上偏官论，岂知旺财生煞，将救死之不暇，于何取贵？此类甚多，皆误收格局也。如己未、壬申、戊子、庚申，本食神生财也，而欲弃月令，以为戊日庚申合禄之格，岂知本身自有财食，岂不甚美？又何劳以庚合乙，求局外之官乎，此类甚多，皆硬入外格也。 人苟中无定见，察理不精，睹此谬论，岂能无惑？何况近日贵格不可解者，亦往往有之乎？岂知行术之人，必以贵命为指归，或将风闻为实据，或探其生日，而即以己意加之生时，谬造贵格，其人之八字，时多未确，即彼本身，亦不自知。若看命者不究其本，而徒以彼既富贵迁就其说以相从，无惑乎终身无解日矣！ 三十一、论正官官以克身，虽与七煞有别，终受彼制，何以切忌刑冲破害，尊之若是乎？岂知人生天地间，必无矫焉自尊之理，虽贵极天子，亦有天祖临之。正官者分所当尊，如在国有君，在家有亲，刑冲破害，以下犯上，乌乎可乎？ 以刑冲破害为忌，则以生之护之为喜矣。存其喜而去其忌则贵，而贵之中又有高低者，何也？以财印并透者论之，两不相碍，其贵也大。如薛相公命，甲申、壬申、乙巳，戊寅，壬印戊财，以乙隔之，水与土不相碍，故为大贵。若壬戌、丁未、戊甲、乙卯，杂气正官，透干会支，最为贵格，而壬财丁印，二者相合，仍以孤官无辅论，所以不上七品。 若财印不以两用，则单用印不若单用财，以印能护官，亦能泄官，而财生官也。若化官为印而透财，则又为甚秀，大贵之格也。如金状元命，乙卯、丁亥、丁未、庚戌，此并用财印，无伤官而不杂煞，所谓去其忌而存其喜者也。 然而遇伤在于佩印，混煞贵乎取清。如宣参国命，己卯、辛未、壬寅、辛亥，未中己官透干用清，支会水局，两辛解之，是遇伤而佩印也。李参政命，庚寅、乙酉、甲子、戊辰，甲用酉官，庚金混杂，乙以合之，合煞留官，是杂煞而取清也。 至于官格透伤用印者，又忌见财，以财能去印，未能生官，而适以护伤故也。然亦有逢财而反大贵者，如范太傅命，丁丑、壬寅、己巳、丙寅，支具巳丑，会金伤官，丙丁解之，透壬岂非破格？却不知丙丁并透，用一而足，以丁合壬而财去，以丙制伤而官清，无情而愈有情。此正造化之妙，变幻无穷，焉得不贵？至若地支刑冲，会合可解，已见前篇，不必再述，而以后诸格，亦不谈及矣。 三十二、论正官取运取运之道，一八字则有一八字这论，其理甚精，其法甚活，只可大略言之。变化在人，不可泥也。 如正官取运，即以正官所统之格分而配之。正官而用财印，身稍轻则取助身，官稍轻则助官。若官露而不可逢合，不可杂煞，不可重官。与地支刑冲，不问所就何局，皆不利也。 正官用财，运喜印受身旺之地，切忌食伤。若身旺而财轻官弱，即仍取财官运可也。 正官佩印，运喜财乡，伤食反吉。若官重身轻而佩印，则身旺为宜，不必财运也。 正官带伤食而用印制，运喜官旺印旺之乡，财运切忌。若印绶叠出，财运亦无害矣。 正官而带煞，伤食反为不碍。其命中用劫合煞，则财运可行，伤食可行，身旺，印绶亦可行，只不过复露七煞。若命用伤官合煞，则伤食与财俱可行，而不宜逢印矣。 三十三、论财财为我克，使用之物也，以能生官，所以为美。为财帛，为妻妾，为才能，为驿马，皆财类也。 财喜根深，不宜太露，然透一位以清用，格所最喜，不为之露。即非月令用神，若寅透乙、卯透甲之类，一亦不为过，太多则露矣。然而财旺生官，露亦不忌，盖露不忌，盖露以防劫，生官则劫退，譬如府库钱粮，有官守护，即使露白，谁敢劫之？如葛参政命，壬申、壬子、戊午、乙卯，岂非财露？唯其生官，所以不忌也。 财格之贵局不一，有财旺生官者，身强而不透伤官，不混七煞，贵格也。 有财用食生者，身强而不露官，略带一位比劫，益觉有情，如壬寅、壬寅、庚辰、辛巳，杨待郎之命是也。透官身弱，则格坏矣。 有财格佩印者，盖孤财不贵，佩印帮身，即印取贵。如乙未、甲申、丙申、庚寅，曾参政之命是也，然财印宜相并，如乙未、己卯、庚寅、辛巳，乙与己两不相能，即有好处，小富而已。 有用食而兼用印者，食与印两不相碍，或有暗官而去食护官，皆贵格也。如吴榜眼命，庚戌、戊子、戊子、丙辰，庚与丙隔两戊而不相克，是食与印不相碍也。如平江伯命，壬辰、乙巳、癸巳、辛酉，虽食印相克，而欲存巳戊官，是去食护官也。反是则减福矣。 有财用伤官者，财不甚旺而比强，辂露一位伤官以化之，如甲子、辛未、辛酉、壬辰，甲透未库，逢辛为劫，壬以化劫生财，汪学士命是也，财旺无劫而透伤，反为不利，盖伤官本非美物，财轻透劫，不得己而用之。旺而露伤，何苦用彼？徒使财遇伤而死生官之具，安望富贵乎？ 有财带七煞者，或合煞存财，或制煞生财，皆贵格也，如毛状元命，乙酉、庚辰、甲午、戊辰，合煞存财也；李御史命，庚辰、戊子、戊寅、甲寅，制煞生财也。 有财用煞印者，党煞为忌，印以化之，格成富局，若冬土逢之亦贵格。如赵待郎命，乙丑、丁亥、己亥、乙亥，化煞而即以解冻，又不露财以杂其印，所以贵也。若财用煞印，而财并透，非特不贵，亦不富也。 至于壬生午月，癸生巳月，单透财而亦贵，又月令有暗官也。如丙寅、癸巳、癸未、壬戌，林尚书命是也。又壬生巳月，单透财而亦贵，以其透丙藏戊，弃煞就财，美者存在赠者弃也。如丙辰、癸巳、壬戌、壬寅，王太仆命是也。至于劫刃太重，弃财就煞，如一尚书命，丙辰、丙申、丙午、壬辰，此变之又变者也。 三十四、论财取运财格取运，即以财格所就之局，分而配之。其财旺生官者，运喜身旺印缓，不利七煞伤官；若生官而后透印，伤官之地，不甚有害。至于生官而带食破局，则运喜印绶，而逢煞反吉矣。 财用食生，财食重而身轻，则喜助身；财食轻而身重，则仍行财食。煞运不忌，官印反晦矣。 财格佩印，运喜官乡，身弱逢之，最喜印旺。 财用食印，财轻则喜财食，身轻则喜比印，官运有碍，煞反不忌也。 财带伤官，财运则亨，煞运不利，运行官印，未见其美矣。 财带七煞。不论合煞制煞，运喜食伤身旺之方。 财用煞印，印旺最宜，逢财必忌。伤食之方，亦任意矣。 三十五、论印绶印绶喜其生身，正偏同为美格，故财与印不分偏正，同为一格而论之。印绶之格局亦不一，有印而透官者，正官不独取其生印，而即可以为用，与用煞者不同。故身旺印强，不愁太过，只要官星清纯，如丙寅、戊戌、辛酉、戊子，张参政之命是也。 然亦有带伤食而贵者，则如朱尚书命，丙戌、戊戌、辛未、壬辰，壬为戊制，不伤官也。又如临淮侯命，乙亥、己卯、丁酉、壬寅，己为乙制，己不碍官也。 有印而用伤食者，身强印旺，恐其太过，泄身以为秀气。如戊戌、乙卯、丙午、乙亥，李状元命也，若印浅身轻，而用层层伤食，则寒贫之局矣。 有用偏官者，偏官本非美物，藉其生印，不得已而用之。故必身重印轻，或身轻印重，有所不足，始为有性。如茅状元命，己巳、癸酉、癸未、庚申，此身轻印重也。马参政命，壬寅、戊申、壬辰、壬寅，此身重印轻也。若身印并重而用七煞，非孤则贫矣。 有用煞而兼带伤食者，则用煞而有制，生身而有泄，不论身旺印重，皆为贵格。 有印多而用财者，印重身强，透财以抑太过，权而用之，只要根深，无防财破。如辛酉、丙申、壬申、辛亥，汪侍郎命是也。若印轻财重，又无劫财以救，则为贪财破印，贫贱之局也。 即或印重财轻而兼露伤食，财与食相生，轻而不轻，即可就富，亦不贵矣。然亦有带食而贵者，何也？如庚寅、乙酉、癸亥、丙辰，此牛监薄命，乙合庚而不生癸，所以为贵，若合财存食，又可类推矣。如己未、甲戌、辛未、癸已，此合财存食之贵也。 又有印而兼透官煞者，或合煞，或有制，皆为贵格。如辛亥、庚子、甲辰、乙亥，此合煞留官也；壬子、癸卯、丙子、己亥、此官煞有制也。 至于化印为劫；弃之以就财官，如赵知府命，丙午、庚寅、丙午、癸已，则变之又变者矣。 更有印透七煞，而劫财以存煞印，亦有贵格，如庚戌、戊子、甲戌、乙亥是也。然此格毕竟难看，宜细详之。 三十六、论印绶取运印格取运，即以印格所成之局，分而配之。其印绶用官者，官露印重，财运反吉，伤食之方，亦为最利。 若用官而带伤食，运喜官旺印绶之乡，伤食为害，逢煞不忌矣。 印绶而用伤食，财运反吉，伤食亦利，若行官运，反见其灾，煞运则反能为福矣。 印用七煞，运喜伤食，身旺之方，亦为美地，一见财乡，其凶立至。 若用煞而兼带伤食，运喜身旺印绶之方，伤食亦美，逢官遇财，皆不吉。 印绶遇财，运喜劫地，官印亦亨，财乡则忌。 印格而官煞竞透，运喜食神伤官，印旺身旺，行之亦利。若再透官煞，行财运，立见其灾矣。 印用食伤，印轻者亦不利见财也。 三十七、论食神食神本属泄气，以其能生正财，所以喜之。故食神生财，美格也。财要有根，不必偏正叠出，如身强食旺而财透，大贵之格。若丁未、癸卯、癸亥、癸丑，梁丞相之命是也；己未、壬申、戊子、庚申，谢阁老之命是也。藏食露伤，主人性刚,如丁亥、癸卯、癸卯、甲寅，沈路分命是也。偏正叠出，富贵不巨，职甲午、丁卯、癸丑、丙辰，龚知县命是也。 夏木用财，火炎土燥，贵多就武。如己未、已巳、甲寅、丙寅，黄都督之命是也。若不用财而就煞印，最为威权显赫。如辛卯、辛卯、癸酉、己未，常国公命是也。若无印绶而单露偏官，只要无财，亦为贵格，如戊戌、壬戌、丙子、戊戌，胡会元命是也。 若金水食神而用煞，贵而且秀，职丁亥、壬子、辛巳、丁酉，舒尚书命是也。至于食神忌印，夏火太炎而木焦，透印不碍，如丙午、癸巳、甲子、丙寅，钱参政命是也。食神忌官，金水不忌，即金水伤官可见官之谓。至若单用食神，作食神有气，有财运则富，无财运则贫。 更有印来夺食，透财以解，亦有富贵，须就其全局之势而断之。至于食神而官煞竞出，亦可成局，但不甚贵耳。更有食神合煞存财，最为贵格。 至若食神透煞。本忌见财，而财先煞后，食以间之，而财不能党煞，亦可就贵。如刘提台命，癸酉、辛酉、己卯、乙亥是也。其余变化，不能尽述，类而推之可也。 三十八、论食神取运食神取运，即以食神所成之局，分而配之。食神生财，财重食轻，则行财食，财食重则喜帮身。官煞之方，俱为不美。 食用煞印，运喜印旺，切忌财乡。身旺，食伤亦为福运，行官行煞，亦为吉也。 食伤带煞，喜行印绶，身旺，食伤亦为美运，财则最忌。若食太重而煞轻，印运最利，逢财反吉矣。 食神太旺而带印，运最利财，食伤亦吉，印则最忌，官煞皆不吉也。 若食神带印，透财以解，运喜财旺，食伤亦吉，印与官煞皆忌也。 三十九、论偏官煞以攻身，似非美物，百大贵之格，多存七煞。盖控制得宜，煞为我用，如大英雄大豪杰，似难驾驭，而处之有方，则惊天动地之功，忽焉而就。此王侯将相所以多存七煞也。 七煞之格局亦不一：煞用食制者，上也，煞旺食强而身健，极为贵格。如乙亥、乙酉、乙卯、丁丑，极等之贵也。 煞用食制，不要露财透印，以财能转食生煞，而印能去食护煞也。然而财先食后，财生煞而食以制之，或印先食后，食太旺而印制，则格成大贵。如脱脱丞相命，壬辰、甲胡、丙戌、戊戌，辰中暗煞，壬以透之，戊坐四支，食太重而透甲印，以损太过，岂非贵格？若煞强食泄而印露，则破局矣。 有七煞用印者，印能护煞，本非所宜，而印有情，便为贵格。如何参政命，丙寅、戊戌、壬戌、辛丑，戊与辛同通月令，是煞印有情也。 亦有煞重身轻，用食则身不能当，不若转而就印，虽不通根月令，亦为无情而有情。格亦许贵，但不大耳。 有煞而用财者，财以党煞，本非所喜，而或食被制，不能伏煞，而财以去印存食，便为贵格。如周丞相命，戊戌、甲子，丁未、庚戌，戊被制不能伏煞，时透庚财，即以清食者，生不足之煞。生煞即以制煞，两得其用，尤为大贵。 又有身重煞轻，煞又化印，用神不清，而借财以清格，亦为贵格。如甲申、乙亥、丙戌、庚寅，刘运使命是也。 更有杂气七煞，干头不透财以清用，亦可取贵。 有煞而杂官者，或去官，或去煞，取清则贵。如岳统制命，癸卯、丁巳、庚寅、庚辰，去官留煞也。夫官为贵气，去官何如去煞？岂知月令偏官，煞为用而官非用，各从其重。若官格杂煞而去官留煞，不能如是之清矣。如沈郎中命，丙子、甲午、辛亥、辛卯，子冲午而克煞，是去煞留官也。 有煞无食制而用印当者，如戊辰、甲寅、戊寅、戊午、赵员外命是也。 至书有制煞不可太过之说，虽亦有理，然运行财印，亦能发福，不可执一也，乃若弃命从煞，则于外格详之。 四十、论偏官取运偏官取运，即以偏官所成之局分而配之。煞用食制，煞重食轻则助食，煞轻食重则助煞，煞食均而日主根轻则助身。忌正官之混杂，畏印绶之夺食。 煞用印绶，不利财乡，伤官为美，印绶身旺，俱为福地。 七煞用财，其以财而去印存食者，不利劫财，伤食皆吉，喜财怕印，透煞亦顺。 其以财而助煞不及者，财已足，则喜食印与帮身；财未足，则喜财旺而露煞。 煞带正官，不论去官留煞，去煞留官，身轻则喜助身，食轻则喜助食。莫去取清之物，无伤制煞之神。 煞无食制而用刃当煞，煞轻刃重则喜助煞，刃轻煞重，则宜制伏，无食可夺，印运何伤？七煞既纯，杂官不利。 四十一、论伤官伤官虽非吉神，实为秀气，故文人学士，多于伤官格内得之。而夏木见水，冬金见火，则又为秀之尤秀者也。其中格局比他格多，变化尤多，在查其气候，量其强弱，审其喜忌，观其纯杂，微之又微，不可执也。 故有伤官用财者，盖伤不利于民，所以为凶，伤官生财，则以伤官为生官之具，转凶为吉，故最利。只要身强而有根，便为贵格，如壬午、己酉、戊午、庚申，史春芳命也。 至于化伤为财，大为秀气，如罗状元命，甲子、乙亥、辛未、戊子，干头之甲，通根于亥，然又会未成局，化水为木，化之生财，尤为有情，所以伤官生财，冬金不贵，以冻水不能生木。若乃化木，不待于生，安得不为殿元乎？至于财伤有情，与化伤为财者，其秀气不相上下，如秦龙图命，己卯、丁丑、丙寅、庚寅，已与庚同根月令是也。 有伤官佩印者，印能制伤，所以为贵，反要伤官旺，身稍弱，始为秀气。如孛罗平章命，壬申、丙午、申午、壬申、伤官旺，印根深，身又弱，又是夏木逢润，其秀百倍，所以一品之贵。然印旺极深，不必多见，偏正叠出，反为不秀，故伤轻身重而印绶多见，贫穷之格也。 有伤官兼用财印者，财印相克，本不并用，只要干头两清而不相碍；又必生财者，财太旺而带印，佩印者印太重而带财，调停中和，遂为贵格。如丁酉、己酉、戊子、壬子，财太重而带印，而丁与壬隔以戊已，两不碍，且金水多而觉寒，得火融和，都统制命也。又如壬戌、己酉、戊午、丁巳，印太重而隔戊已，而丁与壬不相碍，一丞相命也。反是则财印不并用而不秀矣。 有伤官用煞印者，伤多身弱，赖煞生印以邦身而制伤，如己未、丙子、庚子、丙子，蔡贵妃也。煞因伤而有制，两得其宜，只要无财，便为贵格，如壬寅、丁未、丙寅、壬辰，夏阁老命是也。 有伤官用官者，他格不用，金水独宜，然要财印为辅，不可伤官并透。如戊申、甲子、庚午、丁丑，藏癸露丁，戊甲为辅，官又得禄，所以为丞相之格。若孤官无辅，或官伤并透，则发福不大矣。 若冬金用官，而又化伤为财，则尤为极秀极贵。如丙申、己亥、辛未、己亥，郑丞相命是也。 然亦有非金水而见官，何也？化伤为财，伤非其伤，作财旺生官而不作伤官见官，如甲子、壬申、己亥、辛未，章丞相命也。 至于伤官而官煞并透，只要干头取清，金水得之亦清，不然则空结构而已。 四十二、论伤官取运伤官取运，即以伤官所成之局，分而配之。伤官用财，财旺身轻，则利印比；身强财浅，则喜财运，伤官亦宜。 伤官佩印，运行官煞为宜，印运亦吉，伤食不碍，财地则凶。 伤官而兼用财印，其财多而带印者，运喜助印，印多而带财者，运喜助财。 伤官而用煞印，印运最利，伤食亦亨，杂官非吉，逢财即危。 伤官带煞，喜印忌财，然伤重煞轻，运喜印而财亦吉。惟七根重，则运喜伤食，印绶身旺亦吉，而逢财为凶矣。 伤官用官，运喜财印，不利食伤，若局中官露而财印两旺，则比劫伤官，未绐非吉矣。 四十三、论阳刃阳刃者，劫我正财之神，乃正财之七煞也。禄前一位，惟五阳有之，故为旭刃。不曰劫而曰刃，劫之甚也。刃宜伏制，官煞皆宜，财印相随，尤为贵显。夫正官而财印相随美矣，七煞得之，夫乃甚乎？岂知他格以煞能伤身，故喜制伏，忌财印；阳刃用之，则赖以制刃，不怕伤身，故反喜财印，忌制伏也。 阳刃用官，透刃不虑；阳刃露煞，透刃无成。盖官能制刃，透而不为害；刃能合煞，则有何功？如丙生午月，透壬制刃，而又露丁，丁与壬合，则七煞有贪合忘克之意，如何制刃？故无功也。 然同是官煞制刃，而格亦有高低，如官煞露而根深，其贵也大；官煞藏而不露，或露而根浅，其贵也小。若己酉、丙子、壬寅、丙午，官透有力，旺财生之，丞相命也。又辛酉、甲午、丙申、壬辰，透煞根浅，财印助之，亦丞相命也。 然亦有官煞制刃带伤食而贵者，何也？或是印护，或是煞太重而裁损之，官煞轻而取清之，如穆同知命，甲午、癸酉、庚寅、戊寅，癸水伤寅午之官，而戊以合之，所谓印护也，如贾平章命，甲寅、庚午、戊申、甲寅，煞两透而根太重，食以制之，所谓裁损也。如丙戌、丁酉、庚申、壬午，官煞竞出，而壬合丁官，煞纯而不杂。况阳刃之格，利于留煞，所谓取清也。 其于丙生午月，内藏己土，可以克水，尤宜带财佩印，若戊生午月，干透丙火，支会火乙，则化刃为印，或官或煞，透则去刃存印其格愈清。倘或财煞并透露，则犯去印存煞之忌，不作生煞制煞之例，富贵两空矣。 更若阳刃用财，格所不喜，然财根深而用伤食，以转刃生财，虽不比建禄月劫，可以取贵，亦可就富。不然，则刃与财相搏，不成局矣。 四十四、论阳刃取运阳刃用官，则运喜助官，然命中官星根深，则印绶比劫之方，反为美运，但不喜伤食合官耳。 阳刃用煞，煞不甚旺，则运喜助煞；煞若太重，则运喜身旺印绶，伤食亦不为忌。 阳刃而官煞并出，不论去官去煞，运喜制伏，身旺亦利，财地官乡反为不吉也。 四十五、论建禄月劫建禄者，月建逢禄堂也，禄即是劫。或以禄堂透出，即可依以用者，非也。故建禄与月劫，可同一格，不必加分，皆以透干支，别取财官煞食为用。 禄格用官，干头透出为奇，又要财印相随，不可孤官无辅。有用官而印护者，如庚戌、戊子、癸酉、癸亥，金丞相命是也。有用官而财助者，如丁酉、丙午、丁巳、壬寅，李知府命是也。 有官而兼带财印者，所谓身强值三奇，尤为贵气。三奇者，财官印也，只要以官隔之，使财印两不相伤，其格便大，如庚午、戊子、癸卯、丁巳，王少师命是也。 禄劫用财，须带食伤，盖月令为劫而以财作用，二财相克，必以伤食化之，始可转劫生财，如甲子、丙子、癸丑、壬辰，张都统命是也。 至于化劫为财，与化劫为生，尤为秀气。如己未、已巳、丁未、辛丑，丑与巳会，即以劫财之火为金局之财，安得不为大贵？所谓化劫为财也。如高尚书命，庚子、甲申、庚子、甲申，即以劫财之金，化为生财之水，所谓化劫为生也。 禄劫用煞，必须制伏台，如娄参政命，丁巳、壬子、癸卯、己未，壬合丁财以去其党煞，卯未会局以制伏是也。 至用煞而又财，本为不美，然能去煞存财，又成贵格。戊辰、癸亥、壬午、丙午，合煞存财，袁内阁命是也。 其禄劫之格，无财官而用伤食，泄其太过，亦为秀气。唯春木秋金，用之则贵，盖木逢火则明，金生水则灵。如张状元命，甲子、丙寅、甲子、丙寅，木火通明也；又癸卯、庚申、庚子、庚辰，金水相涵也。 更有禄劫而官煞竞出，必取清方为贵格。如一平章命，辛丑、庚寅、甲辰、乙亥、合煞留这也；如辛亥、庚写、甲申、丙寅，制煞留官也。 倘或两官竞出，亦须制伏，所谓争正官不可无伤也。 若夫用官而孤官无辅，格局更小，难于取贵，若透伤食便不破格。然亦有官伤并透而贵者，何也？如己酉、乙亥、壬戌、庚子，庚合乙而去伤存官，王总兵命也。 用财而不透伤食，便难于发端，然干头透一位而不杂，地支根多，亦可取富，但不贵耳。 用官煞重而无制伏，运行制伏，亦可发财，但不可官煞太重，致令身危也。 四十六、论建禄月劫取运禄劫取运，即以禄劫所成之局，分而配之。禄劫用官，印护者喜财，怕官星之逢合，畏七煞之相乘。伤食不能为害，劫比未即为凶。 财生喜印，宜官星之植根，畏伤食之相侮，逢财愈见其功，杂煞岂能无碍？禄劫用财而带伤食，财食重则喜印绶，而不忌比肩；财食轻则宜助财，而不喜印比。逢煞无伤，遇官非福。 禄劫用煞食制，食重煞轻，则运宜助煞；食轻煞重，则运喜助食。 若用煞而带财，命中合煞存财，则伤食为宜，财运不忌，透官无虑，身旺亦亨。若命中合财存煞，而用食制，煞轻则助煞，食轻则助食则已。 禄劫而用伤食，财运最宜，煞亦不忌，行印非吉，透官不美。若命中伤食太重，则财运固利，而印亦不忌矣。 禄劫而官煞并出，不论合煞留官，存官制煞，运喜伤食，比肩亦宜，印绶未为良图，财官亦非福运。 四十七、论杂格杂格者，月令无用，以外格而用之，其格甚多，故谓之杂。大约要干头无官无煞，方成格，如有官煞，则自有官煞为用，列外格矣。若透财尚可取格，然财根深，或财透两位，则亦以财为重，不取外格也。 试以诸格论之，有取五行一方秀气者，取甲乙全亥卯未、寅卯辰，又生春月之类，本是一派劫财，以五行各得其全体，所以成格，喜印露而体纯。如癸亥、乙卯、乙未、壬午，吴相公命是也。运亦喜印绶比劫之乡，财食亦吉，官煞则忌矣。 有从化取格者，要化出之物，得时乘令，四支局全。如丁壬化木，地支全亥卯未、寅卯辰，而又生于春月，方为大贵。否则，亥未之月亦是木地，次等之贵，如甲戌、丁卯、壬寅、甲辰，一品贵格命也。运喜所化之物，与所化之印绶，财伤亦可，不利官煞。 倒冲成格者，以四柱列财官而对面以冲之，要支中字多，方冲得动。譬如以弱主邀强官，主不众则宾不从。如戊午、戊午、戊午、戊午，是冲子财也；甲寅、庚午、丙午、甲午，是冲子官也。运忌填实，余俱可行。 有朝阳成格者，戊去朝丙，辛日得官，以丙戊同禄于巳，即以引汲之意。要干头无木火，方成其格，盖有火则无待于朝，有木财触戊之怒，而不为我朝。如戊辰、辛酉、辛酉、戊子，张知县命是也。运喜土金水，木运平平，火则忌矣。 有合禄成格者，命无官星，借干支以合之。戊日庚申，以庚合乙，因其主而得其偶。如己未、戊辰、戊辰、庚申，蜀王命是也。癸日庚申，以申合巳，因其主而得其朋，如己酉、癸未、癸未、庚申，起丞相命是也。运亦忌填实，不利官煞，理会不宜以火克金，使彼受制而不能合，余则吉矣。 有弃命保财者，四柱皆财而身无气，舍而从之，格成大贵。若透印则身赖印生而不从，有官煞则亦无从财兼从煞之理，其格不成。如庚申、乙酉、丙申、乙丑，王十万命造也。运喜伤食财乡，不宜身旺。有弃命从煞者，四柱皆煞，而日主无根，舍而从之，格成大贵。若有伤食，则煞受制而不从，有印则印以化煞而不从。如乙酉、乙酉、乙酉、甲申，李侍郎命是也。运喜财官，不宜身旺，食伤则尤忌矣。 有井栏成格者，庚金生三七月，方用此格。以申子辰冲寅午戌，财官印绶，合而冲之，若透丙丁，有巳午，以现有财官，而无待于冲，乃非井栏之格矣。如戊子、庚申、庚申、庚申，郭统制命也。运喜财，不利填实，余亦吉也。 有刑合成格者，癸日甲寅时，寅刑巳而得财官，格与合禄相似，但合禄则喜以合之，而刑合则硬以致之也。命有庚申，则木被冲克而不能刑；有戊已字，则现透官煞而无待于刑，非此格矣。如乙未、癸卯、癸卯、甲寅，十二节度使命是也。运忌填实，不利金乡，余则吉矣。 有遥合成格者，巳与丑会，本同一局，丑多则会巳而辛丑处官，亦合禄之意也。如辛丑、辛丑、辛丑、庚寅，章统制命是也。若命是有子字，则丑与子合而不遥，有丙丁戊已，则辛癸之官煞已透，而无待于遥，另有取用，非此格矣。至于甲子遥已，转辗求俣，似觉无情，此格可废，因罗御史命，聊复存之。为甲申、甲戌、甲子、甲子，罗御史命是也。 若夫拱禄、拱贵、趋乾、归禄、夹戌、鼠贵、骑龙、日贵、日德、富禄、魁罡、食神时墓、两干不杂、干支一气、五行具足之类，一切无理之格，既置勿取。即古人格内，亦有成式，总之意为牵就，硬填人格，百无一是，徒误后学而已。乃若天地双飞，虽富贵亦有自有格，不全赖此。而亦能增重基格，即用神不甚有用，偶有依以为用，亦成美格。然而有用神不吉，即以为凶，不可执也。 其于伤官伤尽，谓是伤尽，不宜一见官，必尽力以伤之，使之无地容身，现行伤运，便能富贵，不知官有何罪，而恶之如此？况见官而伤，则以官非美物，而伤以制之，又何伤官之谓凶神，而见官之为祸百端乎？予用是术以历试，但有贫贱，并无富贵，未轻信也，近亦见有大贵者，不知何故。然要之极贱者多，不得不观其人物以衡之。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>易学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《白夜行》]]></title>
    <url>%2F2016%2F10%2F07%2Fbaiyexing%2F</url>
    <content type="text"><![CDATA[总评趁着国庆快要结束前，抓紧时间把《白夜行》看完了，这类侦探小说我算是看透了，啥都不说，先给你铺垫个500页，你要是没兴趣看了（确实不看也罢），那就看不到最后5秒甚至2秒的高潮，哦……不对，是5页甚至2页的高潮结局？但是，人嘛就是为了寻求这种刺激带来的快感啊，所以，为了这5页的高潮，怎么也得看完啊！说实在的，这本书值得一看！这个豆瓣的书评写得很不错！ 说人性先讲讲这个人性吧，毕竟是侦探小说，肯定少不了很多的犯罪情节。但是作者也应该想到了单纯的恶和善其实也是很难存在的，写出来的小说也必定是没人看的，所以想点花套路，所以说嘛对于雪穗和亮司他们的做法肯定是罪恶的，我们作为充满正能量的好青年肯定是不赞成的。但是基于他们童年遭受的苦难，我想这也是一般人无法体会的，不正常的环境导致了他们不正常的发展。 说雪穗和亮司的爱说起来，我是不认为他们的爱是单纯的男女之爱，偏向于刑警笹垣的枪虾和虾虎鱼的互利共生关系，类似于这样的爱是什么爱？我也不清楚如何定义？对于亮司来说，他短短一生都是在为雪穗而活，亮司的小男孩和小女孩牵手的剪纸，希望他们能在白天里阳光下自由快乐的牵手行走。而雪穗应该也是深爱着亮司的，雪穗说：“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。”结尾是这样写的：“雪穗像人偶般面无表情。她冰冷地回答：‘我不知道。’”“只见雪穗正沿扶梯上楼，背影犹如白色的幽灵。”“她一次都没有回头。”为什么呢？因为她人生中的太阳没有了，所以她的灵魂没了，她成了幽灵！这是无奈又凄美的爱情！太阳没了，灵魂没了，爱没了，所以故事也就结束了！ 小男孩对于“手牵手在太阳下散步”的念想，是那段素净却因此注定无法实现的爱情。就是因为这段爱情，东野圭吾才保留了日本文学一向迷恋的永恒悲伤。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客测试]]></title>
    <url>%2F2016%2F09%2F25%2Ftest%2F</url>
    <content type="text"><![CDATA[Why因为无聊实在是感觉wordpress过于臃肿，而且没有好看简洁的主题，说干就干，立马就把wordpress博客内容迁移，其实wordpress也才弄了几天那就折腾一下 Test试试看我写的md格式是否正确看看next主题效果 Note首先，使用hexo-migrator-wordpress插件将wordpress文件迁移,对markdown的不足和常用的CSS样式进行扩展，比如图片居中，查了hexo标签插件的image插件，先是没注意那个[class name]后来才想到这是CSS样式，并且可以自己添加自定义样式，我使用的next主题，next主题中/source/_custom/custom.styl可以添加自定义CSS，但是我添加的图片居中没实现，我不服啊……F12检查发现CSS样式加了下划线，往前找，发现原来的CSS加了!important,于是我也给自己的样式加了!important,呵呵……之后，为了绑定github pages的域名,需要在/source文件夹中新建CNAME文件，然后填上自己要绑定的域名；绑定coding page可以直接在page服务中绑定；写文章要想有首页文章折叠，阅读全文的按钮，可以自己在md文章中加入&lt;!--more--&gt;,API里也没看到啊，也是醉了 PS：chrome清楚缓存快捷键：ctrl+shift+del 接下来，就是对评论，搜索，图标的一些优化的，相信也没什么大问题了，目前看来hexo还是很简洁，用markdown格式写文章也是我想要的，所以继续加油！ 2016.9.29更新今天添加了swiftype搜索，并且更改了搜索框的样式；swifteype在我之前没添加sitemap时一直显示在crawling中，很是让人蛋疼，后来搜索之后才发现有hexo-generator-sitemap这个插件，生成了网站sitemap，至此告一段落^_^]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《我的零点时刻》]]></title>
    <url>%2F2016%2F09%2F25%2Fmy-zero-time%2F</url>
    <content type="text"><![CDATA[以前是不喜欢看这些书的，看到这种书名和封面就已经没有翻开的欲望。今天，论文有点看不下去了，就去实验室翻了翻书，都是些小宝的非主流书，《我的零点时刻》毕竟是朱军签过名的，那就拿来看看吧。 看了之后，总体感觉朱军很有文化，他是一个偏重传统文化的爱国之人，整本书是充满正能量的，那一辈人的踏实、努力、执着确实值得我们去学习。对于我们这一辈人来说，浮躁多了一些，负能量多了一些，急功近利多了一些。娱乐化的节目充斥了整个视野，但是除了娱乐大多却没有什么价值，没法引起思考和共鸣。所以以后，看一个节目，我也会思考和判断这个节目到底有没有价值？ 对于我这个把不住口的执、犟性格来说，得时刻谨记舌头地下压死人啊……有句话让我印象深刻，书里说是季羡林总结的，叫：“假话全不说，真话说不全”。恩，有道理，别傻乎乎的给你说得一点面子都没有，毕竟，人啊，都还是希望体面得活着。另外一句玩笑话说得也很有意思，“这年头，说真话得罪朋友，说假话得罪自己，那就让我们说笑话吧。说假话迟早完蛋，说真话立马完蛋，说笑话顶多被骂扯淡”，哈哈……得好好说话啊。老舍也说过，语言的有力无力，决定于思想是否精辟，感情是否浓厚，字句对安排是否得当，而并不靠一些土话甚至脏话给打气撑腰。所以，做一个会说话的有用好人！ 此外，做一件事不要去抱怨，没用，要不你就不干，要不你承担不了不干的后果，你就开开心心去干，不要觉得委屈，每天苦哈哈的伤己伤人。所以说没事弄点鸡汤喝喝也是有必要的嘛，鸡汤鸡汤，他毕竟还是有营养的嘛…所以，即使我知道了很多真相，我还是要努力前行，因为我们承载了中国带来的荣耀，我们也应该为它承担苦难，贡献自己的力量，而不是一味的批评而不是去解决问题，我还是我，那个充满正能量的阳光少年！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《平凡的世界》]]></title>
    <url>%2F2016%2F09%2F20%2Fordinary-world%2F</url>
    <content type="text"><![CDATA[这次我看的是《平凡的世界》普及本，删除了关于官场及人事变动的一些事，非常好看，四百多页的书，加起来一天不到的时间就看完了，因为刻画的十分生动，印象深刻的有那么一句话是说，哪敢借一万，借人八九十块手都抖，哎呀，笑死我了，很真实也很有意思，重要的是很能带入情景的书最后还能让你有所思考，也难怪拿了茅盾文学奖。 这个小说是围绕孙家两兄弟来写的，大哥孙少安因为出身不好，家庭环境差就不敢娶和他亲梅竹马但是比他家境好的田润叶，造就了田润叶的悲剧，对孙少安来说可能也是一种遗憾。兄弟孙少平喜爱读书，有一定文化，但是没当成教师去了煤矿，坚持读书和学习，这是很不容易的，田晓霞也是因为这样才欣赏和喜欢他的，最后两人相恋，而田晓霞出身也很好，但是最后却因为记者去灾区报道救人牺牲，这对于孙少平是很大的打击，心酸啊。。。两兄弟都勤奋刻苦但又是那种自尊心极强的人，环境的压力，生活的压力造就了他们的一生…… 对于我来说，金凤凰是对现在很多农村大学生或者农村出来的优秀青年的称呼，而我也是其中之一，不可置否我们得去思考这个问题，自尊或者是过度的自尊对别人会不会有伤害？你的品位是不是low到与别人无法交流但是你却不以为然？所以经济基础决定上层建筑这句话始终是没有问题的，别想太多，多挣钱才是硬道理啊，别让你的下一代重蹈覆辙，别让自己后悔！ 摘抄一句：刹那间我真想令时光停驻，好让我回顾自己，回顾失去的年华，缅怀那一个穿连衣裙和瘦窄的短衫的小女孩…让我追悔少年时代我心灵的愚昧无知，它轻易地错过了我一生中未来可以获得的欢乐和幸福！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[零散笔记]]></title>
    <url>%2F2016%2F09%2F20%2Fstudylist%2F</url>
    <content type="text"><![CDATA[2016.09.20之前笔记学习笔记7.10 sass和compassSass是一个CSS3的扩展语言, 它提供了丰富的特性使得编写样式更加容易: 嵌套样式, 变量定义, 扩展, mixin等等;Compass是一个使用了Sass的库, 它将很多常用样式打包成了一些模块, 我们可以在自己的项目中使用这些模块, 比如模块reset可以用来将不同浏览器的差异抹平, css3则用来生成CSS3相关的属性等. 12gem install compasscompass create projectNamesublime 插件: emmet, html-css-js 7.11ubuntu16.04安装网易云音乐 源可换成阿里源;安装shadowsocks客户端时, linux使其自启动可在/etc/rc.local中 exit0 前加入命令 sudo ssolocal -c /etc/shadowsock.json -d start 7.12mongodb需要安装mongdb-server和mongodb-clients后可以不用一直输入./mongod --dbpath ../blog/删除数据库: db.dropDatabase()删除集合: db.collection.drop() 7.26今天复习了下bootstrap, 这几天都有点颓废, 把亮剑小说看完了, 瞬间热血沸腾, 其实电视里拍的只是小说的一部分啊, 我想我应该学习老李的是勇敢顽强, 为了真理永远不能屈服, 那么才能培养出一生正气至于文革, 我想说的是很同意知乎上一个知友的说法, 对于日本篡改教科书, 不承认南京大屠杀, 当局强烈谴责; 那么对于自己的wg, 64, 为什么不能正确面对; 我希望未来的中国是民主的正气的自由的积极向上的, 我想中华民主几千年文明的底蕴传承, 中国未来是有希望的。而我也要在其中做出自己的一份贡献, 最近看了很多不是那么美好的事实, 无知是幸福的, 但是真理是我们应该追求的, 即使痛苦。但是庆幸的是, 我还是个积极向上的阳光青年值得注意的是别那么傲娇了, 嘴下积德, 好好的读好书, 好好学习本领(听着 《再见 小时候》好听)&amp;amp; nbsp表示Non-breaking space使用bootstrap框架不要直接在元素里加rowclass 8.02JS对象的属性用.(点)叠加, 数组用 [下标] 来访问。 8.04JS中str是不变的, str.toLowerCase()/str.toUpperCase()不能改变原字符串 8.14JS中break, continue可以加标签, break: label跳转到该标签位置 8.17debian开机自启动, 网上查看开机自启动脚本位于/etc/local, 但是假如脚本无法启动, 也没有/etc/rc.d/rc.local这个文件, 通过vim /etc/inittab查看需要启动服务的script的放置路径, 我的vps位于/etc/init.d/rc.local, 直接在这个里添加脚本可以开机自启动 8.28ll命令: 打开.bashrc文件修改ll, 并使其生效 source .bashrc 8.31rtl8188eus无线网卡内核驱动, (来自: https://github.com/lwfinger/)rtl8188eu通过此处代码编译, 编译流程: 123configuremake allmake install 双系统linux系统时间要比windows快8小时, Windows/Ubuntu 双系统用户会发现在 Ubuntu 里面的时间正常的情况下Windows的系统时间被改到8小时前。 原来 Linux 操作系统是以 CMOS 时间做为格林威治标准时间, 再根据系统设置的时区来确定目前系统时间。但是Windows 会直接修改CMOS 时间。而中国的时区是+8区, 所以才会造成时间被调整了-8个小时。所以您可以让 Windows 去使用时区或者让 Ubuntu 使用本地时间。修改 Windows 使用时区的方法是在注册表: HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\ 下增加一个名为 RealTimeIsUniversal 的REG_DWORD 键, 并赋值为 1。而让Ubuntu 使用本地时间的方法是: sudo gedit /etc/default/rcS 把里面的 UTC=yes 改为 UTC=no (来自: http: //blog.chinaunix.net/uid-8305736-id-2033022.html) 互联网网络协议 实体层: 把电脑连接起来的物理手段。它主要规定了网络的一些电气特性, 作用是负责传送0和1的电信号。 链接层: 确定了0和1的分组方式。以太网协议: 一帧(frame): Head+Data; Head包含发送和接受者的信息, 即网卡地址(MAC地址), 每个网卡的地址是独一无二的; 广播: (arp协议识别接收方网卡地址)以太网它不是把数据包准确送到接收方, 而是向本网络内所有计算机发送, 让同一子网每台计算机自己判断MAC地址与标头中接受方的MAC地址, 是否为接收方。(数据包的定义、网卡的MAC地址、广播的发送方式) 网络层 必须找到一种方法, 能够区分哪些MAC地址属于同一个子网络, 哪些不是。如果是同一个子网络, 就采用广播方式发送, 否则就采用”路由”方式发送。(“路由”的意思, 就是指如何向不同的子网络分发数据包, 这是一个很大的主题); 这就导致了”网络层”的诞生, 它的作用是引进一套新的地址, 使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”, 简称”网址”。”网络层”出现以后, 每台计算机有了两种地址, 一种是MAC地址, 另一种是网络地址。两种地址之间没有任何联系, MAC地址是绑定在网卡上的, 网络地址则是管理员分配的, 它们只是随机组合在一起。网络地址帮助我们确定计算机所在的子网络, MAC地址则将数据包送到该子网络中的目标网卡。因此, 从逻辑上可以推断, 必定是先处理网络地址, 然后再处理MAC地址。 规定网络地址的协议叫IP协议, IP4为32地址, 前24位为网络部分, 后8位为主机部分, 处于同一子网络的计算机的网络部分应相同。所谓”子网掩码”, 就是表示子网络特征的一个参数。它在形式上等同于IP地址, 也是一个32位二进制数字, 它的网络部分全部为1, 主机部分全部为0。判断方法是将两个IP地址与子网掩码分别进行AND运算(两个数位都为1, 运算结果为1, 否则为0), 然后比较结果是否相同, 如果是的话, 就表明它们在同一个子网络中, 否则就不是。IP数据包直接放进以太网中的数据部分。不在同一个子网络中需要通过网关转发, 而使用ARP协议可以得到同一个子网络内的主机MAC地址。 传输层: 我们还需要一个参数, 表示这个数据包到底供哪个程序(进程)使用。这个参数就叫做”端口”(port), 它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口, 所以不同的程序就能取到自己所需要的数据。。”传输层”的功能, 就是建立”端口到端口”的通信。相比之下, “网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口, 我们就能实现程序之间的交流。因此, Unix系统就把主机+端口, 叫做”套接字”(socket)。UDP协议: UDP数据包, 也是由”标头”和”数据”两部分组成。”标头”部分主要定义了发出端口和接收端口, “数据”部分就是具体的内容。然后, 把整个UDP数据包放入IP数据包的”数据”部分, 而前面说过, IP数据包又是放在以太网数据包之中的。特点是简单, 但可靠性差。TCP协议: 可以近似认为, 它就是有确认机制的UDP协议, 每发出一个数据包都要求确认。如果有一个数据包遗失, 就收不到确认, 发出方就知道有必要重发这个数据包了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包和UDP数据包一样, 都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制, 理论上可以无限长, 但是为了保证网络的效率, 通常TCP数据包的长度不会超过IP数据包的长度, 以确保单个TCP数据包不必再分割。(以太网数据包的数据部分, 最大长度为1500字节, 超出需分割) 应用层: “应用层”的作用, 就是规定应用程序的数据格式。举例来说, TCP协议可以为各种各样的程序传递数据, 比如Email、WWW、FTP等等。那么, 必须有不同协议规定电子邮件、网页、FTP数据的格式, 这些应用程序协议就构成了”应用层”。这是最高的一层, 直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此, 现在的以太网的数据包就变成下面这样。 上网设置 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址(把网址转换为IP地址) 9.5shadowsocks, 500 internal privoxy error.怎么解决？(https: //www.zhihu.com/question/40771057)以管理员身份运行CMD, 执行: 123netsh interface ipv4 resetnetsh interface ipv6 resetnetsh winsock reset 重启电脑, 解决。 9.10 Vim 编辑文件报错: Swap file &quot;Hello.java.swp&quot; already exists! 问题原因: Vim 编辑 Hello.java 文件的时候, 非正常退出, 然后又重新再 Vim 这个文件一般都会提示这个。 解决办法: 进入被编辑的文件目录, 比如: Hello.java 我放在 /opt 目录下, 那就先: cd /opt, 然后: ls -A, 会发现有一个: .Hello.java.swp, 把这个文件删除掉: rm -f .Hello.java.swp, 然后重新 Vim 文件即可。 9.20 wordpress安装: LAMP; 数据库建立; 5分钟安装; 插件授权录后, 执行 12sudo chown -R www-data /var/www/wordpresssudo chmod -R 775 /var/www/wordpress 这样就完全解决问题了.注意了, 不需要把/var/www/目录的所有者也设置为www-data, 而只需要设置wordpress文件夹的所有者.wp-config.php里加入下面代码: 123define("FS_METHOD", "direct"); define("FS_CHMOD_DIR", 0777); define("FS_CHMOD_FILE", 0777); 2017-08-27更新 unbuntu引导设置默认由于双系统问题, 每次启动都需要手动选择启动, 查阅资料发现可以对其引导项默认值进行修改, sudo vim /etc/default/grub打开grub文件进行修改, GRUB_DEFAULT=0修改为想要默认启动的序号, 序号默认从0开始, 我的windows为第五项序号为4改为GRUB_DEFAULT=4 vps中的shadowsocks版本更换由于之前python版本的shadowsocks经常自动关闭, 而且现在更新也不够及时, 选择shadowsocks-libev参见安装shadowsocks-libev]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>IT</tag>
      </tags>
  </entry>
</search>
